[{"content":"题意：将一个数组a分成两个数组b和c，使得$a_i = b_i + c_i$，同时b数组要单调不减，c数组要单调不增，问$\\sum_{i=1}^n \\lvert b_i\\rvert + \\lvert c_i\\rvert$可能的最小值\n首先一个突破口就是发现一点：贪心地想，$b_i$、$c_i$确定后，$b_{i+1}$、$c_{i+1}$其中一个是等于上一个的，因为要使得某一个数组尽量上升（或者下降）地慢一些\n所以可以发现，一旦$b_1$确定后，整个b、c数组就确定了\n还有一点是将c数组取反（全部加个负号），这样b和c都是单调不减的数组了（至于为什么，后面中位数看明白后回头看就懂了）\n这样的话$a_i = b_i - c_i$\n对于第$i + 1$个，如果$a_{i} \\ge a_{i+1}$，则 $$ \\begin{aligned} b_{i+1} \u0026amp;= b_i \\newline c_{i+1} \u0026amp;= b_{i+1} - a_{i+1} \\newline \u0026amp; = a_i + c_i - a_{i+1} \\newline \u0026amp;= c_i + (a_i - a_{i+1}) \\end{aligned} $$ 否则 $$ \\begin{aligned} c_{i+1} \u0026amp;= c_i \\newline b_{i+1} \u0026amp;= a_{i+1} + c_{i+1} \\newline \u0026amp; = a_{i + 1} + b_i - a_{i} \\newline \u0026amp;= b_i + (a_{i + 1} - a_{i}) \\end{aligned} $$ 整合下就是 $$ \\begin{aligned} b_{i+1} \u0026amp;= b_i + \\max(0, \\space a_{i+1} - a_i) \\newline c_{i+1} \u0026amp;= c_i + \\max(0, \\space a_i - a_{i+1}) \\end{aligned} $$ 前面说了，假设$b_1$确定了，后面的就全确定了， 假设$b_1 = x$, 则后面的就为${b_1 + \\max(0, a_2 - a_1), \\space b_2 + \\max(0, a_3 - a_2), \\space \\ldots}$\n设这个确定$b_1$后的b数组为p数组，c数组为q数组，变动x只会让所有的p和q数组都同时变动，即 $$ res = \\sum_{i=1}^n \\lvert p_i - t \\rvert + \\lvert q_i - t \\rvert $$ 求$res$最小，显然t就是p和q拼接后的数组(设为arr)的中位数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 2e5 + 5; long long a[N], arr[N + N]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;a[i]); } arr[1] = a[1]; for (int i = 2; i \u0026lt;= n; ++i) { arr[i] = arr[i - 1] + max(0ll, a[i] - a[i - 1]); arr[i + n] = arr[i + n - 1] + max(0ll, a[i - 1] - a[i]); } nth_element(arr + 1, arr + n, arr + n + n + 1); long long ans = 0; for (int i = 1; i \u0026lt;= n + n; ++i) { ans += abs(arr[i] - arr[n]); } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } ","date":"2022-02-13T11:12:00+08:00","permalink":"https://example.com/2022/arc123d-inc-dec-decomposition/","title":"arc123D Inc, Dec - Decomposition"},{"content":"题意：把一个数拆成x个数相加，这x个数的十进制每一位都必须是 1,2,3中的数\n分治地思维想\n将数拆成两部分 :\n（部分a：除了个位的其余位的数）（部分b：个位的数）\n如果”部分b“最少可以拆成x次，同时“部分a”拆的次数不超过x次，则整体的次数便是x\n例如 29 可以拆成 （部分a：2） 和 （部分b：9）\n可以发现9的最少次数为3次（3, 3, 3），而”部分a“的最少次数为1次（2），则29可以拆3次（23，3，3）\n注意到“部分b”是可以向前借位的，此时“部分b”的便可以在实现拆4次以上，\n我们可以枚举“部分b”的次数，然后看看“部分a”的次数是否满足上述条件，从小枚举，符合便return，则答案就是最小\n其实可以发现，如果“部分b”的次数为5时，b的范围就是$0 \\le b \\le 9$，其中0到5的范围是向前借了位，5到9是没有借位的范围。\n这说明次数是不会超过5次的，保险起见枚举9次\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;unordered_map\u0026gt; using namespace std; typedef long long ll; unordered_map\u0026lt;ll, int\u0026gt; mp; int cal(ll x) { if (x == 0) return 0; if (mp.count(x)) return mp[x]; for (int i = 1; i \u0026lt;= 9; ++i) { // 枚举次数 for (int b = i; b \u0026lt;= i * 3; ++b) { // 枚举部分b是什么 if ((x - b) % 10 != 0) continue; if (cal((x - b) / 10) \u0026lt;= i) return mp[x] = i; } } } int main() { int t = 1; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { ll n; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); printf(\u0026#34;%d\\n\u0026#34;, cal(n)); } return 0; } ","date":"2022-02-11T13:31:21+08:00","permalink":"https://example.com/2022/arc123c-1-2-3-decomposition/","title":"Arc123C 1, 2, 3 - Decomposition"},{"content":"题意：在一个$n\\times n$的格子中，.表示白色，#表示黑色，问你把k个白色染成红色并且最后是个连通（所有红色都同属一个连通块）的方案数\n一开始想到状压，后来发现单行连通，此行不连通但相邻行能使他们连通的情况不好处理\n后来发现可以dfs爆搜，一开始想不到怎么不重不漏地搜出来，用set去重计数，跑了400+ms的速度，很是不满意\n后来察觉到，往时搜索立刻回溯的方案太慢了，而且有重复遍历，所有采用最后再全部回溯为原来模样的方式遍历，跑了17ms\n可以这么理解，包括该点的走法，和不包括该点的走法， 最后统一回溯，有效防止后面dfs时再走一次\n记录一下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int n, m; char g[10][10]; int vis[10][10], ans = 0; pair\u0026lt;int, int\u0026gt; dxy[] = { {0, 1}, {0, -1}, {1, 0}, {-1, 0} }; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; isp; void dfs(int num) { if (num == 0) return ans += 1, void(); vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; nxt, tmp = isp; for (auto [x, y] : tmp) { for (auto [dx, dy] : dxy) { int nx = x + dx, ny = y + dy; if (nx \u0026lt;= 0 || ny \u0026lt;= 0 || nx \u0026gt; n || ny \u0026gt; n) continue; if (g[nx][ny] != \u0026#39;.\u0026#39;) continue; g[nx][ny] = \u0026#39;@\u0026#39;; isp.push_back({nx, ny}); nxt.push_back({nx, ny}); dfs(num - 1); g[nx][ny] = \u0026#39;#\u0026#39;; isp.pop_back(); } } for (auto [x, y] : nxt) { g[x][y] = \u0026#39;.\u0026#39;; } } int main() { scanf(\u0026#34;%d %d\\n\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%s\\n\u0026#34;, g[i] + 1); } for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { if (g[i][j] == \u0026#39;.\u0026#39;) { g[i][j] = \u0026#39;@\u0026#39;, isp.push_back({i, j}); dfs(m - 1); g[i][j] = \u0026#39;#\u0026#39;, isp.pop_back(); } } } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } ","date":"2022-02-09T13:29:05+08:00","permalink":"https://example.com/2022/abc211e-red-polyomino/","title":"Abc211E Red Polyomino"},{"content":"题意：给你x，y，求 $\\sum_{i=0}^x \\sum_{j = \\lbrack i = 0 \\rbrack}^y \\lbrack i \\And j = 1\\rbrack \\lfloor log_2(i + j) + 1 \\rfloor$\n对于这种题（求范围内符合条件的数对）类型的题，有点类似19年南昌icpc的C题的数位dp思路\n首先 $i \\And j = 1$ 是一个切入口，一开始想错没注意到这个条件，后来发现后便觉得这题的难度小了一大半\n然后要了解到$\\lfloor log(x) + 1\\rfloor$可以理解成二进制最高位1的位置\n最后就是求和，定死最高位1在i的条件进行累加，注意，对于两个数的某一个数，如果i超过了或者等于他的最高位的位数，则这个数在dp的时候要有 limit限制\n看代码好理解些\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 1e5 + 5, mod = 1e9 + 7; int a[40], b[40], dp[35][2][2][2]; int change(int x, int* num) { int len = 0; fill_n(num, 40, 0); while (x) num[++len] = x % 2, x /= 2; return len; } int dfs(int id, int limit1, int limit2, int ish) { // ish看看当前是不是最高位 if (id == 0) return 1; int\u0026amp; res = dp[id][limit1][limit2][ish]; if (res != -1) return res; res = 0; int up1 = limit1 ? a[id] : 1; int up2 = limit2 ? b[id] : 1; for (int i = 0; i \u0026lt;= up1; ++i) { for (int j = 0; j \u0026lt;= up2; ++j) { if (i \u0026amp; j) continue; if (ish \u0026amp;\u0026amp; i + j == 0) continue; res += dfs(id - 1, limit1 \u0026amp;\u0026amp; i == up1, limit2 \u0026amp;\u0026amp; j == up2, 0); if (res \u0026gt;= mod) res %= mod; } } return res; } void problem() { int n, m; scanf(\u0026#34;%d %d\\n\u0026#34;, \u0026amp;n, \u0026amp;m); int len1 = change(n, a), len2 = change(m, b); int len = max(len1, len2); int ans = 0; memset(dp, -1, sizeof dp); for (int i = len; i \u0026gt;= 1; --i) { ans += 1ll * i * dfs(i, i \u0026gt;= len1, i \u0026gt;= len2, 1) % mod; if (ans \u0026gt;= mod) ans %= mod; } printf(\u0026#34;%d\\n\u0026#34;, ans); } int main() { int t = 1; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { problem(); } return 0; } ","date":"2022-02-08T13:31:52+08:00","permalink":"https://example.com/2022/2020icpc%E4%B8%8A%E6%B5%B7%E7%AB%99c.-sum-of-log/","title":"2020ICPC上海站C. Sum of Log"},{"content":"题意：S(x)表示x十进制上的所有数相加的和，问n范围内，$0 \\le A \\le B$ 并且 $S(A) \u0026gt; S(B)$ 的数对个数\n本题首先要想到的是用数位dp解决，然后就是状态的定义，本题状态定义的话刷多了dp的都有感觉，和（NC19158 失衡天平）的定义差不多的思想\n定义 dp[id][dif] 为最低位到第id位上，两个数和的差\n然后数位dp转移，有两个限制的limit的这种题还是很少遇到的，记录一下，这种题应该一般是对单范围内符合某种条件的数对的个数\n递归写好理解，注意对于两个limit限制条件需要开多两个维度，不然T到飞起\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const ll mod = 1e9 + 7; int num[110]; int init = 1000; ll dp[110][2005][2][2]; ll dfs(int pos, int dif, int limit1, int limit2) { if (pos == 0) return dif \u0026gt; init; ll\u0026amp; res = dp[pos][dif][limit1][limit2]; if (res != -1) return res; res = 0; int up = (limit1 ? num[pos] : 9); for (int i = 0; i \u0026lt;= up; ++i) { // B int len = (limit2 ? i : 9); for (int j = 0; j \u0026lt;= len; ++j) { // A res = (res + dfs(pos - 1, dif + j - i, limit1 \u0026amp;\u0026amp; (i == up), limit2 \u0026amp;\u0026amp; (j == len))) % mod; } } return res; } void problem() { memset(dp, -1, sizeof dp); string s; cin \u0026gt;\u0026gt; s; int cnt = 0; while (s.size()) { num[++cnt] = s.back() - \u0026#39;0\u0026#39;; s.pop_back(); } cout \u0026lt;\u0026lt; dfs(cnt, init, 1, 1) \u0026lt;\u0026lt; endl; } int main() { problem(); return 0; } ","date":"2022-02-08T09:14:53+08:00","permalink":"https://example.com/2022/nc2020%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%AC%E5%85%AD%E5%9C%BAh%E9%A2%98-harmony-pairs/","title":"NC2020多校训练营（第六场）H题 Harmony Pairs"},{"content":"题意：一个数被称为lunlun数（无前导0）则说明每个相邻的数相差不超过1，例如345，问你从1开始第n个lunlun数是几\n还记得windy数（数位dp入门题）吗，对，如果让我们n以内的windy数的个数显然可以数位dp\n那么这道题也是同理，随着数的增加，lunlun数的个数也不减，具有单调性，所以我们可以求一个x内的lunlun数的个数，看看其是不是超过n个，那么问题就变成了找第一个x其范围内lunlun数的个数大于等于n，显然二分找\n其实记录本题的目的是记录类似这种前导0需要特判数位dp的处理方式代码16~20行\n当然，还有一种办法就是dfs多传一个参，标志是否前面全是0，然后再类似代码中的判断一样进行处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; int num[20]; ll dp[20][13]; ll dfs(int id, int pre, int limit) {// pre为上一个数填了什么，12表示前面全是0， if (id == 0) return 1; ll\u0026amp; ret = dp[id][pre], res = 0; if (!limit \u0026amp;\u0026amp; ret != -1) return ret; int up = limit ? num[id] : 9; for (int i = 0; i \u0026lt;= up; ++i) { if (pre == 12) { res += dfs(id - 1, i == 0 ? 12 : i, limit \u0026amp;\u0026amp; i == up); } else if (abs(pre - i) \u0026lt;= 1){ res += dfs(id - 1, i, limit \u0026amp;\u0026amp; i == up); } } if (!limit) ret = res; return res; } ll solve(ll x) { int len = 0; while (x) { num[++len] = x % 10; x /= 10; } return dfs(len, 12, 1) - 1; } int main() { memset(dp, -1, sizeof dp); int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); ll l = 1, r = 3234566667ll, ans = 1; while (l \u0026lt;= r) { ll mid = (l + r) \u0026gt;\u0026gt; 1; if (solve(mid) \u0026gt;= n) r = mid - 1, ans = mid; else l = mid + 1; } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } ","date":"2022-02-07T16:14:40+08:00","permalink":"https://example.com/2022/abc161d-lunlunnumber/","title":"Abc161D LunlunNumber"},{"content":"前言 这是一篇自己对各类动态规划和动态规划技巧的总结，未完待续，后续会一边刷题一边添加内容\n关于填表法和刷表法 在我们做的题中，一般填表法用得较多，但两者各有好处\n一般来说动态规划中，状态的转移可以理解成图论中的一条有向边($u \\rightarrow v$)，我们以 u 作为已求出来的状态，v 为需要求的状态，那么填表法便是将目光放在 v 上，去寻找已知的 u 来更新；而刷表法则是将目光放在u 上，利用已知的 u 来去更新可抵达的 状态 v\n具体来说填表法会写成这样 ：dp[i] = dp[i - j] + w\n而刷表法会写成这样： dp[i + j] = dp[i] + w\n填表法的好处不多说，毕竟平时用得最多的便是填表法\n而刷表法的好处便是：一般对于一道题中，若是在求本状态时，寻找需要利用到的状态比较困难时，则可以考虑用刷表法\n关于空间优化 动态规划中，真要考起动态规划来，感觉很少卡空间，但还是说说吧\n一般我碰见比较常见的空间优化的方式有两种：\n一种是状态转移时，本状态的维度只用到了上一个状态的维度，即 dp[i][x] = dp[i - 1][y] 这种形式，这样的优化方式有很多，例如开数组时将那一维开成2的大小，又例如直接把那一维删了\n另一种是多维度状态数组超内存的情况，一般来说这种的特点是，有一维可以利用其它几维间接推出来，固优化方式是直接将那一维删了，然后转移时，那一维的信息直接利用其它维信息推出来。例题 [NOIP2010]乌龟棋 : 本题不能直接开5维度的空间\n关于状态转移——tmp数组 为什么要总结这个？个人感觉这个真的很重要，在树形背包的应用上有奇效\ntmp数组只是我自己的叫法，具体怎么用得慢慢解释\n对于上述所说的 \u0026ldquo;本状态的维度只用到了上一个状态的维度\u0026rdquo; 的空间优化，有人是这么处理的\n1 2 3 4 5 6 int dp[2][N]; // 声明 for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= m; ++j) { dp[i \u0026amp; 1][j] = max(dp[i \u0026amp; 1][j], dp[!(i \u0026amp; 1)][j - x] + y); } } 但如果使用tmp数组则可以这样，有两种方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int dp[N], tmp[N]; // 声明 /* 方式一 */ for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= m; ++j) tmp[j] = dp[j]; // 先复制，记录没转移前的状态 for (int j = 1; j \u0026lt;= m; ++j) { dp[j] = max(dp[j], tmp[j - x] + y); // 在转移 } } /* 方式二 */ for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= m; ++j) tmp[j] = -inf; // 先初始化 for (int j = 1; j \u0026lt;= m; ++j) { tmp[j] = max(tmp[j], dp[j - x] + y); // 再转移 } for (int j = 1; j \u0026lt;= m; ++j) dp[j] = tmp[j]; // 最后复制回dp数组里面 } 使用tmp数组的好处是思路清晰，处理简单\n注意，方式一和方式二各有好处，不同题目的初始条件不同两者的效果可能会不同\n关于更新状态 寻常来说我们更新状态直接利用递推便可\n但有些题目最终利用到的状态并没有多少，但直接递推又不好找转移的状态，并且直接递推复杂度可能顶不住\n固一般来说这样的状态转移可以考虑记忆化搜索，类似剪枝一般在寻找状态时只搜索自己需要用到的状态，同时，有时状态可能是无限的，也可能超出了数组的下标承受范围，则可以考虑使用map存储状态\n关于时间复杂度 一般来说，我们dp的时间复杂度可以从空间大小来推测，因为一般我们的状态若是几乎都要遍历一遍的话，其复杂度的下限便是其空间的大小\n关于寻找具体方案 对于这种题目，求最后的答案时可以像寻常般进行dp，而反过头来求出答案来源的具体方案我一般是dfs往回找，时间负责度也不高\n对于求解对字典序有要求的具体方案，我会反过来dp，然后正过来dfs找具体方案\n当然，也看过别的求解具体方案的方式：多开一个数组记录转移的路线，然后像是遍历图一样找路线\n线性dp 线性dp——背包 对于背包真的不想多说了，刷多了自然有就感觉了，我的《背包问题》这篇博客我也总结得不少了\n例题 AcWing 2. 01背包问题 01背包入门题 AcWing 3. 完全背包问题 完全背包入门题 AcWing 4. 多重背包问题 I 多重背包入门题 AcWing 5. 多重背包问题 II 多重背包进阶题 AcWing 6. 多重背包问题 III 多重背包困难题 AcWing 7. 混合背包问题 混合背包 AcWing 8. 二维费用的背包问题 二维背包 AcWing 9. 分组背包问题 分组背包 AcWing 11. 背包问题求方案数 背包问题求方案数 AcWing 12. 背包问题求具体方案 背包问题求具体方案，可以试试上面说的求具体方案的方法 NC23413 小A买彩票 一个简单的背包问题 NC14526 购物 01背包+分组背包 NC207751 牛牛的旅游纪念品 背包问题入门题 NC16693 [NOIP2001]装箱问题 裸的01背包 P1048 [NOIP2005 普及组] 采药 裸的01背包 NC17871 CSL分苹果 转换成01背包写 P1064 [NOIP2006 提高组] 金明的预算方案 我是当成有依赖的背包写的，但也有人用线性方式的dp写出来了，所以放这吧 NC14699 队伍配置 多维背包的入门题 [USACO09DEC]Video Game Troubles 分组背包+01背包，转移用两个方程 NC17193 简单瞎搞题 分组背包用bitset优化 NC16576 [NOIP2012]摆花 分组背包 P5020 [NOIP2018 提高组] 货币系统 完全背包的应用 P1877 [HAOI2012]音量调节 简单背包问题 P4158 [SCOI2009]粉刷匠 划分dp + 分组背包，有点进阶 CodeForces 755F PolandBall and Gifts 多重背包，说实话有点毒瘤 CodeForces - 864E Fire 贪心+01背包 CodeForces - 366C 思维+01背包，有点进阶 atcoder Knapsack 2 01背包+换意dp atcoder Candies 多重背包，需要一些优化手段 atcoder Tower 思维+01背包，有点思维性，多想想 CodeForces 1637D. Yet Another Minimization Problem 打比赛时发现的，好题 其他线性dp 线性dp是最基础的dp，其他dp可以说是他的延伸，线性dp难起来一般的难点是转移上\n线性dp考点有很多，包括空间优化，状态转移和定义，寻找具体方案等\n多刷题才是王道\n例题 NC20875 舔狗舔到最后一无所有 这题的转移有点意思 NC20650 可爱の星空 这题的转移注意状态的空间，建议使用dfs找状态 NC51216 花店橱窗 这题感觉像是背包+数字三角形的模型，还要求具体方案 NC16850 免费馅饼 加个时间轴作为状态的一维，然后像数字三角形一样走，反过来遍历就好了，然后正过来找具体方案 NC16856 钉子和小球 这题有点好玩，初始状态有点意思 NC16619 [NOIP2008]传球游戏 很简单的线性dp NC16664 [NOIP2004]合唱队形 算LIS的入门题吧 [NOIP1999] 拦截导弹 相信不少人做过这题，Dilworth定理的应用 NC15553 数学考试 算划分dp吧 NC19158 失衡天平 这种转移也有点意思，没遇到过可能真要想挺久的 NC13885 Music Problem 要用到bitset优化，想想取余的加减法对应的操作吧 NC14704 美味菜肴 先贪心，后dp，最后找最优值 NC207781 迁徙过程中的河流 贪心思维的dp [NOIP2008 提高组] 传纸条 建议记忆化搜索，可以空间优化 P1004 [NOIP2000 提高组] 方格取数 和传纸条差不多 P1052 [NOIP2005 提高组] 过河 空间优化，转移找状态有点恶心 NC16590 乌龟棋 需要空间优化 NC50959 To the Max 前缀和与最大连续子串的应用 P1169 [ZJOI2007]棋盘制作 思维+最大全为1的正方形+单调栈的应用 P2331 [SCOI2005]最大子矩阵 状态有点难想，也有点难转移 AcWing 431. 守望者的逃离 转移挺有意思的，记住特判条件就好了 [USACO 2008 Jan S]Running 刷表法的应用 P2051 [AHOI2009]中国象棋 要结合组合数学转移 atcoder Grid 2 需要组合数学和走格子的一个数学小结论 atcoder abc212E Safety Journey 一开始以为是图上矩阵的k次幂，发现数据太大 P3216 [HNOI2011] 数学作业 快速幂优化，注意数据范围 libre 10180. 「一本通 5.5 练习 1」烽火传递 单调队列优化的划分dp libre 10177. 「一本通 5.5 例 3」修剪草坪 和烽火传递一样 [libre 10181. 「一本通 5.5 练习 2」绿色通道 二分+单调队列优化dp CodeForces - 372C Watching Fireworks is Fun 单调队列优化dp 区间dp 一种具有区间性质的dp，一般来说转移都是从小区间转移到大区间，固一般是先枚举小区间再枚举大区间的即 dp[l][r] \u0026lt;- dp[l + 1][r - 1]\n有两种遍历方式可以做到\n1 2 3 4 5 6 7 8 9 10 11 12 //1 比较常见的 for (int len = 1; len \u0026lt;= n; ++len) { for (int l = 1, r = l + len - 1; r \u0026lt;= n; ++l, ++r) { // 转移 } } //2 可以反向l只会找l+1转移，r只会找r-1转移，固可以l逆着遍历，r顺着遍历 for (int l = n; l \u0026gt;= 1; --l) { for (int r = l; r \u0026lt;= n; ++r) { // 转移 } } 两种效果差不多\n对于环形的区间dp，一般的处理方式是拆环成链，开两倍的空间\n例题 NC14701 取数游戏2 区间dp入门题\nNC15447 wyh的问题 区间dp题，没什么好说的\n石子合并 经典\n凸多边形的划分 经典\nP4170 [CQOI2007]涂色 区间dp，感性转移\nNC16129 小小粉刷匠 和涂色差不多，多了个限制条件\nNC23501 小A的回文串 拆环成链\nNC227595 跳跳跳 区间dp，也不难想\nNC13230 合并回文子串 如果能想到是区间dp就挺简单的了\nP3147 [USACO16OPEN]262144 P 区间dp+换意dp\nP1005 [NOIP2007 提高组] 矩阵取数游戏 普普通通的区间dp\nP1040 [NOIP2003 提高组] 加分二叉树 需要一点树的中序和前序遍历的知识\nHDU 2476 String painter 和涂色差不多，需要预处理，然后来个区间dp，最后划分dp\nUVA 10617 Again Palindrome 求区间中有多少个回文子序列，需要容斥一下\nPOJ 1159 Palindrome 需要空间优化\natcoder Deque 思维+区间dp\n树上dp 个人感觉，树上dp和树上背包是不一样的，固分开来写\n树形dp简单的来说就是在树上进行dp\n但有些模型个人觉得还是必须要去了解的\n例如\n树上独立集 树的最小支配集 树的最小点覆盖 树的直径 树的重心 性质如下 一棵树最少有一个重心，最多有两个重心，若有两个重心，则他们相邻（即连有直接边） 树上所有点到某个点的距离和里，到重心的距离和最小；若有两个重心，则其距离和相同 若以重心为根，则所有子树的大小都不超过整棵树的一半 在一棵树上添加或删除一个叶子节点，其重心最多平移一条边的距离 两棵树通过连一条边组合成新树，则新树重心在原来两棵树的重心的连线上 树的中心 …… 当然还有比较常见的便是换根dp和基环树dp\n对于换根dp，换根时个人觉得还是多开一个数组进行记录需要的答案比较好。一般来说思考换根的公式是画图和进行未换根前的公式转换\n例题 Libre 10157 「一本通 5.2 例 5」皇宫看守 树上最小支配集\nNC51178 没有上司的舞会 树上最大独立集\nLibre 10156 「一本通 5.2 例 4」战略游戏 树上最小点覆盖\nLibre 10159 「一本通 5.2 练习 2」旅游规划 树的直径+具体方案\nPOJ 1655 Balancing Act 树的重心\nNC202475 树上子链 有点像树的直径\nNC211219 电话网络 树上最小支配集\nNC22598 Rinne Loves Edges 直接树上dp就行了\nP4268 [USACO18FEB]Directory Traversal 换根dp\nP2986 [USACO10MAR] Great Cow Gathering 换根dp\nNC51180 Accumulation Degree 换根dp\nNC51222 Strategic game 树上最小点覆盖\n树形背包 树形背包，顾名思义是在树上的或者说是有依赖的背包问题\n对于思考方式可以看看之前写的《树形背包思考方式》\n一般困难点便是转移的思考、如何定义状态、边和点权哪个是物品重量等\n当然还有一个进阶考法是利用虚树进行优化\n例题 AcWing 10. 有依赖的背包问题 入门题\nLibre 10154. 「一本通 5.2 例 2」选课 入门级别吧\nLibre 10153. 「一本通 5.2 例 1」二叉苹果树 入门级别\nNC20811 蓝魔法师 要学会思考什么是背包模型中的物品重量\nP1273 有线电视网 树形背包+换意dp\nP1272 重建道路 这题也不难\nP3177 [HAOI2015]树上染色 注意背包模型中的物品是什么\nHDU6540 Neko and tree 进阶题\nP3354 [IOI2005]Riv 河流 有点难\n状压dp 状态压缩一般指的是利用二进制进行状态的压缩，很少出现三进制这些\n当然状态压缩dp常见的考点便是哈密顿通路的模型\n注意一个二进制状态寻找子集的搜索方法，其复杂度是O($3^n$)的\n1 2 3 4 for (int s1 = s; s1; s1 = (s1 - 1) \u0026amp; s) { int s2 = s ^ s1; // s1 与 s2 互为 s 的补集 } 例题 AcWing 292. 炮兵阵地 基础题 P1896 [SCOI2005]互不侵犯 入门题 NC17890 方格填色 要用快速幂优化 NC210981 mixup2 混乱的奶牛 算是基础题吧 AcWing 291. 蒙德里安的梦想 状态dp，个人觉得轮廓线的思想来转移会比较好 NC15832 Most Powerful 好好思考状态 P1879 [USACO06NOV]Corn Fields 基础题 NC16122 郊区春游 本质是求一个哈密顿最小路径的通路 NC16544 简单环 类似求一个哈密顿回路的方案数 P3118 [USACO15JAN]Moovie Mooving 思考状态存什么 P3092 [USACO13NOV]No Change 要二分优化 atcoder Matching 二分图的完美匹配方案数 atcoder Grouping 你需要学会枚举子集 [CQOI2012]局部极小值 状压dp+容斥（难度较高） leetcode 6007. 数组的最大与和 这题有点意思，建议用状压做 atcoder ABC213G - Connectivity 2 枚举子集，要想到如何不重不漏地计算 数位dp 说起数位dp，求解的过程更像是在树上计数一样\n值得注意的是：记忆化递归求解简单易懂，而且几乎不会卡递归的方式\n给出递归时的一个套路代码（很多地方更多的是希望根据题意来）\n有时候有些数位dp可能对前导0或者前面填的数对后面有影响，则可以在dfs中传参传多几个标志，然后在更新res（12行）时特判就好了\n当然，个人感觉核心代码就是11~13行内部的转移方式，一般来说，写题的时候有点纠结状态怎么定义时，会先写这部分\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 int num[100], dp[100]; int dfs(int indx, int limit, /*参数根据题意来添加*/) { if (indx == 0) { return 1;// 根据题意来返回 } int \u0026amp;ref = dp[indx]; if (!limit \u0026amp;\u0026amp; ref != -1) return ref; int res = 0; int up = (limit ? num[indx] : 9); for (int i = 0; i \u0026lt;= up; ++i) { // 更新res dfs(indx - 1, limit \u0026amp;\u0026amp; i == up); } if (!limit) ref = res; return res; } int solve(int x) { if (!x) return 1; // 根据题意来决定返回值 int len = 0; while (x) { num[++len] = x % 10; x /= 10; } return dfs(len, 1); } int main() { memset(dp, - 1, sizeof dp); // 根据题意决定初始化的时机和大小 // 此行省略读入 cout \u0026lt;\u0026lt; solve(r) - solve(l - 1) endl; } 例题 Libre 10164. 「一本通 5.3 例 2」数字游戏 入门好题 Libre 10166. 「一本通 5.3 练习 1」数字游戏 和上一题处理差不多 [SCOI2009] windy 数 多少人的刚学是做的这题？ atcoder abc161D Lunlun Number 不说应该也能想到怎么做的题 CodeForces 204A Little Elephant and Interval 这题让我吹爆记忆化搜的数位dp，处理前导0的形式值得练习 CodeForces 1143B Nirvana 这题虽然可以不用数位dp做，但可以当做数位dp的练手题，可以练习一下处理前导0的形式 And and Pair 19年南昌icpc的C题，重现的时候自己是组合数学写出来的，但这题确实可以用数位dp写，注意是两个限制维度 Sum of Log 20年上海icpc的C题，也是两个限制维度限制的数位dp ~持续更新中……\n","date":"2022-01-25T12:08:36+08:00","permalink":"https://example.com/2022/%E5%90%84%E7%B1%BBdp%E6%80%BB%E7%BB%93/","title":"各类dp总结"},{"content":"能用双指针的条件 具有区间递增性，即随着区间的两边扩散，某个性质递增增长 常用套路与技巧 板子一 1 2 3 4 5 6 7 8 9 10 for(int l = 0, r = 0; r \u0026lt; n; ++r) { add(arr[r]); // 添加右指针 while (isbad()) { remove(arr[l]); l += 1; } if (isgood()) { // 必要的话价格判断判断 update(ans); // 更新ans } } 板子二 1 2 3 4 5 6 7 8 for (int l = 0, r = 0; r \u0026lt; n; ++r) { add(arr[r]); while (isgood()) { update(ans); remove(arr[l]); l += 1; } } 技巧：当删除不好维护时，考虑用两个栈来维护，即建两个栈 sl, sr， 当添加时往 sr 上添加，当删除时，如果 sl 为空，则将 sr 上的所有元素倒入 sl 后再删除 sl 的栈顶元素，若 sl 不为空，则直接删除 sl 的栈顶元素 未完待续…… ","date":"2021-09-15T17:46:16+08:00","permalink":"https://example.com/2021/%E5%8F%8C%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93/","title":"双指针总结"},{"content":" 狂补dp Atcoder Educational DP Contest(全) 注意 为了减少篇幅，本博客代码部分只放主代码部分，其余省略快读、快输、头文件等代码，即把代码看做伪代码更佳 A - Frog 1 幼儿级别的dp，直接dp便可 1 2 3 4 5 6 7 8 9 void problem() { int n = IO(); for (int i = 0; i \u0026lt; n; ++i) num[i] = IO(); for (int i = 1; i \u0026lt; n; ++i) { dp[i] = dp[i - 1] + abs(num[i] - num[i - 1]); if (i \u0026gt;= 2) dp[i] = min(dp[i], dp[i - 2] + abs(num[i] - num[i - 2])); } print(dp[n - 1]); } B - Frog 2 还是幼儿级别，比A题多了一重循环 1 2 3 4 5 6 7 8 9 10 11 void problem() { int n = IO(), k = IO(); for (int i = 0; i \u0026lt; n; ++i) num[i] = IO(); for (int i = 1; i \u0026lt; n; ++i) { dp[i] = dp[i - 1] + abs(num[i] - num[i - 1]); for (int j = 2; j \u0026lt;= min(k, i); ++j) { if (i \u0026gt;= j) dp[i] = min(dp[i], dp[i - j] + abs(num[i] - num[i - j])); } } print(dp[n - 1]); } C - Vacation 根据题意定义一个二维dp，第二维表示当前选的是哪个，然后转移就很简单了 1 2 3 4 5 6 7 8 9 10 void problem() { int n = IO(); for (int i = 1; i \u0026lt;= n; ++i) a[i] = IO(), b[i] = IO(), c[i] = IO(); for (int i = 1; i \u0026lt;= n; ++i) { dp[i][0] = max(dp[i - 1][1], dp[i - 1][2]) + a[i]; dp[i][1] = max(dp[i - 1][0], dp[i - 1][2]) + b[i]; dp[i][2] = max(dp[i - 1][1], dp[i - 1][0]) + c[i]; } print(max({dp[n][0], dp[n][1], dp[n][2]})); } D - Knapsack 1 01背包问题 1 2 3 4 5 6 7 8 void problem() { int n = IO(), m = IO(); for (int i = 1; i \u0026lt;= n; ++i) w[i] = IO(), v[i] = IO(); for (int i = 1; i \u0026lt;= n; ++i) { for (int j = m; j \u0026gt;= w[i]; --j) dp[j] = max(dp[j], dp[j - w[i]] + v[i]); } print(dp[m]); } E - Knapsack 2 01背包+换意dp 原本定义 dp[i] 表示容量不超过 i 能装的最大价值 由于背包容量过大，但我们不难发现物品的价值不大，可以对状态定义进行换意 即定义 dp[i] 表示装价值为 i 物品所花费的最小容量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void problem() { int n = IO(), m = IO(); for (int i = 1; i \u0026lt;= n; ++i) w[i] = IO(), v[i] = IO(); fill_n(dp, N, INF); dp[0] = 0; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 100000; j \u0026gt;= v[i]; --j) { dp[j] = min(dp[j], dp[j - v[i]] + w[i]); } } for (int i = 100000; i \u0026gt;= 0; --i) { if (dp[i] \u0026lt;= m) { print(i); break; } } } F - LCS LCS+dp求具体方案 dp求具体方案我还是喜欢递归找，复杂度O($n$) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void solve(int n, int m) { if (n == 0 || m == 0) { reverse(all(ans)); for (char\u0026amp; c : ans) putchar(c); exit(0); return; } if (dp[n][m] == dp[n - 1][m]) solve(n - 1, m); else if (dp[n][m] == dp[n][m - 1]) solve(n, m - 1); else { ans.push_back(a[n]); solve(n - 1, m - 1); } } void problem() { scanf(\u0026#34;%s\\n%s\u0026#34;, a + 1, b + 1); int n = strlen(a + 1), m = strlen(b + 1); for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= m; ++j) { if (a[i] == b[j]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]); } } solve(n, m); } G - Longest Path 拓扑dp 可以bfs转移，但我是dfs转移的 值得注意的是，状态定义为 dp[i] 表示从 i 点出发能走的最远距离好转移一些 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int dfs(int u) { if (dp[u] != -1) return dp[u]; int\u0026amp; res = dp[u] = 0; for (int\u0026amp; v : mp[u]) { res = max(res, dfs(v) + 1); } return res; } void problem() { int n = IO(), m = IO(); for (int i = 0; i \u0026lt; m; ++i) { int u = IO(), v = IO(); mp[u].pb(v); ++du[v]; } fill_n(dp + 1, n, -1); for (int i = 1; i \u0026lt;= n; ++i) if (!du[i]) ans = max(dfs(i), ans); print(ans, \u0026#39;\\n\u0026#39;); } H - Grid 1 走格子，老dp模型了 1 2 3 4 5 6 7 8 9 10 11 12 void problem() { int n = IO(), m = IO(); for (int i = 1; i \u0026lt;= n; ++i) scanf(\u0026#34;%s\u0026#34;, g[i] + 1); dp[0][1] = 1; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= m; ++j) { if (g[i][j] != \u0026#39;.\u0026#39;) continue; dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod; } } print(dp[n][m]); } I - Coins 简单的一个概率dp 定义 dp[i][j] 表示前 i 个硬币中人头朝上的个数为 j 的概率 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void problem() { int n = IO(); for (int i = 1; i \u0026lt;= n; ++i) scanf(\u0026#34;%lf\u0026#34;, p + i); dp[0][0] = 1; for (int i = 1; i \u0026lt;= n; ++i) { dp[i][0] = dp[i - 1][0] * (1.0 - p[i]); for (int j = 1; j \u0026lt;= i; ++j) { dp[i][j] += dp[i - 1][j - 1] * p[i] + dp[i - 1][j] * (1.0 - p[i]); } } double ans; for (int i = 1; i \u0026lt;= n; ++i) { if (i \u0026gt; n - i) ans += dp[n][i]; } printf(\u0026#34;%.9f\\n\u0026#34;, ans); } J - Sushi 期望dp 突破口就是每个盘子上的寿司不超过3个，计数寿司个数为 i 的盘子有几个 定义 dp[i][j][k] 表示剩下 i 个盘子上面只有1个寿司， j 个盘子上面只有2个寿司， k 个盘子只有3个寿司的期望值 转移的话，递归记忆化转移比较方便 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 double dfs(int a, int b, int c) { if (a + b + c == 0) return 0; if (vis[a][b][c]) return dp[a][b][c]; vis[a][b][c] = 1; double tot = a + b + c; double \u0026amp;res = dp[a][b][c] = n * 1.0 / tot; if (a) res += dfs(a - 1, b, c) * a / tot; if (b) res += dfs(a + 1, b - 1, c) * b / tot; if (c) res += dfs(a, b + 1, c - 1) * c / tot; return res; } void problem() { n = IO(); int num[4] = {0}; for (int i = 0; i \u0026lt; n; ++i) { int x = IO(); ++num[x]; } printf(\u0026#34;%.10f\u0026#34;, dfs(num[1], num[2], num[3])); } K - Stones 基础博弈dp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void problem() { int n = IO(), k = IO(); for (int i = 0; i \u0026lt; n; ++i) a[i] = IO(); dp[0] = 0; for (int i = 1; i \u0026lt;= k; ++i) { int ok = 0; for (int j = 0; j \u0026lt; n; ++j) { if (i \u0026lt; a[j]) continue; if (dp[i - a[j]] == 0) { ok = 1; // 如果有一个必输点，则他必赢 break; } } dp[i] = ok; } puts(dp[k] ? \u0026#34;First\u0026#34; : \u0026#34;Second\u0026#34;); } L - Deque 区间dp+思维 转变一下思路，先手希望 X-Y 最大，后手希望 X-Y 最小，即后手希望 Y-X最大，即都希望自己的分数减去对手的分数达到最大 设 dp[l][r] 表示 [l, r] 区间中先手分数减去后手分数的最大值，转移的话，便是用决策 加上 负数的dp值 即 dp[l][r] = max(a[r] + (-dp[l][r - 1]), a[l] + (-dp[l + 1][r])) 1 2 3 4 5 6 7 8 9 10 void problem() { int n = IO(); for (int i = 1; i \u0026lt;= n; ++i) a[i] = IO(), dp[i][i] = a[i]; for (int i = n; i; --i) { for (int j = i; j \u0026lt;= n; ++j) { dp[i][j] = max(a[j] - dp[i][j - 1], a[i] - dp[i + 1][j]); } } print(dp[1][n]); } M - Candies 多重背包问题 直接三重循环的话会超时，像这样的代码 1 2 3 4 5 6 7 8 dp[0][0] = 1; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 0; j \u0026lt;= m; ++j) { for (int k = 0; k \u0026lt;= min(a[i], j); ++k) { dp[i][j] += dp[i - 1][j - k]; } } } 但我们不难发现第三重循环是可以优化掉的 分析 dp[i][j] 他的转移只会从 dp[i - 1][x] （其中 j - a[i] \u0026lt;= x \u0026lt;= j ）转移过来，固我们可以用前缀和与滑动窗口的思想来进行优化掉第三重循环 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void problem() { int n = IO(), m = IO(); for (int i = 1; i \u0026lt;= n; ++i) a[i] = IO(); dp[0][0] = 1; for (int i = 1; i \u0026lt;= n; ++i) { ll sum = 0; for (int j = 0; j \u0026lt;= m; ++j) { sum += dp[i - 1][j]; dp[i][j] = (sum + mod) % mod; if (j \u0026gt;= a[i]) sum -= dp[i - 1][j - a[i]]; } } print(dp[n][m]); } N - Slimes 区间dp入门题 1 2 3 4 5 6 7 8 9 10 11 12 13 void problem() { int n = IO(); memset(dp, 0x3f, sizeof dp); for (int i = 1; i \u0026lt;= n; ++i) a[i] = IO(), sum[i] = sum[i - 1] + a[i], dp[i][i] = 0; for (int i = n; i \u0026gt;= 1; --i) { for (int j = i; j \u0026lt;= n; ++j) { // [i, j] 区间 for (int k = i; k \u0026lt; j; ++k) { dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + sum[j] - sum[i - 1]); } } } print(dp[1][n]); } O - Matching 状压dp 本质就是二分图完美匹配的方案数 设 dp[i][j] 表示正在决策第 i (下标从0开始)个男生，且前 i 个男生匹配好的女生为 j（二进制） 转移用刷表法转移比较好 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 ll dp[22][(1 \u0026lt;\u0026lt; 21) + 10]; vector\u0026lt;int\u0026gt; vt[22]; int count(int x) { int res = 0; while (x) { x \u0026amp;= x - 1; res++; } return res; } int m[25][25]; void problem() { int n = IO(); for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; n; ++j) { m[i][j] = IO(); } } dp[0][0] = 1; int len = 1 \u0026lt;\u0026lt; n; for (int i = 0; i \u0026lt; len; ++i) vt[count(i)].push_back(i); for (int i = 0; i \u0026lt; n; ++i) { for (int j : vt[i]) { for (int k = 0; k \u0026lt; n; ++k) { if (j \u0026amp; (1 \u0026lt;\u0026lt; k)) continue; if (!m[i][k]) continue; dp[i + 1][j ^ (1 \u0026lt;\u0026lt; k)] += dp[i][j]; dp[i + 1][j ^ (1 \u0026lt;\u0026lt; k)] %= mod; } } } print(dp[n][len - 1]); } P - Independent Set 树上dp 有点类似树上独立集了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 vector\u0026lt;int\u0026gt; mp[N]; ll dp[N][2]; // i号结点为0/1色的方案数 void dfs(int u, int fa) { dp[u][0] = dp[u][1] = 1; for (int\u0026amp; v : mp[u]) { if (v == fa) continue; dfs(v, u); dp[u][1] = dp[v][0] * dp[u][1] % mod; dp[u][0] = dp[u][0] * (dp[v][0] + dp[v][1]) % mod; } } void problem() { int n = IO(); for (int i = 1; i \u0026lt; n; ++i) { int u = IO(), v = IO(); mp[u].pb(v), mp[v].pb(u); } dfs(1, 0); printf((dp[1][0] + dp[1][1]) % mod); } Q - Flowers LIS的变种，需要用线段树优化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 const int N = 2e5 + 5; struct pairs { int indx, h; ll a; }p[N]; ll seg[N \u0026lt;\u0026lt; 2]; void update(int indx, ll v, int l, int r, int node = 1) { if (l == r) { seg[node] = v; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (indx \u0026lt;= mid) update(indx, v, l, mid, node \u0026lt;\u0026lt; 1); else update(indx, v, mid + 1, r, node \u0026lt;\u0026lt; 1 | 1); seg[node] = max(seg[node \u0026lt;\u0026lt; 1], seg[node \u0026lt;\u0026lt; 1 | 1]); } ll get(int ql, int qr, int l, int r, int node = 1) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return seg[node]; int mid = (l + r) \u0026gt;\u0026gt; 1; ll ret = 0; if (ql \u0026lt;= mid) ret = get(ql, qr, l, mid, node \u0026lt;\u0026lt; 1); if (qr \u0026gt; mid) ret = max(ret, get(ql, qr, mid + 1, r, node \u0026lt;\u0026lt; 1 | 1)); return ret; } void problem() { int n = IO(); for (int i = 1; i \u0026lt;= n; ++i) { p[i].indx = i; p[i].h = IO(); } for (int i = 1; i \u0026lt;= n; ++i) p[i].a = IO(); sort(p + 1, p + 1 + n, [](pairs\u0026amp; i, pairs\u0026amp; j) { return i.h \u0026lt; j.h; }); ll ans = 0; for (int i = 1; i \u0026lt;= n; ++i) { ll maxv = get(1, p[i].indx, 1, n) + p[i].a; update(p[i].indx, maxv, 1, n); ans = max(maxv, ans); } printf(ans); } R - Walk 不多说，考的就是矩阵乘法在图中的意义（结论题） 矩阵A的n次幂表示走n次x到y的方案数，对于本题就是求矩阵的k次幂，再求结果矩阵上各个点上的和即可 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #define vi vector\u0026lt;ll\u0026gt; #define Mat vector\u0026lt;vi\u0026gt; Mat operator* (Mat a, Mat b) { Mat res(N, vi(N, 0)); for (int i = 0; i \u0026lt; N; ++i) for (int j = 0; j \u0026lt; N; ++j) for (int k = 0; k \u0026lt; N; ++k) res[i][j] = (res[i][j] + a[i][k] * b[k][j] % mod) % mod; return res; } Mat operator^ (Mat a, long long b) { Mat res(N, vi(N, 0)); for (int i = 0; i \u0026lt; N; ++i) res[i][i] = 1; while (b) { if (b \u0026amp; 1) res = res * a; a = a * a, b \u0026gt;\u0026gt;= 1; } return res; } void problem() { ll n = IO(), k = IO(); Mat mat(N, vi(N, 0)); for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; n; ++j) { mat[i][j] = IO(); } } Mat res = mat ^ k; ll ans = 0; for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; n; ++j) { ans = (res[i][j] + ans) % mod; } } printf(ans); } S - Digit Sum 数位dp入门题 对于数位dp，记忆化搜比较好理解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int num[N], len, n; ll dp[N][2][101]; ll dfs(int x, int limit, int m) { ll \u0026amp;res = dp[x][limit][m]; if (~res) return res; if (x == 0) return res = (m == 0); res = 0; int up = (limit ? num[x] : 9); for (int i = 0; i \u0026lt;= up; ++i) { res += dfs(x - 1, limit \u0026amp;\u0026amp; i == up, (m + i) % n); res %= mod; } return res; } void problem() { string s; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; n; len = s.size(); for (int i = 0, j = len; i \u0026lt; len; ++i, --j) num[j] = s[i] - \u0026#39;0\u0026#39;; memset(dp, -1, sizeof dp); print(((dfs(len, 1, 0) - 1) % mod + mod) % mod); } T - Permutation 比较思维的一道dp题 设 dp[i][j] 表示前 i 个排列中（包括 i ）最后一位放的是 j 的方案数 转移的话要注意，当前第 i 个放的 j ,转移利用到的第 i - 1 的排列中将小于 j 的视为小于 j ，大于等于 j 的视为严格大于 j 由于转移的时候是要三重循环，但草稿可以发现第三种循环可以优化掉的，看代码就懂了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int n; string s; ll dp[N][N]; void problem() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s; dp[1][1] = 1; for (int i = 2; i \u0026lt;= n; ++i) { if (s[i - 2] == \u0026#39;\u0026lt;\u0026#39;) { dp[i][1] = 0; for (int j = 2; j \u0026lt;= i; ++j) { dp[i][j] = (dp[i - 1][j - 1] + dp[i][j - 1]) % mod; } } else { dp[i][i] = 0; for (int j = i - 1; j; --j) { dp[i][j] = (dp[i - 1][j] + dp[i][j + 1]) % mod; } } } ll ans = 0; for (int i = 1; i \u0026lt;= n; ++i) { ans = (ans + dp[n][i]) % mod; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } U - Grouping 状压dp 本题对于状压刚入门的童鞋可能比较难，但通过这题只要记住状压是怎么枚举所有子集的便可 这里写一遍，还要注意，枚举的复杂度为 O($3^n$) 1 2 3 4 for (int s1 = s; s1; s1 = (s1 - 1) \u0026amp; s) { int s2 = s ^ s1; // s1 与 s2 互为 s 的补集,其此遍历保证s2为s的真子集 } 本题要的是真子集，所以要改改 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void problem() { int n = IO(), m = 1 \u0026lt;\u0026lt; n; for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; n; ++j) { a[i][j] = IO(); } } for (int i = 1; i \u0026lt; m; ++i) { for (int j = 0; j \u0026lt; n; ++j) { if (((i \u0026gt;\u0026gt; j) \u0026amp; 1) == 0) continue; for (int k = j + 1; k \u0026lt; n; ++k) { if (((i \u0026gt;\u0026gt; k) \u0026amp; 1) == 0) continue; dp[i] += a[j][k]; } } for (int j = i \u0026amp; (i - 1); j; j = (j - 1) \u0026amp; i) { dp[i] = max(dp[i], dp[j] + dp[j ^ i]); } } print(dp[m - 1]); } V - Subtree 换根dp 换根过程中，考虑到模数可能不为质数，所以要记录每颗子树的前后缀积， 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 void dfs(int u, int fa) { dp[u] = 1; pre[u].push_back(1); for (int v : edg[u]) { if (v == fa) continue; dfs(v, u); dp[u] = dp[u] * (1 + dp[v]) % m; pre[u].pb(dp[u]); } for (int i = (int)edg[u].size() - 1; i \u0026gt;= 0; --i) { int v = edg[u][i]; if (v == fa) continue; ll tmp = (dp[v] + 1) % m; if (last[u].size()) tmp = last[u].back() * tmp % m;; last[u].pb(tmp); } reverse(all(last[u])); last[u].pb(1); } void solve(int u, int fa, ll sub) { int indx_pre = 0, indx_last = 1; for (int v : edg[u]) { if (v == fa) continue; ll tmp = pre[u][indx_pre++] * last[u][indx_last++] % m; // printf(\u0026#34;%d %d\\n\u0026#34;, u, tmp); f[v] = (sub * tmp % m + 1) * dp[v] % m; solve(v, u, (tmp * sub + 1) % m); } } void problem() { n = IO(), m = IO(); for (int i = 1; i \u0026lt; n; ++i) { int u = IO(), v = IO(); edg[u].pb(v), edg[v].pb(u); } dfs(1, 0); f[1] = dp[1]; solve(1, 0, 1); for (int i = 1; i \u0026lt;= n; ++i) print(f[i], \u0026#39;\\n\u0026#39;); } W - Intervals 线段树优化dp 这题有点意思，一开始没发现要数据结构优化，怎么想都觉得是一个O($n^3$)的dp，后来发现可以用线段树优化成O($nlogn$) 设 dp[i] 表示前 i 长度的字符串中，第 i 个位置必填 1 的最大价值 然后先看转移方程，设结构体 p 为题中的区间 $$ dp[i] = dp[j] + p[k].a $$\n$$ 其中 0 \u0026lt;= j \u0026lt; i $$\n$$ 并且 j \u0026lt; p[k].l \\le i $$\n$$ 且p[k].r \\ge i $$\n不难发现，暴力的话，这样转移是 O($n^3$) 但我们会发现对于一个 p[k].l \u0026lt;= i 的区间，所有 j \u0026lt; p[k].l 的 dp[j] 都必须要加上这个区间，然后就很容易想到将所有区间按左端点升序排序，然后线段树进行转移便可，让区间 [0, p[k].l - 1] 的所有dp值加上 p[k].a ， 记得加完要减回去 看代码简单易懂 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 #define ls node \u0026lt;\u0026lt; 1 #define rs (ls) | 1 struct pii { int x, y, v; bool operator\u0026lt; (const pii\u0026amp; j) { return x != j.x ? x \u0026lt; j.x : y \u0026lt; j.y; } }; struct nodes{ ll maxv, lazy; }; const int N = 1e5 + 10, M = 1e6 + 10; ll dp[M \u0026lt;\u0026lt; 1]; pii q[N \u0026lt;\u0026lt; 1]; nodes seg[N \u0026lt;\u0026lt; 3]; vector\u0026lt;int\u0026gt; pos[N \u0026lt;\u0026lt; 1]; void push_down(int node) { ll \u0026amp;tmp = seg[node].lazy; if (!tmp) return; seg[ls].lazy += tmp; seg[rs].lazy += tmp; seg[ls].maxv += tmp; seg[rs].maxv += tmp; tmp = 0; assert(seg[node].lazy == 0); } void update_range(int ql, int qr, ll v, int l, int r, int node = 1) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) { seg[node].lazy += v; seg[node].maxv += v; return; } push_down(node); int mid = (l + r) \u0026gt;\u0026gt; 1; if (ql \u0026lt;= mid) update_range(ql, qr, v, l, mid, ls); if (qr \u0026gt; mid) update_range(ql, qr, v, mid + 1, r, rs); seg[node].maxv = max(seg[ls].maxv, seg[rs].maxv); } void update_pos(int indx, ll v, int l, int r, int node = 1) { if (l == r) { seg[node].maxv = v; return; } push_down(node); int mid = (l + r) \u0026gt;\u0026gt; 1; if (indx \u0026lt;= mid) update_pos(indx, v, l, mid, ls); else update_pos(indx, v, mid + 1, r, rs); seg[node].maxv = max(seg[ls].maxv, seg[rs].maxv); } ll query_range(int ql, int qr, int l, int r, int node = 1) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return seg[node].maxv; push_down(node); int mid = (l + r) \u0026gt;\u0026gt; 1; ll ret = -llf; if (ql \u0026lt;= mid) ret = query_range(ql, qr, l, mid, ls); if (qr \u0026gt; mid) ret = max(ret, query_range(ql, qr, mid + 1, r, rs)); return ret; } void problem() { int n = IO(), m = IO(); for (int i = 0; i \u0026lt; m; ++i) { q[i].x = IO(), q[i].y = IO(), q[i].v = IO(); } sort(q, q + m); for (int i = 0; i \u0026lt; m; ++i) pos[q[i].y].push_back(i); ll ans = 0; for (int i = 1, j = 0; i \u0026lt;= n; ++i) { while (j \u0026lt; m \u0026amp;\u0026amp; q[j].x \u0026lt;= i) { update_range(0, q[j].x - 1, q[j].v, 0, n); j += 1; } dp[i] = query_range(0, i - 1, 0, n); update_pos(i, dp[i], 0, n); for (int p : pos[i]) update_range(0, q[p].x - 1, -q[p].v, 0, n); ans = max(ans, dp[i]); } print(ans); } X - Tower 贪心+01背包 dp前的贪心排序要大胆地猜，然后证明 用领项交换法的思路去思考，当前决策相邻的两个物品 $w_i, s_i$ 和 $w_j,s_j$ ，前面物品（假设合法）的重量为 $X$，若以 $i$ 在 $j$ 上的顺序放的话 $j$ 物品还能承受的重量为 $s_j - X - w_i$，反之 $i$ 物品还能承受的重量为 $s_i - X - w_j$，我们当然是想让 后面的更能承受重量，固 $s_j - X - w_i \u0026gt; s_i - X - w_j$，化简，我们就能发现只需要按 $s_i + w_i \u0026lt; s_j + w_j$ 排序，最后01背包找答案便可 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 struct pii { int w, s; ll v; bool operator\u0026lt; (const pii\u0026amp; j) { return w + s \u0026lt; j.w + j.s; } }; pii p[1010]; ll dp[20010]; void problem() { int n = IO(); for (int i = 0; i \u0026lt; n; ++i) { p[i].w = IO(), p[i].s = IO(), p[i].v = IO(); } sort(p, p + n); for (int i = 0; i \u0026lt; n; ++i) { for (int j = p[i].s + p[i].w; j \u0026gt;= p[i].w; --j) { dp[j] = max(dp[j], dp[j - p[i].w] + p[i].v); } } print(*max_element(dp, dp + 20001)); } Y - Grid 2 数学+dp 显然不能直接dp，会超时 如果是n*m的格子，无障碍的话方案数就是 $C^{n - 1}_{n + m - 2}$ 找突破口，发现障碍的点不多 设 dp[i] 表示从 (1, 1) 到第 i 个障碍的方案数，下面是转移 设第 j 个障碍点在第 i 个障碍点的左上方，再设从第 j 个障碍点到第 i 个障碍点形成的格子是 x * y 的，则 $$ dp[i] += dp[j] * C^{x - 1}_{x + y - 2} $$\n最后的答案便是将所有点往 (n, m) 点转移得到的答案 直接看代码，注意转移的顺序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u0026gt;\u0026gt;= 1, a = a * a % p) if (b \u0026amp; 1) res = res * a % p; return res; } struct pii { int x, y; bool operator\u0026lt; (const pii\u0026amp; j) { return x != j.x ? x \u0026lt; j.x : y \u0026lt; j.y; } }; ll dp[N], f[N * 2], inv[N * 2]; pii p[3010]; ll comb(int n, int m) { if (n \u0026lt; m) return 0; return f[n] * inv[m] % mod * inv[n - m] % mod; } void problem() { f[0] = inv[0] = 1; for (int i = 1; i \u0026lt;= 200000; ++i) { f[i] = f[i - 1] * i % mod; inv[i] = powf(f[i], mod - 2, mod); } int h = IO(), w = IO(), n = IO(); for (int i = 0; i \u0026lt; n; ++i) { p[i].x = IO(), p[i].y = IO(); } sort(p, p + n); for (int i = 0; i \u0026lt; n; ++i) { dp[i] = comb(p[i].x + p[i].y - 2, p[i].x - 1); } for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; i; ++j) { if (p[j].x \u0026lt;= p[i].x \u0026amp;\u0026amp; p[j].y \u0026lt;= p[i].y) { int x = p[i].x - p[j].x + 1, y = p[i].y - p[j].y + 1; dp[i] = dp[i] - dp[j] * comb(x + y - 2, x - 1) % mod; dp[i] = (dp[i] + mod) % mod; } } } ll ans = comb(h + w - 2, h - 1); for (int i = 0; i \u0026lt; n; ++i) { int x = h - p[i].x + 1, y = w - p[i].y + 1; ans = ans - dp[i] * comb(x + y - 2, x - 1) % mod; ans = (ans + mod) % mod; } print(ans); } Z - Frog 3 斜率优化的dp 当他写出 $(h_j - h_i)^2 + C$ 的时候，用膝盖想都能猜到是要斜率优化了，再加上h数组还递增，好家伙，二分都省了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 const int N = 1e5 + 10, M = 1e6 + 10; ll a[M * 2], dp[M * 2], q[M * 2]; ll pow2(ll x) { return x * x; } ll gety(int i) { return dp[i] + pow2(a[i]); } ll getx(int i) { return a[i]; } int push_check(int j, int k, int i) { return gety(k) - gety(j) \u0026lt; 2 * a[i] * (getx(k) - getx(j)); } int pop_check(int j, int k, int i) { return (gety(k) - gety(j)) * (getx(i) - getx(k)) \u0026gt; (gety(i) - gety(k)) * (getx(k) - getx(j)); } void problem() { int n = IO(); ll m = IO(); fill_w(a + 1, n); dp[1] = 0; int l = 0, r = -1; q[++r] = 1; for (int i = 2; i \u0026lt;= n; ++i) { while (l \u0026lt; r \u0026amp;\u0026amp; push_check(q[l], q[l + 1], i)) ++l; dp[i] = dp[q[l]] + pow2(a[i] - a[q[l]]) + m; while (l \u0026lt; r \u0026amp;\u0026amp; pop_check(q[r - 1], q[r], i)) --r; q[++r] = i; } print(dp[n]); } ","date":"2021-08-24T14:38:39+08:00","permalink":"https://example.com/2021/%E7%8B%82%E8%A1%A5dp-atcoder-educational-dp-contest%E5%85%A8/","title":"狂补dp Atcoder Educational DP Contest(全)"},{"content":" 题意：一颗树上有很多点，0号点为根结点，边有边权即距离，点有点权即该点产量，点产生的运到一个建有伐木场的点的费用是其点到点的距离乘上产量（0号结点一开始就有伐木场，其余结点没有），问你给m个结点建造伐木场，最后最小运送费用为多少？\n一开始状态定义错了，定义 dp[u][k][1/0] 表示以u为根的子树，建造k个伐木场，该点建/不建伐木场的最小费用，交上去只有52分，想了一下，虽然这样定义转移是能转，但是有后效性\n后来看了一下别人的思路，发现自己状态可以加一维来消除后效性\n定义 dp[u][k][fa][1/0] 表示以u为根的子树，建造k个伐木场，fa为u的某个祖先，且该祖先为距离u点最近的建造了伐木场的点，而该点建/不建伐木场的产生的最小费用（不包括u点运到fa的费用）\n转移\n1 2 3 4 5 6 7 8 9 10 11 k = i + j dp[u][k][fa][0] = min{ dp[u][k][fa][0], dp[u][i][fa][0] + dp[v][j][fa][0] + (dep[v] - dep[fa]) * w[v], dp[u][i][fa][0] + dp[v][j][fa][1] } dp[u][k][fa][1] = min{ dp[u][k][fa][1], dp[u][i][fa][1] + dp[v][j][u][0] + (dep[v] - dep[u]) * w[v], dp[u][i][fa][1] + dp[v][j][u][1] } 初始化dp看代码 至于fa可以利用一个vector来记录，最后回溯去掉便可 具体看代码函数区 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define dprint(x) printf(#x\u0026#34; = %lld\\n\u0026#34;, (ll)x) #define dcout(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl #define bug puts(\u0026#34;bug\u0026#34;) #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() using namespace std; /*++++++++++++++++++++++++++++++快读与快输++++++++++++++++++++++++++++++*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026amp;\u0026amp; c != -1; c = getchar()) { if (c == \u0026#39;-\u0026#39;) f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c ^ \u0026#39;0\u0026#39;); } return f ? -x : x; } int getstr(string \u0026amp;s) { int c = getchar(); while (c \u0026lt; 33 \u0026amp;\u0026amp; c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u0026gt; 32; c = getchar()) s.pb(c); return s.size(); } void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } void print(const string\u0026amp; s) { for (char c : s) putchar(c); } template \u0026lt;typename T\u0026gt; void print(T x, char c) { print(x); putchar(c); } /*-----------------------------快读与快输-----------------------------*/ /*++++++++++++++++++++++++++++++不可修改区++++++++++++++++++++++++++++++*/ // gcd template \u0026lt;typename T\u0026gt; T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u0026gt;\u0026gt;= 1, a = a * a % p) if (b \u0026amp; 1) res = res * a % p; return res; } // 数组读入 template \u0026lt;typename T\u0026gt; inline void fill_w(T *a, int cnt) { for (int i = 0; i \u0026lt; cnt; ++i) a[i] = IO();} /*------------------------------不可修改区------------------------------*/ /*++++++++++++++++++++++++++++++可修改区++++++++++++++++++++++++++++++*/ // 自定义结构体 struct pii { int x, y; bool operator\u0026lt; (const pii\u0026amp; j) { return x != j.x ? x \u0026lt; j.x : y \u0026lt; j.y; } }; /*------------------------------可修改区------------------------------*/ /*++++++++++++++++++++++++++++++全局变量区++++++++++++++++++++++++++++++*/ const int mod = 1e9 + 7; const int inf = 0x3f3f3f3f; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1.0); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 2e2 + 10, M = 1e6 + 10; int num[M], dep[N], dp[N][N][N][2], tmp[N][N][2]; vi\u0026lt;int\u0026gt; f; int n, m; /*------------------------------全局变量区------------------------------*/ /*++++++++++++++++++++++++++++++模板代码区++++++++++++++++++++++++++++++*/ int head[N], cnt; //初始化 void init(int n) { fill_n(head, n + 5, -1); cnt = -1; } struct edges { int to, next; int w; void add(int t, int n, int w) { to = t, next = n, this-\u0026gt;w = w; } }edge[N \u0026lt;\u0026lt; 1]; //无向图则需要乘2 inline void add(int u, int v, int w) { edge[++cnt].add(v, head[u], w); head[u] = cnt; } /*------------------------------模板代码区------------------------------*/ /*++++++++++++++++++++++++++++++函数代码区++++++++++++++++++++++++++++++*/ int dfs(int u) { f.pb(u); int sum = 1; for (auto fa : f) { // 初始化 dp[u][0][fa][0] = 0; dp[u][1][fa][1] = 0; } rep(u, i, edge) { int v = edge[i].to; dep[v] = dep[u] + edge[i].w; int son = dfs(v); for (auto fa : f) { // if (fa == u) continue; for (int j = 0; j \u0026lt;= sum + son; ++j) { tmp[j][fa][0] = tmp[j][fa][1] = inf; } for (int j = 0; j \u0026lt;= sum; ++j) { for (int k = 0; k \u0026lt;= son; ++k) { if (j + k \u0026gt; m) break; tmp[j + k][fa][0] = min({ tmp[j + k][fa][0], dp[u][j][fa][0] + dp[v][k][fa][0] + (dep[v] - dep[fa]) * num[v], dp[u][j][fa][0] + dp[v][k][fa][1] }); if (j \u0026gt; 0){ tmp[j + k][fa][1] = min({ tmp[j + k][fa][1], dp[u][j][fa][1] + dp[v][k][u][0] + (dep[v] - dep[u]) * num[v], dp[u][j][fa][1] + dp[v][k][u][1] }); } } } for (int j = 0; j \u0026lt;= sum + son; ++j) { dp[u][j][fa][0] = tmp[j][fa][0]; dp[u][j][fa][1] = tmp[j][fa][1]; } } sum += son; } f.pop_back(); return sum; } /*------------------------------函数代码区------------------------------*/ /*++++++++++++++++++++++++++++++主代码区++++++++++++++++++++++++++++++*/ void problem() { n = IO(), m = IO(); init(n); for (int i = 1; i \u0026lt;= n; ++i) { num[i] = IO(); int fa = IO(), w = IO(); add(fa, i, w); } memset(dp, 0x3f, sizeof dp); dfs(0); print(dp[0][m][0][0]); } /*------------------------------主代码区------------------------------*/ int main() { // int t = IO(); while (1) problem(); return 0; } 当然本题还有一种多叉转二叉的方式\n写了之后发现多叉转二叉在树形背包中的一些好处：\n可以避免一些无用的状态转移 利用记忆化搜索强行变成了一种线性的dp的感觉 记忆化时简单好懂 为了方便状态定义改了改\n定义 dp[u][k][fa][1/0] 表示以u为根的子树，建造k个伐木场，fa为u的某个祖先，且该祖先为距离u点最近的建造了伐木场的点，而该点建/不建伐木场的产生的最小费用（包括u点运到fa的费用）\n简单的来说就是把括号里的不包括改成了包括\n实现起来还是不难的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define dprint(x) printf(#x\u0026#34; = %lld\\n\u0026#34;, (ll)x) #define dcout(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl #define bug puts(\u0026#34;bug\u0026#34;) #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() using namespace std; /*++++++++++++++++++++++++++++++快读与快输++++++++++++++++++++++++++++++*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026amp;\u0026amp; c != -1; c = getchar()) { if (c == \u0026#39;-\u0026#39;) f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c ^ \u0026#39;0\u0026#39;); } return f ? -x : x; } int getstr(string \u0026amp;s) { int c = getchar(); while (c \u0026lt; 33 \u0026amp;\u0026amp; c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u0026gt; 32; c = getchar()) s.pb(c); return s.size(); } void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } void print(const string\u0026amp; s) { for (char c : s) putchar(c); } template \u0026lt;typename T\u0026gt; void print(T x, char c) { print(x); putchar(c); } /*-----------------------------快读与快输-----------------------------*/ /*++++++++++++++++++++++++++++++不可修改区++++++++++++++++++++++++++++++*/ // gcd template \u0026lt;typename T\u0026gt; T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u0026gt;\u0026gt;= 1, a = a * a % p) if (b \u0026amp; 1) res = res * a % p; return res; } // 数组读入 template \u0026lt;typename T\u0026gt; inline void fill_w(T *a, int cnt) { for (int i = 0; i \u0026lt; cnt; ++i) a[i] = IO();} /*------------------------------不可修改区------------------------------*/ /*++++++++++++++++++++++++++++++可修改区++++++++++++++++++++++++++++++*/ // 自定义结构体 struct pii { int l = -1, r = -1, d, w; // int x, y; // bool operator\u0026lt; (const pii\u0026amp; j) { // return x != j.x ? x \u0026lt; j.x : y \u0026lt; j.y; // } }; /*------------------------------可修改区------------------------------*/ /*++++++++++++++++++++++++++++++全局变量区++++++++++++++++++++++++++++++*/ const int mod = 1e9 + 7; const int inf = 0x3f3f3f3f; const ll llf = 1e18; const double eps = 1e-5, PI = acos(-1.0); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 2e2 + 10, M = 1e6 + 10; int dep[N], dp[N][N][N]; pii node[N]; /*------------------------------全局变量区------------------------------*/ /*++++++++++++++++++++++++++++++模板代码区++++++++++++++++++++++++++++++*/ /*------------------------------模板代码区------------------------------*/ /*++++++++++++++++++++++++++++++函数代码区++++++++++++++++++++++++++++++*/ void init_deep(int u) { int lson = node[u].l; while (lson != -1) { dep[lson] = dep[u] + node[lson].d; init_deep(lson); lson = node[lson].r; } } int dfs(int u, int k, int fa) { int\u0026amp; ret = dp[u][k][fa]; if (ret != -1) return ret; int ls = node[u].l, rs = node[u].r; ret = inf; for (int i = 0; i \u0026lt;= k; ++i) { int tmp = 0; if (ls != -1) tmp = dfs(ls, i, fa); if (rs != -1) tmp += dfs(rs, k - i, fa); ret = min(tmp + (dep[u] - dep[fa]) * node[u].w, ret); if (i \u0026lt; k) { tmp = 0; if (ls != -1) tmp = dfs(ls, i, u); if (rs != -1) tmp += dfs(rs, k - i - 1, fa); ret = min(tmp, ret); } } return ret; } /*------------------------------函数代码区------------------------------*/ /*++++++++++++++++++++++++++++++主代码区++++++++++++++++++++++++++++++*/ void problem() { int n = IO(), m = IO(); for (int i = 1; i \u0026lt;= n; ++i) { node[i].w = IO(); int fa = IO(); node[i].d = IO(); node[i].r = node[fa].l; node[fa].l = i; } init_deep(0); memset(dp, -1, sizeof dp); print(dfs(0, m, 0)); } /*------------------------------主代码区------------------------------*/ int main() { // int t = IO(); while (1) problem(); return 0; } ","date":"2021-08-20T16:45:44+08:00","permalink":"https://example.com/2021/%E6%B4%9B%E8%B0%B7-3354-riv-%E6%B2%B3%E6%B5%81/","title":"洛谷 3354 Riv 河流"},{"content":" 题意：有 n 个人，第 i 个人想送给第 p[i] 个人一份礼物，保证 p 数组是一个排列且 p[i] != i ，如果 i 忘记带礼物，则 i 和 p[i] 都不会受到礼物，问恰好有 k 个人忘记带礼物，最少和最多有几个人收不到礼物 如果将送礼物的线路做成图，则将会行形成若干个环。 当一个人忘记带礼物时，则会有两个人收不到礼物 固最大值可以利用贪心来计算，设某个环的大小为 x ，若 x 偶数，则只需要让 k / 2 的人忘记带礼物便可让整个环的人多不能收到礼物；若 x 为奇数，则可以先让 (x - 1) / 2 个人忘记带礼物，此时还差一个人能够收到礼物，只需特判此人是否需要忘记带礼物才能达到恰好 k 个人忘记带便可 再来考虑最小值，这个也考虑贪心做，首先如果某个环的大小为 x , 若要环内的 y 个人忘记带礼物，则如果 y \u0026lt; x 那么最贪心的方式就是让连续 y 个人忘记带礼物，则有 y + 1 个人收不到礼物（这是最贪心的方式了）,若 x == y 则环内所有人都收不到礼物 固最小值的答案可以推得为：若某些环的大小和恰好为 k ，则最小值为 k，否则最小值为 k + 1 对于最小值，问题转化为若干个大小为 v ，数量为 c 的数，能否凑齐恰好为 k 的数，此为多重背包 本题数据太大，尝试过用二进制优化的多重背包，发现复杂度过不去 后来想想二进制优化后产生的01背包对于凑数问题可以用bitset优化（具体看代码实现）,速度可观，完全能过 代码看主代码区部分便可 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define dprint(x) printf(#x\u0026#34; = %lld\\n\u0026#34;, (ll)x) #define dcout(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl #define bug puts(\u0026#34;bug\u0026#34;) #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() using namespace std; /*++++++++++++++++++++++++++++++快读与快输++++++++++++++++++++++++++++++*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026amp;\u0026amp; c != -1; c = getchar()) { if (c == \u0026#39;-\u0026#39;) f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c ^ \u0026#39;0\u0026#39;); } return f ? -x : x; } int getstr(string \u0026amp;s) { int c = getchar(); while (c \u0026lt; 33 \u0026amp;\u0026amp; c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u0026gt; 32; c = getchar()) s.pb(c); return s.size(); } void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } void print(const string\u0026amp; s) { for (char c : s) putchar(c); } template \u0026lt;typename T\u0026gt; void print(T x, char c) { print(x); putchar(c); } /*-----------------------------快读与快输-----------------------------*/ /*++++++++++++++++++++++++++++++不可修改区++++++++++++++++++++++++++++++*/ // gcd template \u0026lt;typename T\u0026gt; T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u0026gt;\u0026gt;= 1, a = a * a % p) if (b \u0026amp; 1) res = res * a % p; return res; } // 数组读入 template \u0026lt;typename T\u0026gt; inline void fill_w(T *a, int cnt) { for (int i = 0; i \u0026lt; cnt; ++i) a[i] = IO();} /*------------------------------不可修改区------------------------------*/ /*++++++++++++++++++++++++++++++可修改区++++++++++++++++++++++++++++++*/ // 自定义结构体 struct pii { int x, y; bool operator\u0026lt; (const pii\u0026amp; j) { return x != j.x ? x \u0026lt; j.x : y \u0026lt; j.y; } }; /*------------------------------可修改区------------------------------*/ /*++++++++++++++++++++++++++++++全局变量区++++++++++++++++++++++++++++++*/ const int mod = 1e9 + 7; const int inf = (1LL \u0026lt;\u0026lt; 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1.0); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e5 + 10, M = 1e6 + 10; int len[M], vis[M], f[M], fa[M], siz[M]; bitset\u0026lt;M\u0026gt; dp; /*------------------------------全局变量区------------------------------*/ /*++++++++++++++++++++++++++++++模板代码区++++++++++++++++++++++++++++++*/ class UF { public: int n; // 当前连通分量数目 int cnt; vector\u0026lt;int\u0026gt; size; vector\u0026lt;int\u0026gt; parent; UF(int _n): n(_n + 1), cnt(_n + 1), size(_n + 1, 1), parent(_n + 1) { int i = 0; for (auto \u0026amp;x : parent) x = i++; } int findset(int x) { return parent[x] == x ? x : parent[x] = findset(parent[x]); } bool unite(int x, int y) { x = findset(x); y = findset(y); if (x == y) { return false; } if (size[x] \u0026lt; size[y]) { swap(x, y); } parent[y] = x; size[x] += size[y]; --cnt; return true; } bool conn(int x, int y) { x = findset(x); y = findset(y); return x == y; } }; /*------------------------------模板代码区------------------------------*/ /*++++++++++++++++++++++++++++++函数代码区++++++++++++++++++++++++++++++*/ /*------------------------------函数代码区------------------------------*/ /*++++++++++++++++++++++++++++++主代码区++++++++++++++++++++++++++++++*/ void problem() { int n = IO(), m = IO(), maxv = 0, cnt = 0, k = m; UF un(n); for (int i = 1; i \u0026lt;= n; ++i) { int p = IO(); un.unite(i, p); } for (int i = 1; i \u0026lt;= n; ++i) { int fa = un.findset(i); if (vis[fa]) continue; vis[fa] = 1; int tot = un.size[fa]; len[tot] += 1; if (tot / 2 \u0026lt;= k) k -= tot / 2, maxv += (tot / 2) * 2; else maxv += k * 2, k = 0; if (tot % 2 == 1) cnt += 1; } maxv += min(k, cnt); vi\u0026lt;int\u0026gt; v; for (int i = 1; i \u0026lt;= n; ++i) { if (len[i]) { int y = 1; while (len[i]) { y = min(y, len[i]); v.pb(y * i); len[i] -= y; y += y; } } } dp[0] = 1; for (size_t i = 0; i \u0026lt; v.size(); ++i) { dp |= (dp \u0026lt;\u0026lt; v[i]); } print(m + !dp[m], \u0026#39; \u0026#39;); print(maxv, \u0026#39;\\n\u0026#39;); } /*------------------------------主代码区------------------------------*/ int main() { // int t = IO(); while (1) problem(); return 0; } ","date":"2021-08-15T14:10:57+08:00","permalink":"https://example.com/2021/cf755f-polandball-and-gifts/","title":"Cf755F PolandBall and Gifts"},{"content":" 题意：给你一些硬币面值为 $a_1, a_2, a_3\u0026hellip;$个数为 $c_1, c_2, c_3\u0026hellip;$，问你1到m有多少个价格可以凑成 多重背包，一开始觉得必须要单调队列才能过了，后来看了别人的思路，发现是自己的格局小了 我们发现如果一个数可以凑成则不需要对其进行转移了 设 dp[i] 表示 i 是否能够凑成，1表示能，0表示不能 用 num[i] 表示当前硬币面值凑成花费了多少个，固转移时需要判断有没有超过个数 看代码好懂 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 #include \u0026lt;cctype\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;bitset\u0026gt; #include \u0026lt;cmath\u0026gt; #define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define dprint(x) printf(#x\u0026#34; = %lld\\n\u0026#34;, (ll)x) #define dcout(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl #define bug puts(\u0026#34;bug\u0026#34;) #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() using namespace std; /*++++++++++++++++++++++++++++++快读与快输++++++++++++++++++++++++++++++*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026amp;\u0026amp; c != -1; c = getchar()) { if (c == \u0026#39;-\u0026#39;) f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c ^ \u0026#39;0\u0026#39;); } return f ? -x : x; } int getstr(string \u0026amp;s) { int c = getchar(); while (c \u0026lt; 33 \u0026amp;\u0026amp; c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u0026gt; 32; c = getchar()) s.pb(c); return s.size(); } void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } // void print(const string\u0026amp; s) { for (char c : s) putchar(c); } template \u0026lt;typename T\u0026gt; void print(T x, char c) { print(x); putchar(c); } /*-----------------------------快读与快输-----------------------------*/ /*++++++++++++++++++++++++++++++不可修改区++++++++++++++++++++++++++++++*/ // gcd template \u0026lt;typename T\u0026gt; T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u0026gt;\u0026gt;= 1, a = a * a % p) if (b \u0026amp; 1) res = res * a % p; return res; } // 数组读入 template \u0026lt;typename T\u0026gt; inline void fill_w(T *a, int cnt) { for (int i = 0; i \u0026lt; cnt; ++i) a[i] = IO();} /*------------------------------不可修改区------------------------------*/ /*++++++++++++++++++++++++++++++可修改区++++++++++++++++++++++++++++++*/ // 自定义结构体 struct pii { // int x, y; int t, d, p, i; bool operator\u0026lt; (const pii\u0026amp; j) { return d \u0026lt; j.d; } }; /*------------------------------可修改区------------------------------*/ /*++++++++++++++++++++++++++++++全局变量区++++++++++++++++++++++++++++++*/ const int mod = 1e9 + 7; const int inf = (1LL \u0026lt;\u0026lt; 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1.0); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e5 + 10, M = 1e6 + 10; int a[110], c[110], dp[N], num[N]; /*------------------------------全局变量区------------------------------*/ /*++++++++++++++++++++++++++++++模板代码区++++++++++++++++++++++++++++++*/ /*------------------------------模板代码区------------------------------*/ /*++++++++++++++++++++++++++++++函数代码区++++++++++++++++++++++++++++++*/ /*------------------------------函数代码区------------------------------*/ /*++++++++++++++++++++++++++++++主代码区++++++++++++++++++++++++++++++*/ void problem() { int n = IO(), m = IO(); if (n + m == 0) exit(0); fill_w(a + 1, n), fill_w(c + 1, n); fill_n(dp, m + 1, 0); dp[0] = 1; for (int i = 1; i \u0026lt;= n; ++i) { fill_n(num, m + 1, 0); for (int j = a[i]; j \u0026lt;= m; ++j) { if (!dp[j] \u0026amp;\u0026amp; dp[j - a[i]] \u0026amp;\u0026amp; num[j - a[i]] \u0026lt; c[i]) { dp[j] = 1; num[j] = num[j - a[i]] + 1; } } } int ans = 0; for (int i = 1; i \u0026lt;= m; ++i) { ans += dp[i]; } print(ans, \u0026#39;\\n\u0026#39;); } /*------------------------------主代码区------------------------------*/ int main() { // int t = IO(); while (1) problem(); return 0; } ","date":"2021-08-13T21:20:35+08:00","permalink":"https://example.com/2021/poj-1742-coins/","title":"POJ 1742 Coins"},{"content":" 题意：着火了，要拯救有n个物品，对于每个物品的价值为 p[i] ，拯救出来所需要的时间为 t[i]， 但过了时间 d[i] 后该物品便无价值了，输出能获得物品的最大价值和拯救物品的顺序（输出其中一种即可）\n这道题看是能看出是01背包，但是状态的转移需要花一些心思\n首先物品的拯救的顺序不能乱来，可以贪心来搞，优先考虑快要无价值的物品\n然后便是非常朴素的01背包问题和求具体方案了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define dprint(x) printf(#x\u0026#34; = %lld\\n\u0026#34;, (ll)x) #define dcout(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl #define bug puts(\u0026#34;bug\u0026#34;) #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() using namespace std; /*++++++++++++++++++++++++++++++快读与快输++++++++++++++++++++++++++++++*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026amp;\u0026amp; c != -1; c = getchar()) { if (c == \u0026#39;-\u0026#39;) f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c ^ \u0026#39;0\u0026#39;); } return f ? -x : x; } int getstr(string \u0026amp;s) { int c = getchar(); while (c \u0026lt; 33 \u0026amp;\u0026amp; c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u0026gt; 32; c = getchar()) s.pb(c); return s.size(); } void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } void print(const string\u0026amp; s) { for (char c : s) putchar(c); } template \u0026lt;typename T\u0026gt; void print(T x, char c) { print(x); putchar(c); } /*-----------------------------快读与快输-----------------------------*/ /*++++++++++++++++++++++++++++++不可修改区++++++++++++++++++++++++++++++*/ // gcd template \u0026lt;typename T\u0026gt; T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u0026gt;\u0026gt;= 1, a = a * a % p) if (b \u0026amp; 1) res = res * a % p; return res; } // 数组读入 template \u0026lt;typename T\u0026gt; inline void fill_w(T *a, int cnt) { for (int i = 0; i \u0026lt; cnt; ++i) a[i] = IO();} /*------------------------------不可修改区------------------------------*/ /*++++++++++++++++++++++++++++++可修改区++++++++++++++++++++++++++++++*/ // 自定义结构体 struct pii { // int x, y; int t, d, p, i; bool operator\u0026lt; (const pii\u0026amp; j) { return d \u0026lt; j.d; } }; /*------------------------------可修改区------------------------------*/ /*++++++++++++++++++++++++++++++全局变量区++++++++++++++++++++++++++++++*/ const int mod = 1e9 + 7; const int inf = (1LL \u0026lt;\u0026lt; 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e5 + 10, M = 1e6 + 10; int dp[110][2005]; pii p[110]; vi\u0026lt;int\u0026gt; res; /*------------------------------全局变量区------------------------------*/ /*++++++++++++++++++++++++++++++模板代码区++++++++++++++++++++++++++++++*/ /*------------------------------模板代码区------------------------------*/ /*++++++++++++++++++++++++++++++函数代码区++++++++++++++++++++++++++++++*/ void solve(int n, int m) { if (m == 0 || n == 0) { print(res.size(), \u0026#39;\\n\u0026#39;); reverse(all(res)); for (int x : res) print(x, \u0026#39; \u0026#39;); exit(0); } if (m \u0026lt; p[n].d \u0026amp;\u0026amp; m \u0026gt;= p[n].t \u0026amp;\u0026amp; dp[n][m] == dp[n - 1][m - p[n].t] + p[n].p) { res.pb(p[n].i); solve(n - 1, m - p[n].t); res.pop_back(); } solve(n - 1, m); } /*------------------------------函数代码区------------------------------*/ /*++++++++++++++++++++++++++++++主代码区++++++++++++++++++++++++++++++*/ void problem() { int n = IO(); for (int i = 1; i \u0026lt;= n; ++i) { p[i].t = IO(), p[i].d = IO(), p[i].p = IO(); p[i].i = i; } sort(p + 1, p + 1 + n); int ans = 0, m = 0; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 0; j \u0026lt;= 2000; ++j) { dp[i][j] = dp[i - 1][j]; if (j \u0026lt; p[i].d \u0026amp;\u0026amp; j \u0026gt;= p[i].t) { dp[i][j] = max(dp[i][j], dp[i - 1][j - p[i].t] + p[i].p); } if (i == n \u0026amp;\u0026amp; dp[i][j] \u0026gt; ans) ans = dp[i][j], m = j; } } print(ans, \u0026#39;\\n\u0026#39;); solve(n, m); } /*------------------------------主代码区------------------------------*/ int main() { // int t = IO(); while (1) problem(); return 0; } ","date":"2021-08-12T20:44:52+08:00","permalink":"https://example.com/2021/cf864e/","title":"Cf864E"},{"content":" 题解：给你两个数组，当 a[i] 被选时， b[i] 必选，问你最终选出a数组的和恰好是b数组的k倍的最大a数组的和，不存在则输出-1 题中需要我们做的是选出一个下标集合使得 $\\sum a_i \\div \\sum b_i = k$ 思维转换一下：$\\sum a_i - k \\sum b_i = 0$ 得到： $\\sum(a_i - k\\times b_i) = 0$ 根据题意可以转化为：给你每个物品质量为 a[i] - k * b[i] 且价值为 a[i] 的物品，问你背包容量为0的最大价值为多少 需要注意的是可能有质量有负数，只需要每个质量加一个偏移量便可 直接看代码的主代码区 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define dprint(x) printf(#x\u0026#34; = %lld\\n\u0026#34;, (ll)x) #define dcout(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl #define bug puts(\u0026#34;bug\u0026#34;) #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() using namespace std; /*++++++++++++++++++++++++++++++快读与快输++++++++++++++++++++++++++++++*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026amp;\u0026amp; c != -1; c = getchar()) { if (c == \u0026#39;-\u0026#39;) f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c ^ \u0026#39;0\u0026#39;); } return f ? -x : x; } int getstr(string \u0026amp;s) { int c = getchar(); while (c \u0026lt; 33 \u0026amp;\u0026amp; c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u0026gt; 32; c = getchar()) s.pb(c); return s.size(); } void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } void print(const string\u0026amp; s) { for (char c : s) putchar(c); } template \u0026lt;typename T\u0026gt; void print(T x, char c) { print(x); putchar(c); } /*-----------------------------快读与快输-----------------------------*/ /*++++++++++++++++++++++++++++++不可修改区++++++++++++++++++++++++++++++*/ // gcd template \u0026lt;typename T\u0026gt; T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u0026gt;\u0026gt;= 1, a = a * a % p) if (b \u0026amp; 1) res = res * a % p; return res; } // 数组读入 template \u0026lt;typename T\u0026gt; inline void fill_w(T *a, int cnt) { for (int i = 0; i \u0026lt; cnt; ++i) a[i] = IO();} /*------------------------------不可修改区------------------------------*/ /*++++++++++++++++++++++++++++++可修改区++++++++++++++++++++++++++++++*/ // 自定义结构体 struct pii { int x, y; bool operator\u0026lt; (const pii\u0026amp; j) { return x != j.x ? x \u0026lt; j.x : y \u0026lt; j.y; } }; /*------------------------------可修改区------------------------------*/ /*++++++++++++++++++++++++++++++全局变量区++++++++++++++++++++++++++++++*/ const int mod = 1e9 + 7; const int inf = (1LL \u0026lt;\u0026lt; 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e5 + 10, M = 1e6 + 10; int a[110], b[110], dp[2][N]; /*------------------------------全局变量区------------------------------*/ /*++++++++++++++++++++++++++++++模板代码区++++++++++++++++++++++++++++++*/ /*------------------------------模板代码区------------------------------*/ /*++++++++++++++++++++++++++++++函数代码区++++++++++++++++++++++++++++++*/ int real(int x) { return x + 10100; } /*------------------------------函数代码区------------------------------*/ /*++++++++++++++++++++++++++++++主代码区++++++++++++++++++++++++++++++*/ void problem() { int n = IO(), k = IO(); fill_w(a + 1, n); fill_w(b + 1, n); memset(dp, 0xf7, sizeof dp); dp[0][real(0)] = 0; int now = 1, pre = 0; for (int i = 1; i \u0026lt;= n; ++i) { int v = a[i] - k * b[i]; for (int j = -10000; j \u0026lt;= 10000; ++j) { dp[now][real(j)] = max(dp[pre][real(j)], dp[pre][real(j - v)] + a[i]); } swap(now, pre); } print(dp[pre][real(0)] == 0 ? -1 : dp[pre][real(0)], \u0026#39;\\n\u0026#39;); } /*------------------------------主代码区------------------------------*/ int main() { // int t = IO(); while (1) problem(); return 0; } ","date":"2021-08-12T18:47:24+08:00","permalink":"https://example.com/2021/cf366c-dima-and-salad/","title":"Cf366C Dima and Salad"},{"content":" 题意：给你一个数组，每次区间询问mex\n这题用主席树比较好写，而且还是在线算法\n利用权值线段树在每个权值上记录该数最后出现的下标，再次基础上加上可持续化，便是主席树了\n最终查询 [l, r] 区间的mex时，则是在版本 r 的权值线段树中找下标小于 l 的最小的数即可\n注意：\n本题不需要离散化，但若是需要离散化则需要同时将比原来数多1的数和0也同时离散化，因为答案必定是原数组中某个数+1或者是0 权值线段树下标至少为1，我们让所有数先+1 直接看模板区代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define dprint(x) printf(#x\u0026#34; = %lld\\n\u0026#34;, (ll)x) #define dcout(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl #define bug puts(\u0026#34;bug\u0026#34;) #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() using namespace std; /*++++++++++++++++++++++++++++++快读与快输++++++++++++++++++++++++++++++*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026amp;\u0026amp; c != -1; c = getchar()) { if (c == \u0026#39;-\u0026#39;) f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c ^ \u0026#39;0\u0026#39;); } return f ? -x : x; } int getstr(string \u0026amp;s) { int c = getchar(); while (c \u0026lt; 33 \u0026amp;\u0026amp; c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u0026gt; 32; c = getchar()) s.pb(c); return s.size(); } void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } void print(const string\u0026amp; s) { for (char c : s) putchar(c); } template \u0026lt;typename T\u0026gt; void print(T x, char c) { print(x); putchar(c); } /*-----------------------------快读与快输-----------------------------*/ /*++++++++++++++++++++++++++++++不可修改区++++++++++++++++++++++++++++++*/ // gcd template \u0026lt;typename T\u0026gt; T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u0026gt;\u0026gt;= 1, a = a * a % p) if (b \u0026amp; 1) res = res * a % p; return res; } // 数组读入 template \u0026lt;typename T\u0026gt; inline void fill_w(T *a, int cnt) { for (int i = 0; i \u0026lt; cnt; ++i) a[i] = IO();} /*------------------------------不可修改区------------------------------*/ /*++++++++++++++++++++++++++++++可修改区++++++++++++++++++++++++++++++*/ // 自定义结构体 struct pii { int x, y; bool operator\u0026lt; (const pii\u0026amp; j) { return x != j.x ? x \u0026lt; j.x : y \u0026lt; j.y; } }; /*------------------------------可修改区------------------------------*/ /*++++++++++++++++++++++++++++++全局变量区++++++++++++++++++++++++++++++*/ const int mod = 1e9 + 7; const int inf = (1LL \u0026lt;\u0026lt; 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 2e5 + 10, M = 1e6 + 10; int a[N], ram, root[N], vis[N]; /*------------------------------全局变量区------------------------------*/ /*++++++++++++++++++++++++++++++模板代码区++++++++++++++++++++++++++++++*/ struct nodes {int l, r, minv; } hjt[N * 25]; int modify(int pre, int l, int r, int val, int pos) { int now = ++ram; hjt[now] = hjt[pre]; if (l == r) { hjt[now].minv = pos; return now; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (val \u0026lt;= mid) hjt[now].l = modify(hjt[now].l, l, mid, val, pos); else hjt[now].r = modify(hjt[now].r, mid + 1, r, val, pos); hjt[now].minv = min(hjt[hjt[now].l].minv, hjt[hjt[now].r].minv); return now; } int query(int tr, int l, int r, int ql) { if (l == r) return l; int mid = (l + r) \u0026gt;\u0026gt; 1; if (hjt[hjt[tr].l].minv \u0026lt; ql) return query(hjt[tr].l, l, mid, ql); return query(hjt[tr].r, mid + 1, r, ql); } /*------------------------------模板代码区------------------------------*/ /*++++++++++++++++++++++++++++++函数代码区++++++++++++++++++++++++++++++*/ /*------------------------------函数代码区------------------------------*/ /*++++++++++++++++++++++++++++++主代码区++++++++++++++++++++++++++++++*/ void problem() { int n = IO(), len = 0, m = IO(); for (int i = 1; i \u0026lt;= n; ++i) { a[i] = IO() + 1; len = max(len, a[i] + 1); } for (int i = 1; i \u0026lt;= n; ++i) { root[i] = modify(root[i - 1], 1, len, a[i], i); } while (m --) { int l = IO(), r = IO(); print(query(root[r], 1, len, l) - 1, \u0026#39;\\n\u0026#39;); } } /*------------------------------主代码区------------------------------*/ int main() { // int t = IO(); while (1) problem(); return 0; } ","date":"2021-08-12T11:32:52+08:00","permalink":"https://example.com/2021/%E6%B4%9B%E8%B0%B7-4137-mex/","title":"洛谷 4137 mex"},{"content":" 题意：给你一个数组，每次询问你某个区间内不同数的个数 本题可以用离线+树状数组来做，常数小，速度快，解法移步至HDU3333刷题记录 利用主席树，最暴力的方式便是利用下标来构建一颗主席树，对于每个数，为其下标上的主席树+1，并记录本数上次出现的下标，为其在当前版本的主席树上的下标-1，最后的询问便是查询 [l, r] 区间版本的主席树中 [l, r] 区间内的和 具体看模板区代码（注意，洛谷本题数据加强，本人测试过，此解法在洛谷上加强的数据会超时2个，但在BZOJ上测试小数据范围（ $n \\le 5e4$ ）可过） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define dprint(x) printf(#x\u0026#34; = %lld\\n\u0026#34;, (ll)x) #define dcout(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl #define bug puts(\u0026#34;bug\u0026#34;) #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() using namespace std; /*++++++++++++++++++++++++++++++快读与快输++++++++++++++++++++++++++++++*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026amp;\u0026amp; c != -1; c = getchar()) { if (c == \u0026#39;-\u0026#39;) f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c ^ \u0026#39;0\u0026#39;); } return f ? -x : x; } int getstr(string \u0026amp;s) { int c = getchar(); while (c \u0026lt; 33 \u0026amp;\u0026amp; c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u0026gt; 32; c = getchar()) s.pb(c); return s.size(); } void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } void print(const string\u0026amp; s) { for (char c : s) putchar(c); } template \u0026lt;typename T\u0026gt; void print(T x, char c) { print(x); putchar(c); } /*-----------------------------快读与快输-----------------------------*/ /*++++++++++++++++++++++++++++++不可修改区++++++++++++++++++++++++++++++*/ // gcd template \u0026lt;typename T\u0026gt; T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u0026gt;\u0026gt;= 1, a = a * a % p) if (b \u0026amp; 1) res = res * a % p; return res; } // 数组读入 template \u0026lt;typename T\u0026gt; inline void fill_w(T *a, int cnt) { for (int i = 0; i \u0026lt; cnt; ++i) a[i] = IO();} /*------------------------------不可修改区------------------------------*/ /*++++++++++++++++++++++++++++++可修改区++++++++++++++++++++++++++++++*/ // 自定义结构体 struct pii { int x, y; bool operator\u0026lt; (const pii\u0026amp; j) { return x != j.x ? x \u0026lt; j.x : y \u0026lt; j.y; } }; /*------------------------------可修改区------------------------------*/ /*++++++++++++++++++++++++++++++全局变量区++++++++++++++++++++++++++++++*/ const int mod = 1e9 + 7; const int inf = (1LL \u0026lt;\u0026lt; 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e6 + 10, M = 1e6 + 10; int a[N], ram, root[N], last[M]; /*------------------------------全局变量区------------------------------*/ /*++++++++++++++++++++++++++++++模板代码区++++++++++++++++++++++++++++++*/ struct nodes {int l, r, sum = 0; } hjt[N * 35]; int build(int l, int r) { int now = ++ram; if (l == r) return now; int mid = (l + r) \u0026gt;\u0026gt; 1; hjt[now].l = build(l, mid); hjt[now].r = build(mid + 1, r); return now; } int modify(int pre, int l, int r, int indx, int val) { int now = ++ram; hjt[now] = hjt[pre], hjt[now].sum += val; if (l == r) return now; int mid = (l + r) \u0026gt;\u0026gt; 1; if (indx \u0026lt;= mid) hjt[now].l = modify(hjt[now].l, l, mid, indx, val); else hjt[now].r = modify(hjt[now].r, mid + 1, r, indx, val); return now; } int query(int tl, int tr, int ql, int qr, int l, int r) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return hjt[tr].sum - hjt[tl].sum; int mid = (l + r) \u0026gt;\u0026gt; 1, res = 0; if (ql \u0026lt;= mid) res = query(hjt[tl].l, hjt[tr].l, ql, qr, l, mid); if (qr \u0026gt; mid) res += query(hjt[tl].r, hjt[tr].r, ql, qr, mid + 1, r); return res; } /*------------------------------模板代码区------------------------------*/ /*++++++++++++++++++++++++++++++函数代码区++++++++++++++++++++++++++++++*/ /*------------------------------函数代码区------------------------------*/ /*++++++++++++++++++++++++++++++主代码区++++++++++++++++++++++++++++++*/ void problem() { int n = IO(); root[0] = build(1, n); for (int i = 1; i \u0026lt;= n; ++i) { a[i] = IO(); root[i] = modify(root[i - 1], 1, n, i, 1); if (last[a[i]]) root[i] = modify(root[i], 1, n, last[a[i]], -1); last[a[i]] = i; } int m = IO(); while (m --) { int l = IO(), r = IO(); print(query(root[l - 1], root[r], l, r, 1, n), \u0026#39;\\n\u0026#39;); } } /*------------------------------主代码区------------------------------*/ int main() { // int t = IO(); while (1) problem(); return 0; } 超时了两发，怎么办呢？ 注意到，构建主席树时，每个数可能都会被构建两次主席树 不妨换个思路来构建主席树，我们每次询问 [l, r] 区间的不同数的个数，其实就是在找 [l, r] 区间内 last[i] \u0026lt; l 的数的个数，转换一下就是 last[i] + 1 \u0026lt;= l 的个数 这样的话，我们在构建主席树时，就可以不用在当前版本中该数的下标上来+1操作，而是在当前版本中该数上次出现的位置 + 1（即 last[i] + 1）上进行+1操作 每次询问 [l, r] 区间，其实就是查询 [l, r] 版本的主席树中 [1, l] 的区间的和 综上，我们对于每个数就可以做到只构建一次主席树了 在洛谷上跑一下，完全能过 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define dprint(x) printf(#x\u0026#34; = %lld\\n\u0026#34;, (ll)x) #define dcout(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl #define bug puts(\u0026#34;bug\u0026#34;) #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() using namespace std; /*++++++++++++++++++++++++++++++快读与快输++++++++++++++++++++++++++++++*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026amp;\u0026amp; c != -1; c = getchar()) { if (c == \u0026#39;-\u0026#39;) f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c ^ \u0026#39;0\u0026#39;); } return f ? -x : x; } int getstr(string \u0026amp;s) { int c = getchar(); while (c \u0026lt; 33 \u0026amp;\u0026amp; c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u0026gt; 32; c = getchar()) s.pb(c); return s.size(); } void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } void print(const string\u0026amp; s) { for (char c : s) putchar(c); } template \u0026lt;typename T\u0026gt; void print(T x, char c) { print(x); putchar(c); } /*-----------------------------快读与快输-----------------------------*/ /*++++++++++++++++++++++++++++++不可修改区++++++++++++++++++++++++++++++*/ // gcd template \u0026lt;typename T\u0026gt; T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u0026gt;\u0026gt;= 1, a = a * a % p) if (b \u0026amp; 1) res = res * a % p; return res; } // 数组读入 template \u0026lt;typename T\u0026gt; inline void fill_w(T *a, int cnt) { for (int i = 0; i \u0026lt; cnt; ++i) a[i] = IO();} /*------------------------------不可修改区------------------------------*/ /*++++++++++++++++++++++++++++++可修改区++++++++++++++++++++++++++++++*/ // 自定义结构体 struct pii { int x, y; bool operator\u0026lt; (const pii\u0026amp; j) { return x != j.x ? x \u0026lt; j.x : y \u0026lt; j.y; } }; /*------------------------------可修改区------------------------------*/ /*++++++++++++++++++++++++++++++全局变量区++++++++++++++++++++++++++++++*/ const int mod = 1e9 + 7; const int inf = (1LL \u0026lt;\u0026lt; 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e6 + 10, M = 1e6 + 10; int a[N], ram, root[N], last[M]; /*------------------------------全局变量区------------------------------*/ /*++++++++++++++++++++++++++++++模板代码区++++++++++++++++++++++++++++++*/ struct nodes {int l, r, sum = 0; } hjt[N * 25]; int build(int l, int r) { int now = ++ram; if (l == r) return now; int mid = (l + r) \u0026gt;\u0026gt; 1; hjt[now].l = build(l, mid); hjt[now].r = build(mid + 1, r); return now; } int modify(int pre, int l, int r, int indx, int val) { int now = ++ram; hjt[now] = hjt[pre], hjt[now].sum += val; if (l == r) return now; int mid = (l + r) \u0026gt;\u0026gt; 1; if (indx \u0026lt;= mid) hjt[now].l = modify(hjt[now].l, l, mid, indx, val); else hjt[now].r = modify(hjt[now].r, mid + 1, r, indx, val); return now; } int query(int tl, int tr, int ql, int qr, int l, int r) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return hjt[tr].sum - hjt[tl].sum; int mid = (l + r) \u0026gt;\u0026gt; 1, res = 0; if (ql \u0026lt;= mid) res = query(hjt[tl].l, hjt[tr].l, ql, qr, l, mid); if (qr \u0026gt; mid) res += query(hjt[tl].r, hjt[tr].r, ql, qr, mid + 1, r); return res; } /*------------------------------模板代码区------------------------------*/ /*++++++++++++++++++++++++++++++函数代码区++++++++++++++++++++++++++++++*/ /*------------------------------函数代码区------------------------------*/ /*++++++++++++++++++++++++++++++主代码区++++++++++++++++++++++++++++++*/ void problem() { int n = IO(); root[0] = build(1, n); for (int i = 1; i \u0026lt;= n; ++i) { a[i] = IO(); root[i] = modify(root[i - 1], 1, n, last[a[i]] + 1, 1); last[a[i]] = i; } int m = IO(); while (m --) { int l = IO(), r = IO(); print(query(root[l - 1], root[r], 1, l, 1, n), \u0026#39;\\n\u0026#39;); } } /*------------------------------主代码区------------------------------*/ int main() { // int t = IO(); while (1) problem(); return 0; } ","date":"2021-08-10T10:37:01+08:00","permalink":"https://example.com/2021/%E6%B4%9B%E8%B0%B7-1972-hh%E7%9A%84%E9%A1%B9%E9%93%BE/","title":"洛谷-1972 HH的项链"},{"content":" 题意：给你一个数组，问你区间 [l,r] 中出现次数超过 (r - l + 1) / k 次的最小的数，不存在输出-1 在修改一下普通主席树的询问便可，先从主席树的左边开始找，如果左边的个数和都小于了 (r - l + 1) / k 那就不用找了，但如果找到了，则右子树就不用找了 直接看模板区代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define dprint(x) printf(#x\u0026#34; = %lld\\n\u0026#34;, (ll)x) #define dcout(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl #define bug puts(\u0026#34;bug\u0026#34;) #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() using namespace std; /*++++++++++++++++++++++++++++++快读与快输++++++++++++++++++++++++++++++*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026amp;\u0026amp; c != -1; c = getchar()) { if (c == \u0026#39;-\u0026#39;) f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c ^ \u0026#39;0\u0026#39;); } return f ? -x : x; } int getstr(string \u0026amp;s) { int c = getchar(); while (c \u0026lt; 33 \u0026amp;\u0026amp; c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u0026gt; 32; c = getchar()) s.pb(c); return s.size(); } void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } void print(const string\u0026amp; s) { for (char c : s) putchar(c); } template \u0026lt;typename T\u0026gt; void print(T x, char c) { print(x); putchar(c); } /*-----------------------------快读与快输-----------------------------*/ /*++++++++++++++++++++++++++++++不可修改区++++++++++++++++++++++++++++++*/ // gcd template \u0026lt;typename T\u0026gt; T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u0026gt;\u0026gt;= 1, a = a * a % p) if (b \u0026amp; 1) res = res * a % p; return res; } // 数组读入 template \u0026lt;typename T\u0026gt; inline void fill_w(T *a, int cnt) { for (int i = 0; i \u0026lt; cnt; ++i) a[i] = IO();} /*------------------------------不可修改区------------------------------*/ /*++++++++++++++++++++++++++++++可修改区++++++++++++++++++++++++++++++*/ // 自定义结构体 struct pii { int x, y; bool operator\u0026lt; (const pii\u0026amp; j) { return x != j.x ? x \u0026lt; j.x : y \u0026lt; j.y; } }; /*------------------------------可修改区------------------------------*/ /*++++++++++++++++++++++++++++++全局变量区++++++++++++++++++++++++++++++*/ const int mod = 1e9 + 7; const int inf = (1LL \u0026lt;\u0026lt; 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 3e5 + 10, M = 1e6 + 10; int a[N], ram, root[N]; /*------------------------------全局变量区------------------------------*/ /*++++++++++++++++++++++++++++++模板代码区++++++++++++++++++++++++++++++*/ struct nodes {int l, r, sum = 0; } hjt[N * 30]; int build(int l, int r) { int now = ++ram; if (l == r) return now; int mid = (l + r) \u0026gt;\u0026gt; 1; hjt[now].l = build(l, mid); hjt[now].r = build(mid + 1, r); return now; } int modify(int pre, int l, int r, int indx) { int now = ++ram; hjt[now] = hjt[pre], hjt[now].sum += 1; if (l == r) return now; int mid = (l + r) \u0026gt;\u0026gt; 1; if (indx \u0026lt;= mid) hjt[now].l = modify(hjt[now].l, l, mid, indx); else hjt[now].r = modify(hjt[now].r, mid + 1, r, indx); return now; } int query(int tl, int tr, int l, int r, int k) { if (hjt[tr].sum - hjt[tl].sum \u0026lt;= k) return -1; if (l == r) return l; int mid = (l + r) \u0026gt;\u0026gt; 1; int res = hjt[hjt[tr].l].sum - hjt[hjt[tl].l].sum, ret = -1; if (res \u0026gt;= k) ret = query(hjt[tl].l, hjt[tr].l, l, mid, k); if (ret == -1) ret = query(hjt[tl].r, hjt[tr].r, mid + 1, r, k); return ret; } /*------------------------------模板代码区------------------------------*/ /*++++++++++++++++++++++++++++++函数代码区++++++++++++++++++++++++++++++*/ /*------------------------------函数代码区------------------------------*/ /*++++++++++++++++++++++++++++++主代码区++++++++++++++++++++++++++++++*/ void problem() { int n = IO(), m = IO(); root[0] = build(1, n); for (int i = 1; i \u0026lt;= n; ++i) { a[i] = IO(); root[i] = modify(root[i - 1], 1, n, a[i]); } while (m--) { int l = IO(), r = IO(), k = IO(); k = (r - l + 1) / k; print(query(root[l - 1], root[r], 1, n, k), \u0026#39;\\n\u0026#39;); } } /*------------------------------主代码区------------------------------*/ int main() { // int t = IO(); while (1) problem(); return 0; } ","date":"2021-08-10T09:37:29+08:00","permalink":"https://example.com/2021/cf840d-destiny/","title":"Cf840D Destiny"},{"content":" 题意：求解一个区间中的第k大，本题带单点修改 考虑如果是静态主席树的话，其本质是利用了前缀和思想，但我们知道前缀和只能查询不能再短时间内单点修改，这个时候就可以考虑不用前缀和来维护主席树了。 想到可以单点修改又可以区间查询的数据结构就有线段树和树状数组了 为了方便起见，我们用树状数组来维护主席树 想象树状数组每个下标都是一个主席树，这样就可以做到单点树修改和区间树查询了 值得注意的是：之前的前缀和主席树是当前树的相同结点是继承上一棵树的，他是利用前一个树来创建一颗新的树。但我们用树状数组就是更新式的，他并没有用到上一棵树的信息，同样还是试想树状数组每一个下标都是一颗树，每次都是更新那棵树，而不是创一颗树，这样理解会好一些。 主要直接看模板代码区 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define dprint(x) printf(#x\u0026#34; = %lld\\n\u0026#34;, (ll)x) #define dcout(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl #define bug puts(\u0026#34;bug\u0026#34;) #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() #define lb(x) ((x) \u0026amp; (-x)) using namespace std; /*++++++++++++++++++++++++++++++快读与快输++++++++++++++++++++++++++++++*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026amp;\u0026amp; c != -1; c = getchar()) { if (c == \u0026#39;-\u0026#39;) f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c ^ \u0026#39;0\u0026#39;); } return f ? -x : x; } int getstr(string \u0026amp;s) { int c = getchar(); while (c \u0026lt; 33 \u0026amp;\u0026amp; c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u0026gt; 32; c = getchar()) s.pb(c); return s.size(); } void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } void print(const string\u0026amp; s) { for (char c : s) putchar(c); } template \u0026lt;typename T\u0026gt; void print(T x, char c) { print(x); putchar(c); } /*-----------------------------快读与快输-----------------------------*/ /*++++++++++++++++++++++++++++++不可修改区++++++++++++++++++++++++++++++*/ // gcd template \u0026lt;typename T\u0026gt; T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u0026gt;\u0026gt;= 1, a = a * a % p) if (b \u0026amp; 1) res = res * a % p; return res; } // 数组读入 template \u0026lt;typename T\u0026gt; inline void fill_w(T *a, int cnt) { for (int i = 0; i \u0026lt; cnt; ++i) a[i] = IO();} /*------------------------------不可修改区------------------------------*/ /*++++++++++++++++++++++++++++++可修改区++++++++++++++++++++++++++++++*/ // 自定义结构体 struct pii { int q, x, y, k; // int x, y; // bool operator\u0026lt; (const pii\u0026amp; j) { // return x != j.x ? x \u0026lt; j.x : y \u0026lt; j.y; // } }; /*------------------------------可修改区------------------------------*/ /*++++++++++++++++++++++++++++++全局变量区++++++++++++++++++++++++++++++*/ const int mod = 1e9 + 7; const int inf = (1LL \u0026lt;\u0026lt; 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 2e4 + 10, M = 1e6 + 10; int a[N], ram, root[N], rnk[N \u0026lt;\u0026lt; 1]; set\u0026lt;int\u0026gt; ms; umap\u0026lt;int, int\u0026gt; mp; pii p[N]; /*------------------------------全局变量区------------------------------*/ /*++++++++++++++++++++++++++++++模板代码区++++++++++++++++++++++++++++++*/ struct nodes{ int l = 0, r = 0, sum = 0; }hjt[N * 200]; void push_up(int indx) { hjt[indx].sum = hjt[hjt[indx].l].sum + hjt[hjt[indx].r].sum; } int modify(int pre, int l, int r, int indx, int val) { int now = (pre == 0 ? ++ram : pre); if (l == r) { hjt[now].sum += val; return now; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (indx \u0026lt;= mid) hjt[now].l = modify(hjt[now].l, l, mid, indx, val); else hjt[now].r = modify(hjt[now].r, mid + 1, r, indx, val); push_up(now); return now; } int query(vi\u0026lt;int\u0026gt;\u0026amp; tl, vi\u0026lt;int\u0026gt;\u0026amp; tr, int l, int r, int k) { if (l == r) return l; int mid = (l + r) \u0026gt;\u0026gt; 1, res = 0; for (int x : tl) res -= hjt[hjt[x].l].sum; for (int x : tr) res += hjt[hjt[x].l].sum; if (k \u0026lt;= res) { for (int\u0026amp; x : tl) x = hjt[x].l; for (int\u0026amp; x : tr) x = hjt[x].l; return query(tl, tr, l, mid, k); } for (int\u0026amp; x : tl) x = hjt[x].r; for (int\u0026amp; x : tr) x = hjt[x].r; return query(tl, tr, mid + 1, r, k - res); } void modify_tree(int indx, int val, int n, int len) { int x = mp[a[indx]]; while (indx \u0026lt;= n) { root[indx] = modify(root[indx], 1, len, x, val); indx += lb(indx); } } int query_tree(int l, int r, int k, int len) { vi\u0026lt;int\u0026gt; tl, tr; // 预处理有哪些树状数组的主席树要求和 for (int i = l - 1; i \u0026gt; 0; i -= lb(i)) tl.pb(root[i]); for (int i = r; i \u0026gt; 0; i -= lb(i)) tr.pb(root[i]); return query(tl, tr, 1, len, k); } /*------------------------------模板代码区------------------------------*/ /*++++++++++++++++++++++++++++++函数代码区++++++++++++++++++++++++++++++*/ /*------------------------------函数代码区------------------------------*/ /*++++++++++++++++++++++++++++++主代码区++++++++++++++++++++++++++++++*/ void problem() { int n = IO(), m = IO(); for (int i = 1; i \u0026lt;= n; ++i) { a[i] = IO(); ms.insert(a[i]); } for (int i = 1; i \u0026lt;= m; ++i) { string s; getstr(s); if (s[0] == \u0026#39;Q\u0026#39;) { p[i].q = 1, p[i].x = IO(), p[i].y = IO(); p[i].k = IO(); } else { p[i].q = 2, p[i].x = IO(), p[i].y = IO(); ms.insert(p[i].y); } } int cnt = 0; for (int x : ms) mp[x] = ++cnt, rnk[cnt] = x; // 初始化建树，和寻常不同，这个树是更新式的，而不是继承式的（直接连接上一棵树的子结点，更新不一样的子结点） for (int i = 1; i \u0026lt;= n; ++i) modify_tree(i, 1, n, cnt); for (int i = 1; i \u0026lt;= m; ++i) { if (p[i].q == 1) { print(rnk[query_tree(p[i].x, p[i].y, p[i].k, cnt)], \u0026#39;\\n\u0026#39;); } else { modify_tree(p[i].x, -1, n, cnt); a[p[i].x] = p[i].y; modify_tree(p[i].x, 1, n, cnt); } } } /*------------------------------主代码区------------------------------*/ int main() { // int t = IO(); while (1) problem(); return 0; } ","date":"2021-08-08T22:52:29+08:00","permalink":"https://example.com/2021/%E6%B4%9B%E8%B0%B7-p2617/","title":"洛谷 P2617"},{"content":" 给你一个数组，每次提问你区间中不超过k的个数 主席树板子题，需要注意的是只对数组离散化是不够的，需要离线把所有询问的k值也进行离散化 直接看代码的主代码区和模板区 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define dprint(x) printf(#x\u0026#34; = %lld\\n\u0026#34;, (ll)x) #define dcout(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl #define bug puts(\u0026#34;bug\u0026#34;) #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() #define ls node \u0026lt;\u0026lt; 1 #define rs (ls) | 1 using namespace std; /*++++++++++++++++++++++++++++++快读与快输++++++++++++++++++++++++++++++*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026amp;\u0026amp; c != -1; c = getchar()) { if (c == \u0026#39;-\u0026#39;) f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c ^ \u0026#39;0\u0026#39;); } return f ? -x : x; } int getstr(string \u0026amp;s) { int c = getchar(); while (c \u0026lt; 33 \u0026amp;\u0026amp; c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u0026gt; 32; c = getchar()) s.pb(c); return s.size(); } void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } void print(const string\u0026amp; s) { for (char c : s) putchar(c); } template \u0026lt;typename T\u0026gt; void print(T x, char c) { print(x); putchar(c); } /*-----------------------------快读与快输-----------------------------*/ /*++++++++++++++++++++++++++++++不可修改区++++++++++++++++++++++++++++++*/ // gcd template \u0026lt;typename T\u0026gt; T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u0026gt;\u0026gt;= 1, a = a * a % p) if (b \u0026amp; 1) res = res * a % p; return res; } // 数组读入 template \u0026lt;typename T\u0026gt; inline void fill_w(T *a, int cnt) { for (int i = 0; i \u0026lt; cnt; ++i) a[i] = IO();} /*------------------------------不可修改区------------------------------*/ /*++++++++++++++++++++++++++++++可修改区++++++++++++++++++++++++++++++*/ // 自定义结构体 struct pii { int l, r, x; // int x, y; // bool operator\u0026lt; (const pii\u0026amp; j) { // return x != j.x ? x \u0026lt; j.x : y \u0026lt; j.y; // } }; /*------------------------------可修改区------------------------------*/ /*++++++++++++++++++++++++++++++全局变量区++++++++++++++++++++++++++++++*/ const int mod = 1e9 + 7; const int inf = (1LL \u0026lt;\u0026lt; 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 2e5 + 10, M = 1e5 + 10; int a[M], ram, root[M], kase; pii q[M]; vi\u0026lt;int\u0026gt; vt; /*------------------------------全局变量区------------------------------*/ /*++++++++++++++++++++++++++++++模板代码区++++++++++++++++++++++++++++++*/ struct nodes{ int l, r, sum = 0; }hjt[M * 20]; int build(int l, int r) { int now = ++ram; if (l == r) return now; int mid = (l + r) \u0026gt;\u0026gt; 1; hjt[now].l = build(l, mid); hjt[now].r = build(mid + 1, r); return now; } int insert(int pre, int l, int r, int indx) { int now = ++ram; hjt[now] = hjt[pre], hjt[now].sum += 1; if (l == r) return now; int mid = (l + r) \u0026gt;\u0026gt; 1; if (indx \u0026lt;= mid) hjt[now].l = insert(hjt[now].l, l, mid, indx); else hjt[now].r = insert(hjt[now].r, mid + 1, r, indx); return now; } int query(int tl, int tr, int l, int r, int x) { if (l == r) return hjt[tr].sum - hjt[tl].sum; int mid = (l + r) \u0026gt;\u0026gt; 1; int res = hjt[hjt[tr].l].sum - hjt[hjt[tl].l].sum; if (x \u0026gt; mid) return res + query(hjt[tl].r, hjt[tr].r, mid + 1, r, x); return query(hjt[tl].l, hjt[tr].l, l, mid, x); } /*------------------------------模板代码区------------------------------*/ /*++++++++++++++++++++++++++++++函数代码区++++++++++++++++++++++++++++++*/ int get_id(int x) { return lower_bound(all(vt), x) - vt.begin() + 1; } /*------------------------------函数代码区------------------------------*/ /*++++++++++++++++++++++++++++++主代码区++++++++++++++++++++++++++++++*/ void problem() { int n = IO(), m = IO(); ram = 0; root[0] = build(1, n); for (int i = 1; i \u0026lt;= n; ++i) { a[i] = IO(); vt.pb(a[i]); } for (int i = 1; i \u0026lt;= m; ++i) { q[i].l = IO() + 1, q[i].r = IO() + 1; q[i].x = IO(); vt.pb(q[i].x); } sort(all(vt)); vt.erase(unique(all(vt)), vt.end()); for (int i = 1; i \u0026lt;= n; ++i) { root[i] = insert(root[i - 1], 1, vt.size(), get_id(a[i])); } printf(\u0026#34;Case %d:\\n\u0026#34;, ++kase); for (int i = 1; i \u0026lt;= m; ++i) { print(query(root[q[i].l - 1], root[q[i].r], 1, vt.size(), get_id(q[i].x)), \u0026#39;\\n\u0026#39;); } vt.clear(); } /*------------------------------主代码区------------------------------*/ int main() { int t = IO(); while (1) problem(); return 0; } ","date":"2021-08-07T17:39:53+08:00","permalink":"https://example.com/2021/hdu-4417-super-mario/","title":"HDU 4417 Super Mario"},{"content":" 题意：给你一个长度为n的序列，让你在里面挑2k个数出来，然后进行两两配对，配对后的得分为两个数只差的平方，先让你求出最小的得分和 首先，两个数的配对方式要贪心选，即要最小化，则只需要挑两个大小接近的数即可，固要将原数组排序 排序后，一个数若选的话，则另一个配对的数一定是其相邻的数 一个数选与不选，最后选出2k个数，这个解释十分像是一个01背包问题 设 dp[i][j] 为前 i 个数中，选 2*j 个数的最优解 则转移方程为: dp[i][j] = max(dp[i - 1][j], dp[i - 2][j - 1] + (a[i] - a[i - 1]) * (a[i] - a[i - 1]) ) 第二维大于0的状态全部初始化为正无穷 代码直接看主代码区 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define dprint(x) printf(#x\u0026#34; = %lld\\n\u0026#34;, (ll)x) #define dcout(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl #define bug puts(\u0026#34;bug\u0026#34;) #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() using namespace std; /*++++++++++++++++++++++++++++++快读与快输++++++++++++++++++++++++++++++*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026amp;\u0026amp; c != -1; c = getchar()) { if (c == \u0026#39;-\u0026#39;) f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c ^ \u0026#39;0\u0026#39;); } return f ? -x : x; } int getstr(string \u0026amp;s) { int c = getchar(); while (c \u0026lt; 33 \u0026amp;\u0026amp; c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u0026gt; 32; c = getchar()) s.pb(c); return s.size(); } void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } void print(const string\u0026amp; s) { for (char c : s) putchar(c); } template \u0026lt;typename T\u0026gt; void print(T x, char c) { print(x); putchar(c); } /*-----------------------------快读与快输-----------------------------*/ /*++++++++++++++++++++++++++++++不可修改区++++++++++++++++++++++++++++++*/ // gcd template \u0026lt;typename T\u0026gt; T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u0026gt;\u0026gt;= 1, a = a * a % p) if (b \u0026amp; 1) res = res * a % p; return res; } // 数组读入 template \u0026lt;typename T\u0026gt; inline void fill_w(T *a, int cnt) { for (int i = 0; i \u0026lt; cnt; ++i) a[i] = IO();} /*------------------------------不可修改区------------------------------*/ /*++++++++++++++++++++++++++++++可修改区++++++++++++++++++++++++++++++*/ // 自定义结构体 struct pii { int x, y; bool operator\u0026lt; (const pii\u0026amp; j) { return x != j.x ? x \u0026lt; j.x : y \u0026lt; j.y; } }; /*------------------------------可修改区------------------------------*/ /*++++++++++++++++++++++++++++++全局变量区++++++++++++++++++++++++++++++*/ const int mod = 1e9 + 7; const int inf = 0x3f3f3f3f; const ll INF = 1e17; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e3 + 10, M = 1e6 + 10; int a[N \u0026lt;\u0026lt; 1], dp[N \u0026lt;\u0026lt; 1][N]; /*------------------------------全局变量区------------------------------*/ /*++++++++++++++++++++++++++++++模板代码区++++++++++++++++++++++++++++++*/ /*------------------------------模板代码区------------------------------*/ /*++++++++++++++++++++++++++++++函数代码区++++++++++++++++++++++++++++++*/ int cal(int a) { return a * a; } /*------------------------------函数代码区------------------------------*/ /*++++++++++++++++++++++++++++++主代码区++++++++++++++++++++++++++++++*/ void problem() { int n = IO(), k = IO(); fill_w(a + 1, n); sort(a + 1, a + 1 + n); fill_n(dp[0] + 1, k, inf); fill_n(dp[1] + 1, k, inf); for (int i = 2; i \u0026lt;= n; ++i) { fill_n(dp[i] + 1, k, inf); for (int j = 1; j \u0026lt;= i / 2 \u0026amp;\u0026amp; j \u0026lt;= k; ++j) { dp[i][j] = min(dp[i - 1][j], dp[i - 2][j - 1] + cal(a[i] - a[i - 1])); } } print(dp[n][k], \u0026#39;\\n\u0026#39;); } /*------------------------------主代码区------------------------------*/ int main() { #ifndef ONLINE_JUDGE freopen(\u0026#34;D:/MYCODE/vsCode-c/test.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); // freopen(\u0026#34;D:/MYCODE/vsCode-c/test.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif // int t = 1; // t = IO(); // while (t--) problem(); while (1) problem(); return 0; } ","date":"2021-08-04T20:30:19+08:00","permalink":"https://example.com/2021/hdu-1421-%E6%90%AC%E5%AF%9D%E5%AE%A4/","title":"HDU 1421 搬寝室"},{"content":" 题意：给你两个字符串a、b，你每次可以把一个区间内的所有字符变成一个字符，问让a字符串变成b字符串的最少操作次数\n首先肯定要知道区间中从无到b在此区间中的字符串的最少操作次数，设为 f[l][r]\n再来就是从a字符串操作成b字符串的最少操作次数，设 dp[i] 表示前 i 长度字符串，由a变为b的最少操作次数\n则dp的转移为\n若 a[i] != b[i] ，则 dp[i] = f[1][i] 若 a[i] = b[i] ， 则 dp[i] = dp[i - 1] ,当前这个位置不用操作 最后有点类似划分dp了 ： dp[i] = min(dp[i], dp[j] + f[j + 1][i]) 其中 0 \u0026lt;= j \u0026lt; i 而 f[l][r] 的转移则为\n若 b[l] != b[r] ，则 f[l][r] = min(f[l + 1][r], f[l][r - 1]) + 1 若 b[l] = b[r] ，则 f[l][r] = min(f[l + 1][r], f[l][r - 1]) 最后便是区间dp了：f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r]) 其中 l \u0026lt;= k \u0026lt; r 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define dprint(x) printf(#x\u0026#34; = %lld\\n\u0026#34;, (ll)x) #define dcout(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl #define bug puts(\u0026#34;bug\u0026#34;) #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() using namespace std; /*++++++++++++++++++++++++++++++快读与快输++++++++++++++++++++++++++++++*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026amp;\u0026amp; c != -1; c = getchar()) { if (c == \u0026#39;-\u0026#39;) f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c ^ \u0026#39;0\u0026#39;); } return f ? -x : x; } int getstr(string \u0026amp;s) { int c = getchar(); while (c \u0026lt; 33 \u0026amp;\u0026amp; c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u0026gt; 32; c = getchar()) s.pb(c); return s.size(); } void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } void print(const string\u0026amp; s) { for (char c : s) putchar(c); } template \u0026lt;typename T\u0026gt; void print(T x, char c) { print(x); putchar(c); } /*-----------------------------快读与快输-----------------------------*/ /*++++++++++++++++++++++++++++++不可修改区++++++++++++++++++++++++++++++*/ // gcd template \u0026lt;typename T\u0026gt; T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u0026gt;\u0026gt;= 1, a = a * a % p) if (b \u0026amp; 1) res = res * a % p; return res; } // 数组读入 template \u0026lt;typename T\u0026gt; inline void fill_w(T *a, int cnt) { for (int i = 0; i \u0026lt; cnt; ++i) a[i] = IO();} /*------------------------------不可修改区------------------------------*/ /*++++++++++++++++++++++++++++++可修改区++++++++++++++++++++++++++++++*/ // 自定义结构体 struct pii { int x, y; bool operator\u0026lt; (const pii\u0026amp; j) { return x != j.x ? x \u0026lt; j.x : y \u0026lt; j.y; } }; /*------------------------------可修改区------------------------------*/ /*++++++++++++++++++++++++++++++全局变量区++++++++++++++++++++++++++++++*/ const int mod = 1e9 + 7; const int inf = (1LL \u0026lt;\u0026lt; 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e5 + 10, M = 1e6 + 10; int dp[110], f[110][110]; /*------------------------------全局变量区------------------------------*/ /*++++++++++++++++++++++++++++++模板代码区++++++++++++++++++++++++++++++*/ /*------------------------------模板代码区------------------------------*/ /*++++++++++++++++++++++++++++++函数代码区++++++++++++++++++++++++++++++*/ /*------------------------------函数代码区------------------------------*/ /*++++++++++++++++++++++++++++++主代码区++++++++++++++++++++++++++++++*/ void problem() { string a, b; int n = getstr(a); getstr(b); a = \u0026#34; \u0026#34; + a, b = \u0026#34; \u0026#34; + b; for (int i = n; i \u0026gt;= 1; --i) { f[i][i] = 1; for (int j = i + 1; j \u0026lt;= n; ++j) { // [i, j] f[i][j] = min(f[i + 1][j], f[i][j - 1]); if (b[i] != b[j]) f[i][j] += 1; for (int k = i; k \u0026lt; j; ++k) { f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j]); } } } for (int i = 1; i \u0026lt;= n; ++i) { dp[i] = f[1][i]; if (a[i] == b[i]) dp[i] = dp[i - 1]; for (int j = 0; j \u0026lt; i; ++j) { dp[i] = min(dp[i], dp[j] + f[j + 1][i]); } } print(dp[n], \u0026#39;\\n\u0026#39;); } /*------------------------------主代码区------------------------------*/ int main() { // int t = 1; // t = IO(); // while (t--) problem(); while (1) problem(); return 0; } ","date":"2021-08-04T18:29:03+08:00","permalink":"https://example.com/2021/hdu-2476/","title":"HDU 2476"},{"content":" 题意：给你一个字符串，你可以删除一些字符（也可以不删），问你有多少种删除方式使得最终得到一个回文串\n将题意转化一下，就是求一个字符串有多少个回文子序列\n设 dp[l][r] 为区间 [l, r] 中有多少个回文子序列\n状态转移需要用到容斥\n若 s[l] != s[r] ，则 dp[l][r] = dp[l][r - 1] + dp[l + 1][r] - dp[l + 1][r - 1] 否则， dp[l][r] = (dp[l][r - 1] + dp[l + 1][r] - dp[l + 1][r - 1]) + dp[l + 1][r - 1] + 1 上式化简后为 dp[l][r] = dp[l][r - 1] + dp[l + 1][r] + 1 相等的情况下加一是因为加上了 s[l] 和 s[r] 两个字符拼接后得到的回文串\n代码直接看 主代码区\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define dprint(x) printf(#x\u0026#34; = %lld\\n\u0026#34;, (ll)x) #define dcout(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl #define bug puts(\u0026#34;bug\u0026#34;) #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() using namespace std; /*++++++++++++++++++++++++++++++快读与快输++++++++++++++++++++++++++++++*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026amp;\u0026amp; c != -1; c = getchar()) { if (c == \u0026#39;-\u0026#39;) f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c ^ \u0026#39;0\u0026#39;); } return f ? -x : x; } int getstr(string \u0026amp;s) { int c = getchar(); while (c \u0026lt; 33 \u0026amp;\u0026amp; c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u0026gt; 32; c = getchar()) s.pb(c); return s.size(); } void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } void print(const string\u0026amp; s) { for (char c : s) putchar(c); } template \u0026lt;typename T\u0026gt; void print(T x, char c) { print(x); putchar(c); } /*-----------------------------快读与快输-----------------------------*/ /*++++++++++++++++++++++++++++++不可修改区++++++++++++++++++++++++++++++*/ // gcd template \u0026lt;typename T\u0026gt; T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u0026gt;\u0026gt;= 1, a = a * a % p) if (b \u0026amp; 1) res = res * a % p; return res; } // 数组读入 template \u0026lt;typename T\u0026gt; inline void fill_w(T *a, int cnt) { for (int i = 0; i \u0026lt; cnt; ++i) a[i] = IO();} /*------------------------------不可修改区------------------------------*/ /*++++++++++++++++++++++++++++++可修改区++++++++++++++++++++++++++++++*/ // 自定义结构体 struct pii { int x, y; bool operator\u0026lt; (const pii\u0026amp; j) { return x != j.x ? x \u0026lt; j.x : y \u0026lt; j.y; } }; /*------------------------------可修改区------------------------------*/ /*++++++++++++++++++++++++++++++全局变量区++++++++++++++++++++++++++++++*/ const int mod = 1e9 + 7; const int inf = (1LL \u0026lt;\u0026lt; 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e5 + 10, M = 1e6 + 10; ll a[N], dp[100][100]; /*------------------------------全局变量区------------------------------*/ /*++++++++++++++++++++++++++++++模板代码区++++++++++++++++++++++++++++++*/ /*------------------------------模板代码区------------------------------*/ /*++++++++++++++++++++++++++++++函数代码区++++++++++++++++++++++++++++++*/ /*------------------------------函数代码区------------------------------*/ /*++++++++++++++++++++++++++++++主代码区++++++++++++++++++++++++++++++*/ void problem() { string s; int n = getstr(s); s = \u0026#34; \u0026#34; + s; for (int i = n; i \u0026gt;= 1; --i) { dp[i][i] = 1; for (int j = i + 1; j \u0026lt;= n; ++j) { dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]; if (s[i] == s[j]) dp[i][j] += dp[i + 1][j - 1] + 1; } } print(dp[1][n], \u0026#39;\\n\u0026#39;); } /*------------------------------主代码区------------------------------*/ int main() { int t = 1; t = IO(); while (t--) problem(); // while (1) problem(); return 0; } ","date":"2021-08-04T13:42:06+08:00","permalink":"https://example.com/2021/uva-10617/","title":"UVA 10617"},{"content":" 题意：给你一个长为n的字符串，问你最少插入多少个字符可以使得这个字符串成为一个回文字符串\n很容易想到直接找最长的回文子序列便可\n设 dp[l][r] 为区间 [l, r] 的字符串中最长的回文子序列\n则转移方程\n若 s[l] != s[r]则 dp[l][r] = max(dp[l + 1][r], dp[l][r - 1])\n否则 dp[l][r] = max({dp[l + 1][r], dp[l][r - 1], dp[l + 1][r - 1] + 2})\n初始化 dp[i][i] = 1\n最后的答案便是 n - dp[1][n]\n但这样空间要开到 5000 * 5000 ，交上去后直接 MLE 了\n观察到转移方程，发现可以空间优化，第一维只需开长度为2便可，然后滚动数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 5e3 + 5; char s[N]; int dp[2][N]; int main() { int n; while (scanf(\u0026#34;%d\\n%s\u0026#34;, \u0026amp;n, s + 1) != -1) { int now = 0, pre = 1; for (int i = n; i \u0026gt;= 1; --i) { dp[now][i] = 1; for (int j = i + 1; j \u0026lt;= n; ++j) { dp[now][j] = max(dp[pre][j], dp[now][j - 1]); if (s[i] == s[j]) dp[now][j] = max(dp[now][j], dp[pre][j - 1] + 2); } swap(now, pre); } printf(\u0026#34;%d\\n\u0026#34;, n - dp[pre][n]); } return 0; } ","date":"2021-08-04T11:17:06+08:00","permalink":"https://example.com/2021/poj-1159-palindrome/","title":"POJ 1159 Palindrome"},{"content":" 题意：给你一个数组，有区间修改和区间查询gcd 显然，这题是没法直接区间修改的 需要用到一个在数论中常见的gcd结论：$gcd(a_1, a_2, a_3, \\dots a_n) = gcd(a_1, a_2 - a_1, a_3 - a_2\\dots a_n - a_{n- 1})$ 观察上面的式子后发现：本来的a序列变成了他的差分序列，由差分序列的性质可知，若原序列区间加减，只需要在差分序列中区间两端加减便可。例如，我要在原序列中 [l, r] 区间中每一个数都加一个 d ，则只需要在差分序列中下标为 l 的数值加 d ，下标为 r + 1 的数值减 d 即可 固，我们只需要将原序列的差分序列建立一个线段树即可 这要做还不能完全解决这道题，利用差分序列使我们更好地操作，但不要忘了，我们还有查询 这里的查询是不能直接利用线段树的区间查询的，观察上面的式子，差分序列第一个数并没有变，所以我们要保留每一个数的上一个数是多少（注意题中区间修改操作会改变这个值），在区间 [l, r] 查询前，我们只需要将 l 下标的数组减去 l - 1 的数值再做区间查询即可 具体看代码（这里线段树保存了两个值，一个是区间的gcd，一个是原序列的值val，考虑到不用求和，因为求和可能会爆longlong，固用非叶子结点的val来当做lazy值。所以本线段树中树的建立、区间查询、单点修改都是针对gcd的，而区间修改、单点查询都是针对原序列val值的） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define dprint(x) printf(#x\u0026#34; = %lld\\n\u0026#34;, (ll)x) #define dcout(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl #define bug puts(\u0026#34;bug\u0026#34;) #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() #define ls (node \u0026lt;\u0026lt; 1) #define rs ((node \u0026lt;\u0026lt; 1) | 1) #define lb(x) ((x) \u0026amp; (-x)) using namespace std; /*++++++++++++++++++++++++++++++快读与快输++++++++++++++++++++++++++++++*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026amp;\u0026amp; c != -1; c = getchar()) { if (c == \u0026#39;-\u0026#39;) f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c ^ \u0026#39;0\u0026#39;); } return f ? -x : x; } void getstr(string \u0026amp;s) { int c = getchar(); while (c \u0026lt; 33 \u0026amp;\u0026amp; c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u0026gt; 32; c = getchar()) s.pb(c); } void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } void print(const string\u0026amp; s) { for (char c : s) putchar(c); } template \u0026lt;typename T\u0026gt; void print(T x, char c) { print(x); putchar(c); } /*-----------------------------快读与快输-----------------------------*/ /*++++++++++++++++++++++++++++++不可修改区++++++++++++++++++++++++++++++*/ // gcd template \u0026lt;typename T\u0026gt; T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u0026gt;\u0026gt;= 1, a = a * a % p) if (b \u0026amp; 1) res = res * a % p; return res; } // 数组读入 template \u0026lt;typename T\u0026gt; inline void fill_w(T *a, int cnt) { for (int i = 0; i \u0026lt; cnt; ++i) a[i] = IO();} /*------------------------------不可修改区------------------------------*/ /*++++++++++++++++++++++++++++++可修改区++++++++++++++++++++++++++++++*/ // 自定义结构体 struct pii { int x, y; bool operator\u0026lt; (const pii\u0026amp; j) { return x != j.x ? x \u0026lt; j.x : y \u0026lt; j.y; } }; /*------------------------------可修改区------------------------------*/ /*++++++++++++++++++++++++++++++全局变量区++++++++++++++++++++++++++++++*/ const int mod = 1e9 + 7; const int inf = (1LL \u0026lt;\u0026lt; 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 5e5 + 10, M = 1e6 + 10; ll a[N], b[N], lazy[N \u0026lt;\u0026lt; 2], val[N \u0026lt;\u0026lt; 2], seg[N \u0026lt;\u0026lt; 2]; /*------------------------------全局变量区------------------------------*/ /*++++++++++++++++++++++++++++++模板代码区++++++++++++++++++++++++++++++*/ void build(int l, int r, int node = 1) { if (l == r) { seg[node] = b[l], val[node] = a[l]; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, ls), build(mid + 1, r, rs); seg[node] = gcd(abs(seg[ls]), abs(seg[rs])); } void modify_point(int indx, ll v, int l, int r, int node = 1) { if (l == r) { seg[node] += v; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (indx \u0026lt;= mid) modify_point(indx, v, l, mid, ls); else modify_point(indx, v, mid + 1, r, rs); seg[node] = gcd(abs(seg[ls]), abs(seg[rs])); } void push_down(int node) { if (val[node] == 0) return; val[ls] += val[node], val[rs] += val[node]; val[node] = 0; } void modify_range(int ql, int qr, ll v, int l, int r, int node = 1) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) { val[node] += v; return; } push_down(node); int mid = (l + r) \u0026gt;\u0026gt; 1; if (ql \u0026lt;= mid) modify_range(ql, qr, v, l, mid, ls); if (qr \u0026gt; mid) modify_range(ql, qr, v, mid + 1, r, rs); } ll get_point(int indx, int l, int r, int node = 1) { if (l == r) return val[node]; push_down(node); int mid = (l + r) \u0026gt;\u0026gt; 1; if (indx \u0026lt;= mid) return get_point(indx, l, mid, ls); else return get_point(indx, mid + 1, r, rs); } ll get_range(int ql, int qr, int l, int r, int node = 1) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return abs(seg[node]); int mid = (l + r) \u0026gt;\u0026gt; 1; ll res = 0; if (ql \u0026lt;= mid) res = get_range(ql, qr, l, mid, ls); if (qr \u0026gt; mid) res = gcd(res, get_range(ql, qr, mid + 1, r, rs)); return res; } /*------------------------------模板代码区------------------------------*/ /*++++++++++++++++++++++++++++++函数代码区++++++++++++++++++++++++++++++*/ /*------------------------------函数代码区------------------------------*/ /*++++++++++++++++++++++++++++++主代码区++++++++++++++++++++++++++++++*/ void problem() { int n = IO(), m = IO(); for (int i = 1; i \u0026lt;= n; ++i) a[i] = IO(); for (int i = n; i; --i) b[i] = a[i] - a[i - 1]; build(1, n, 1); string s; while (m--) { getstr(s); int l = IO(), r = IO(); if (s[0] == \u0026#39;Q\u0026#39;) { ll x = 0; if (l \u0026gt; 1) x = get_point(l - 1, 1, n); if (x) modify_point(l, x, 1, n); print(get_range(l, r, 1, n), \u0026#39;\\n\u0026#39;); if (x) modify_point(l, -x, 1, n); } else { ll d = IO(); modify_range(l, r, d, 1, n); modify_point(l, d, 1, n); if (r \u0026lt; n) modify_point(r + 1, -d, 1, n); } } } /*------------------------------主代码区------------------------------*/ int main() { int t = 1; // // t = IO(); while (t--) problem(); // // while (1) problem(); return 0; } ","date":"2021-08-03T23:29:19+08:00","permalink":"https://example.com/2021/acwing-246-%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/","title":"AcWing 246 区间最大公约数"},{"content":" 给你一个排列的数组，操作m次，要不就是将 [l, r] 区间升序，要不就是降序，最后问某个下标的值是多少 一道思维题，可以这么做，二分一个答案 x，多开一个数组 b ，将原数组比 x 小的位置在数组 b 中设置为0，大于等于 x 的位置在数组 b 中设置为1，然后针对题意中的操作，对数组 b 进行区间查询和区间修改操作，即如果升序，则将该区间前面修改为0，后面修改为1，降序同理，最后查看题中问的下标是1还是0 感觉此思路还是挺明朗的，剩下的就是套个常规的线段树板子改改就好了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define dprint(x) printf(#x\u0026#34; = %lld\\n\u0026#34;, (ll)x) #define dcout(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl #define bug puts(\u0026#34;bug\u0026#34;) #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() #define ls (node \u0026lt;\u0026lt; 1) #define rs ((node \u0026lt;\u0026lt; 1) | 1) using namespace std; /*++++++++++++++++++++++++++++++快读与快输++++++++++++++++++++++++++++++*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026amp;\u0026amp; c != -1; c = getchar()) { if (c == \u0026#39;-\u0026#39;) f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c ^ \u0026#39;0\u0026#39;); } return f ? -x : x; } void getstr(string \u0026amp;s) { int c = getchar(); while (c \u0026lt; 33 \u0026amp;\u0026amp; c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u0026gt; 32; c = getchar()) s.pb(c); } void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } void print(const string\u0026amp; s) { for (char c : s) putchar(c); } template \u0026lt;typename T\u0026gt; void print(T x, char c) { print(x); putchar(c); } /*-----------------------------快读与快输-----------------------------*/ /*++++++++++++++++++++++++++++++不可修改区++++++++++++++++++++++++++++++*/ // gcd template \u0026lt;typename T\u0026gt; T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u0026gt;\u0026gt;= 1, a = a * a % p) if (b \u0026amp; 1) res = res * a % p; return res; } // 数组读入 template \u0026lt;typename T\u0026gt; inline void fill_w(T *a, int cnt) { for (int i = 0; i \u0026lt; cnt; ++i) a[i] = IO();} /*------------------------------不可修改区------------------------------*/ /*++++++++++++++++++++++++++++++可修改区++++++++++++++++++++++++++++++*/ /*↓可修改区*/ // 自定义结构体 struct pii { int q, l, r; // bool operator\u0026lt; (const pii\u0026amp; j) { // return x != j.x ? x \u0026lt; j.x : y \u0026lt; j.y; // } }; /*------------------------------可修改区------------------------------*/ /*++++++++++++++++++++++++++++++全局变量区++++++++++++++++++++++++++++++*/ const int mod = 1e9 + 7; const int inf = (1LL \u0026lt;\u0026lt; 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e5 + 10, M = 1e6 + 10; int a[N], b[N], seg[N \u0026lt;\u0026lt; 2], lazy[N \u0026lt;\u0026lt; 2], vis[N \u0026lt;\u0026lt; 2]; pii ask[N]; /*------------------------------全局变量区------------------------------*/ /*++++++++++++++++++++++++++++++模板代码区++++++++++++++++++++++++++++++*/ int op(int a, int b) { return a + b; } // 题意不同，函数内部不同 void push_down(int l, int r, int node) { if (!vis[node]) return; // 这里如果0也有意义的话多开一个数组标记 int mid = (l + r) \u0026gt;\u0026gt; 1; lazy[ls] = lazy[node], lazy[rs] = lazy[node]; seg[ls] = (mid - l + 1) * lazy[node]; seg[rs] = (r - mid) * lazy[node]; vis[ls] = vis[rs] = 1, vis[node] = 0; } // 初始化 void build(int l, int r, int node) { if (l == r) { seg[node] = b[l], vis[node] = 0; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, ls), build(mid + 1, r, rs); seg[node] = op(seg[ls], seg[rs]), vis[node] = 0; } // 区间修改 void update(int ql, int qr, int v, int l, int r, int node) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) { // 题意不同，这里更新操作不同 lazy[node] = v, vis[node] = 1; seg[node] = (r - l + 1) * v; return; } push_down(l, r, node); int mid = (l + r) \u0026gt;\u0026gt; 1; if (ql \u0026lt;= mid) update(ql, qr, v, l, mid, ls); if (qr \u0026gt; mid) update(ql, qr, v, mid + 1, r, rs); seg[node] = op(seg[ls], seg[rs]); } // 区间查找 int get(int ql, int qr, int l, int r, int node) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return seg[node]; push_down(l, r, node); // 保证单点的情况下这句话可以注释掉 int mid = (l + r) \u0026gt;\u0026gt; 1; int ret = 0; // 题意不同，初始化不同 if (ql \u0026lt;= mid) ret = get(ql, qr, l, mid, ls); if (qr \u0026gt; mid) ret = op(get(ql, qr, mid + 1, r, rs), ret); return ret; } /*------------------------------模板代码区------------------------------*/ /*++++++++++++++++++++++++++++++函数代码区++++++++++++++++++++++++++++++*/ void check(int n, int m, int x) { for (int i = 1; i \u0026lt;= n; ++i) b[i] = (a[i] \u0026gt;= x); build(1, n, 1); for (int i = 0; i \u0026lt; m; ++i) { int q = ask[i].q, l = ask[i].l, r = ask[i].r, len = r - l + 1; int tot = get(l, r, 1, n, 1); if (tot == 0 || tot == len) continue; if (!q) { update(l, r - tot, 0, 1, n, 1); // [l, r - tot] = 0 update(r - tot + 1, r, 1, 1, n, 1); // [r - tot + 1, r] = 1 } else { update(l, l + tot - 1, 1, 1, n, 1); // [l, l + tot - 1] = 1 update(l + tot, r, 0, 1, n, 1); // [l + tot, r] = 0 } } } /*------------------------------函数代码区------------------------------*/ /*++++++++++++++++++++++++++++++主代码区++++++++++++++++++++++++++++++*/ void problem() { int n = IO(), m = IO(); fill_w(a + 1, n); for (int i = 0; i \u0026lt; m; ++i) { ask[i].q = IO(), ask[i].l = IO(), ask[i].r = IO(); } int k = IO(), l = 1, r = n, ans = -1; while (l \u0026lt;= r) { int mid = (l + r) \u0026gt;\u0026gt; 1; check(n, m, mid); if (get(k, k, 1, n, 1)) ans = mid, l = mid + 1; else r = mid - 1; } print(ans, \u0026#39;\\n\u0026#39;); } /*------------------------------主代码区------------------------------*/ int main() { int t = 1; t = IO(); while (t--) problem(); // while (1) problem(); return 0; } ","date":"2021-08-03T20:38:47+08:00","permalink":"https://example.com/2021/hdu-5649-dzy-loves-sorting/","title":"HDU 5649 DZY Loves Sorting"},{"content":" 题意：给你一个数组，问你数组的中开始位置为 [x1, y1]， 结束位置为 [x2, y2] 的最大字段和 $x_1 \\le y1, x2 \\le y2, x1 \\le x2, y1 \\le y2$\n由题意可知区间只有两种情况\n不相交 相交 对于不相交，就是直接求 [x1, y1] 区间中右端点（右端点必选）往左的最大字段和，加上 [x2, y2] 区间左端点（左端点必选）往右的最大字段和，再加上中间必选的区间 [y1 + 1, x2 - 1] 的和\n而相交可以转化为以下几个不相交的区间\n开始位置为 [x1, x2] ， 结束位置为 [x2 + 1, y2] 开始位置为 [x1, x2 - 1] ， 结束位置为 [x2, y2] 开始位置为 [x1, y1] ， 结束位置为 [y1 + 1, y2] 开始位置为 [x1, y1 - 1] ， 结束位置为 [y1, y2] 当然不要忘记了还有开始位置和结束位置都在 [x2, y1] 的情况\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define debug(x) printf(#x\u0026#34; = %lld\\n\u0026#34;, (ll)x) #define bug puts(\u0026#34;bug\u0026#34;) #define umap unordered_map #define uset unordered_set #define ls (node \u0026lt;\u0026lt; 1) #define rs ((node \u0026lt;\u0026lt; 1) | 1) #define vi vector #define all(x) x.begin(), x.end() using namespace std; inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026amp;\u0026amp; c != -1; c = getchar()) { if (c == \u0026#39;-\u0026#39;) f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c ^ \u0026#39;0\u0026#39;); } return f ? -x : x; } void getstr(string \u0026amp;s) { int c = getchar(); while (c \u0026lt; 33 \u0026amp;\u0026amp; c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u0026gt; 32; c = getchar()) s.pb(c); } void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } void print(const string\u0026amp; s) { for (char c : s) putchar(c); } template \u0026lt;typename T\u0026gt; void print(T x, char c) { print(x); putchar(c); } template \u0026lt;typename T\u0026gt; T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u0026gt;\u0026gt;= 1, a = a * a % p) if (b \u0026amp; 1) res = res * a % p; return res; } // 数组读入 template \u0026lt;typename T\u0026gt; inline void fill_w(T *a, int cnt) { for (int i = 0; i \u0026lt; cnt; ++i) a[i] = IO();} struct pii { // int x, y; int l, r, maxv, sum; pii() : l(-1e7), r(-1e7), maxv(-1e7), sum(-1e7) {} pii(int x) : l(x), r(x), maxv(x), sum(x) {} }; const int mod = 1e9 + 7; const int inf = (1LL \u0026lt;\u0026lt; 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e5 + 10, M = 1e6 + 10; int a[N], sum[N]; pii seg[N \u0026lt;\u0026lt; 2]; void push_up(int node) { seg[node].maxv = max({seg[ls].maxv, seg[rs].maxv,seg[ls].r + seg[rs].l}); seg[node].sum = seg[ls].sum + seg[rs].sum; seg[node].l = max(seg[ls].l, seg[ls].sum + seg[rs].l); seg[node].r = max(seg[rs].r, seg[rs].sum + seg[ls].r); } void build(int l, int r, int node = 1) { if (l == r) { seg[node] = pii(a[l]); return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, ls), build(mid + 1, r, rs); push_up(node); } pii get(int ql, int qr, int l, int r, int node = 1) { if (ql \u0026gt; qr) return pii(); if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return seg[node]; int mid = (l + r) \u0026gt;\u0026gt; 1; if (ql \u0026gt; mid) return get(ql, qr, mid + 1, r, rs); if (qr \u0026lt;= mid) return get(ql, qr, l, mid, ls); pii p1 = get(ql, qr, l, mid, ls); pii p2 = get(ql, qr, mid + 1, r, rs); pii res; res.maxv = max({p1.maxv, p2.maxv, p1.r + p2.l}); res.sum = p1.sum + p2.sum; res.l = max(p1.l, p1.sum + p2.l); res.r = max(p2.r, p2.sum + p1.r); return res; } int get_sum(int l, int r) { if (l \u0026gt; r) return 0; return sum[r] - sum[l - 1]; } void problem() { int n = IO(); fill_w(a + 1, n); for (int i = 1; i \u0026lt;= n; ++i) sum[i] = sum[i - 1] + a[i]; build(1, n); int m = IO(); while (m--) { int x1 = IO(), y1 = IO(), x2 = IO(), y2 = IO(), res; if (y1 \u0026lt; x2) { res = get(x1, y1, 1, n).r + get(x2, y2, 1, n).l; res += get_sum(y1 + 1, x2 - 1); } else { res = get(x1, x2, 1, n).r + get(x2 + 1, y2, 1, n).l; res = max(res, get(x1, x2 - 1, 1, n).r + get(x2, y2, 1, n).l); res = max(res, get(x1, y1 - 1, 1, n).r + get(y1, y2, 1, n).l); res = max(res, get(x1, y1, 1, n).r + get(y1 + 1, y2, 1, n).l); res = max(res, get(x2, y1, 1, n).maxv); } print(res, \u0026#39;\\n\u0026#39;); } } int main() { int t = 1; t = IO(); while (t--) problem(); // while (1) problem(); return 0; } ","date":"2021-08-03T18:42:24+08:00","permalink":"https://example.com/2021/spoj-gss5-can-you-answer-these-queries-v/","title":"SPOJ GSS5 Can you answer these queries V"},{"content":" 题意：给你一个数组，每次操作将x下标位的数改成y，每次询问区间 [x, y] 之间的最大子段和 一个另类的线段树维护区间信息的题（听说如果只有查询，可以直接用猫树来做） 线段树结点维护4个值： maxv ：记录当前结点区间的最大字段和 sum：记录当前结点区间的和 l ：记录当前结点区间中，从左端点开始（即左端点必选）的最大字段和 r：记录当前结点区间中，从右端点开始的最大字段和 至于更新值的话就是 maxv ：要不就是左孩子的 maxv ，要不就是右孩子的 maxv， 又或者是左孩子的r 值加上 右孩子的 l值 sum：直接区间求和更新 l ：显然要不就是左孩子的 l 值或者是左孩子的 sum 值 加上右孩子的 l 值 r：要不就是右孩子的 r 值或者是右孩子的 sum 值 加上左孩子的 r 值 直接看代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define debug(x) printf(#x\u0026#34; = %lld\\n\u0026#34;, (ll)x) #define bug puts(\u0026#34;bug\u0026#34;) #define umap unordered_map #define uset unordered_set #define ls (node \u0026lt;\u0026lt; 1) #define rs ((node \u0026lt;\u0026lt; 1) | 1) #define vi vector #define all(x) x.begin(), x.end() using namespace std; inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026amp;\u0026amp; c != -1; c = getchar()) { if (c == \u0026#39;-\u0026#39;) f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c ^ \u0026#39;0\u0026#39;); } return f ? -x : x; } void getstr(string \u0026amp;s) { int c = getchar(); while (c \u0026lt; 33 \u0026amp;\u0026amp; c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u0026gt; 32; c = getchar()) s.pb(c); } void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } void print(const string\u0026amp; s) { for (char c : s) putchar(c); } template \u0026lt;typename T\u0026gt; void print(T x, char c) { print(x); putchar(c); } template \u0026lt;typename T\u0026gt; T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u0026gt;\u0026gt;= 1, a = a * a % p) if (b \u0026amp; 1) res = res * a % p; return res; } // 数组读入 template \u0026lt;typename T\u0026gt; inline void fill_w(T *a, int cnt) { for (int i = 0; i \u0026lt; cnt; ++i) a[i] = IO();} struct pii { // int x, y; int l, r, maxv, sum; pii() : l(-1e7), r(-1e7), maxv(-1e7), sum(-1e7) {} pii(int x) : l(x), r(x), maxv(x), sum(x) {} }; const int mod = 1e9 + 7; const int inf = (1LL \u0026lt;\u0026lt; 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e5 + 10, M = 1e6 + 10; int a[N]; pii seg[N \u0026lt;\u0026lt; 2]; void push_up(int node) { seg[node].maxv = max({seg[ls].maxv, seg[rs].maxv,seg[ls].r + seg[rs].l}); seg[node].sum = seg[ls].sum + seg[rs].sum; seg[node].l = max(seg[ls].l, seg[ls].sum + seg[rs].l); seg[node].r = max(seg[rs].r, seg[rs].sum + seg[ls].r); } void build(int l, int r, int node = 1) { if (l == r) { seg[node] = pii(a[l]); return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, ls), build(mid + 1, r, rs); push_up(node); } void modify(int indx, int val, int l, int r, int node = 1) { if (l == r) { seg[node] = pii(val); return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (indx \u0026lt;= mid) modify(indx, val, l, mid, ls); else modify(indx, val, mid + 1, r, rs); push_up(node); } pii get(int ql, int qr, int l, int r, int node = 1) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return seg[node]; int mid = (l + r) \u0026gt;\u0026gt; 1; if (ql \u0026gt; mid) return get(ql, qr, mid + 1, r, rs); if (qr \u0026lt;= mid) return get(ql, qr, l, mid, ls); pii p1 = get(ql, qr, l, mid, ls); pii p2 = get(ql, qr, mid + 1, r, rs); pii res; res.maxv = max({p1.maxv, p2.maxv, p1.r + p2.l}); res.sum = p1.sum + p2.sum; res.l = max(p1.l, p1.sum + p2.l); res.r = max(p2.r, p2.sum + p1.r); return res; } void problem() { int n = IO(); fill_w(a + 1, n); build(1, n); int m = IO(); while (m--) { int q = IO(), x = IO(), y = IO(); if (q == 1) print(get(x, y, 1, n).maxv, \u0026#39;\\n\u0026#39;); else modify(x, y, 1, n); } } int main() { // int t = 1; // t = IO(); // while (t--) problem(); while (1) problem(); return 0; } ","date":"2021-08-03T17:01:02+08:00","permalink":"https://example.com/2021/spoj-gss3-can-you-answer-these-queries-iii/","title":"SPOJ GSS3 Can you answer these queries III"},{"content":" 给你一个区间的数，每次询问时询问第x和第y（包括）个数之间的数的和，每次操作是将第x和第y（包括）个数之间的数都开方 直接暴力修改就好了，每个数最多不会被开方超过6次，直接暴力当成单点修改便可，当然如果这个数已经是1了，就没必要开方了，固如果一个区间上的和恰好为其区间的长度，则这个区间的数是不用开方的了 直接线段树暴力 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define debug(x) printf(#x\u0026#34; = %lld\\n\u0026#34;, (ll)x) #define bug puts(\u0026#34;bug\u0026#34;) #define umap unordered_map #define uset unordered_set #define ls (node \u0026lt;\u0026lt; 1) #define rs ((node \u0026lt;\u0026lt; 1) | 1) #define vi vector #define all(x) x.begin(), x.end() using namespace std; /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-快读与快输-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026amp;\u0026amp; c != -1; c = getchar()) { if (c == \u0026#39;-\u0026#39;) f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c ^ \u0026#39;0\u0026#39;); } return f ? -x : x; } void getstr(string \u0026amp;s) { int c = getchar(); while (c \u0026lt; 33 \u0026amp;\u0026amp; c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u0026gt; 32; c = getchar()) s.pb(c); } void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } // void print(const string\u0026amp; s) { for (char c : s) putchar(c); } template \u0026lt;typename T\u0026gt; void print(T x, char c) { print(x); putchar(c); } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-快读与快输-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-不可修改区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ // gcd template \u0026lt;typename T\u0026gt; T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u0026gt;\u0026gt;= 1, a = a * a % p) if (b \u0026amp; 1) res = res * a % p; return res; } // 数组读入 template \u0026lt;typename T\u0026gt; inline void fill_w(T *a, int cnt) { for (int i = 0; i \u0026lt; cnt; ++i) a[i] = IO();} /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-不可修改区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-可修改区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ /*↓可修改区*/ // 自定义结构体 struct pii { int x, y; bool operator\u0026lt; (const pii\u0026amp; j) { return x != j.x ? x \u0026lt; j.x : y \u0026lt; j.y; } }; /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-可修改区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-全局变量区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ const int mod = 1e9 + 7; const int inf = (1LL \u0026lt;\u0026lt; 31) - 1; const ll INF = 1e18; // const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e5 + 10, M = 1e6 + 10; ll arr[N], seg[N \u0026lt;\u0026lt; 2]; int kase, flag; /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-全局变量区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-模板代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ ll op(ll a, ll b) { return a + b; } void build(int l, int r, int node = 1) { if (l == r) { seg[node] = arr[l]; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, ls), build(mid + 1, r, rs); seg[node] = op(seg[ls], seg[rs]); } // 区间修改 void update(int ql, int qr, int l, int r, int node = 1) { if (seg[node] == r - l + 1) return; if (l == r) { seg[node] = (ll)sqrt(seg[node]); return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (ql \u0026lt;= mid) update(ql, qr, l, mid, ls); if (qr \u0026gt; mid) update(ql, qr, mid + 1, r, rs); seg[node] = op(seg[ls], seg[rs]); } // 区间查找 ll get(int ql, int qr, int l, int r, int node = 1) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return seg[node]; // push_down(l, r, node); // 保证单点的情况下这句话可以注释掉 int mid = (l + r) \u0026gt;\u0026gt; 1; ll ret = 0; // 题意不同，初始化不同 if (ql \u0026lt;= mid) ret = get(ql, qr, l, mid, ls); if (qr \u0026gt; mid) ret = op(get(ql, qr, mid + 1, r, rs), ret); return ret; } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-模板代码区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-函数代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-函数代码区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-主代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ void problem() { int n = IO(); fill_w(arr + 1, n); if (flag) puts(\u0026#34;\u0026#34;); else flag = 1; printf(\u0026#34;Case #%d:\\n\u0026#34;, ++kase); build(1, n); int m = IO(); while (m--) { int q = IO(), l = IO(), r = IO(); if (l \u0026gt; r) swap(l, r); if (q == 0) update(l, r, 1, n); else print(get(l, r, 1, n), \u0026#39;\\n\u0026#39;); } } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-主代码区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ int main() { while (1) problem(); return 0; } ","date":"2021-07-30T19:29:02+08:00","permalink":"https://example.com/2021/spoj-gss4-can-you-answer-these-queries-iv/","title":"SPOJ GSS4 Can you answer these queries IV"},{"content":" 给你一个长度为L的纸，初始化纸的颜色为1，每次回选取一端区间将其用x颜色覆盖，每次询问一端区间中有多少不同的颜色 观察到颜色的数量不多，可以用每个数的二进制位来记录当前有哪些颜色，更新结点直接用或运算便可，然后就是非常普通的线段树的区间修改与查询，直接套板子改改交上去1A了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;string\u0026gt; #define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define debug(x) printf(#x\u0026#34; = %lld\\n\u0026#34;, (ll)x) #define bug puts(\u0026#34;bug\u0026#34;) #define umap unordered_map #define uset unordered_set #define ls (node \u0026lt;\u0026lt; 1) #define rs ((node \u0026lt;\u0026lt; 1) | 1) #define vi vector #define all(x) x.begin(), x.end() using namespace std; /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-快读与快输-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026amp;\u0026amp; c != -1; c = getchar()) { if (c == \u0026#39;-\u0026#39;) f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c ^ \u0026#39;0\u0026#39;); } return f ? -x : x; } void getstr(string \u0026amp;s) { int c = getchar(); while (c \u0026lt; 33 \u0026amp;\u0026amp; c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u0026gt; 32; c = getchar()) s.pb(c); } void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } // void print(const string\u0026amp; s) { for (char c : s) putchar(c); } template \u0026lt;typename T\u0026gt; void print(T x, char c) { print(x); putchar(c); } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-快读与快输-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-不可修改区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ // gcd template \u0026lt;typename T\u0026gt; T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u0026gt;\u0026gt;= 1, a = a * a % p) if (b \u0026amp; 1) res = res * a % p; return res; } // 数组读入 template \u0026lt;typename T\u0026gt; inline void fill_w(T *a, int cnt) { for (int i = 0; i \u0026lt; cnt; ++i) a[i] = IO();} /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-不可修改区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-可修改区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ /*↓可修改区*/ // 自定义结构体 struct pii { int x, y; // int node, l, r; bool operator\u0026lt; (const pii\u0026amp; j) { return x != j.x ? x \u0026lt; j.x : y \u0026lt; j.y; } }; /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-可修改区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-全局变量区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ const int mod = 1e9 + 7; const int inf = (1LL \u0026lt;\u0026lt; 31) - 1; const ll INF = 1e18; // const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e5 + 10, M = 1e6 + 10; int tim, seg[N \u0026lt;\u0026lt; 2], lazy[N \u0026lt;\u0026lt; 2]; /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-全局变量区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-模板代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ int op(int a, int b) { return a | b; } void push_down(int l, int r, int node) { if (!lazy[node]) return; // 这里如果0也有意义的话多开一个数组标记 lazy[ls] = lazy[node], lazy[rs] = lazy[node]; seg[ls] = lazy[node]; seg[rs] = lazy[node]; lazy[node] = 0; } void build(int l, int r, int node = 1) { if (l == r) { seg[node] = 2; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, ls), build(mid + 1, r, rs); seg[node] = op(seg[ls], seg[rs]); } // 区间修改 void update(int ql, int qr, int v, int l, int r, int node = 1) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) { // 题意不同，这里更新操作不同 lazy[node] = 1 \u0026lt;\u0026lt; v; seg[node] = 1 \u0026lt;\u0026lt; v; return; } push_down(l, r, node); int mid = (l + r) \u0026gt;\u0026gt; 1; if (ql \u0026lt;= mid) update(ql, qr, v, l, mid, ls); if (qr \u0026gt; mid) update(ql, qr, v, mid + 1, r, rs); seg[node] = op(seg[ls], seg[rs]); } // 区间查找 int get(int ql, int qr, int l, int r, int node = 1) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return seg[node]; push_down(l, r, node); // 保证单点的情况下这句话可以注释掉 int mid = (l + r) \u0026gt;\u0026gt; 1; int ret = 0; // 题意不同，初始化不同 if (ql \u0026lt;= mid) ret = get(ql, qr, l, mid, ls); if (qr \u0026gt; mid) ret = op(get(ql, qr, mid + 1, r, rs), ret); return ret; } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-模板代码区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-函数代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ int cal(int x) { int ans = 0; while (x) { ans += 1; x \u0026amp;= (x - 1); } return ans; } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-函数代码区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-主代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ void problem() { int n = IO(), t = IO(), m = IO(); build(1, n); string q; while (m--) { getstr(q); int l = IO(), r = IO(); if (l \u0026gt; r) swap(l, r); if (q[0] == \u0026#39;C\u0026#39;) update(l, r, IO(), 1, n); else print(cal(get(l, r, 1, n)), \u0026#39;\\n\u0026#39;); } } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-主代码区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ int main() { // int t = 1; // t = IO(); // while (t--) problem(); while (1) problem(); return 0; } ","date":"2021-07-30T18:50:42+08:00","permalink":"https://example.com/2021/poj2777-count-color/","title":"POJ2777 Count Color"},{"content":" 题意：在一棵根为1的树上，每个节点初始化为1，每次指定某个结点上的数字如果一开始是1则变为0，反之变为1，并且每次询问以某个结点为根的子树上一共有多少个结点上的数字为1 这题用树链剖分就是一个板子题，但也可以用dfs序+线段树来写 具体做法就是用一个结构体记录每个节点dfs时时间戳的开始和结束，显然这个时间戳的区间便是以该结点为根的子树区间，然后就是线段树的区间查询和单点修改了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;string\u0026gt; #define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define debug(x) printf(#x\u0026#34; = %lld\\n\u0026#34;, (ll)x) #define bug puts(\u0026#34;bug\u0026#34;) #define umap unordered_map #define uset unordered_set #define ls (node \u0026lt;\u0026lt; 1) #define rs ((node \u0026lt;\u0026lt; 1) | 1) #define vi vector #define all(x) x.begin(), x.end() using namespace std; /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-快读与快输-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026amp;\u0026amp; c != -1; c = getchar()) { if (c == \u0026#39;-\u0026#39;) f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c ^ \u0026#39;0\u0026#39;); } return f ? -x : x; } void getstr(string \u0026amp;s) { int c = getchar(); while (c \u0026lt; 33 \u0026amp;\u0026amp; c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u0026gt; 32; c = getchar()) s.pb(c); } void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } // void print(const string\u0026amp; s) { for (char c : s) putchar(c); } template \u0026lt;typename T\u0026gt; void print(T x, char c) { print(x); putchar(c); } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-快读与快输-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-不可修改区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ // gcd template \u0026lt;typename T\u0026gt; T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u0026gt;\u0026gt;= 1, a = a * a % p) if (b \u0026amp; 1) res = res * a % p; return res; } // 数组读入 template \u0026lt;typename T\u0026gt; inline void fill_w(T *a, int cnt) { for (int i = 0; i \u0026lt; cnt; ++i) a[i] = IO();} /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-不可修改区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-可修改区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ /*↓可修改区*/ // 自定义结构体 struct pii { int x, y; // int node, l, r; bool operator\u0026lt; (const pii\u0026amp; j) { return x != j.x ? x \u0026lt; j.x : y \u0026lt; j.y; } }; /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-可修改区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-全局变量区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ const int mod = 1e9 + 7; const int inf = (1LL \u0026lt;\u0026lt; 31) - 1; const ll INF = 1e18; // const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e5 + 10, M = 1e6 + 10; int tim, seg[N \u0026lt;\u0026lt; 2]; pii p[N]; /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-全局变量区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-模板代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ int head[N], cnt; //初始化 void init(int n) { fill_n(head, n + 5, -1); cnt = -1; tim = 0; } struct edges { int to, next; void add(int t, int n) { to = t, next = n; } }edge[N \u0026lt;\u0026lt; 1]; //无向图则需要乘2 inline void add(int u, int v) { edge[++cnt].add(v, head[u]); head[u] = cnt; } int op(int a, int b) { return a + b; } void build(int l, int r, int node = 1) { if (l == r) { seg[node] = 1; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, ls), build(mid + 1, r, rs); seg[node] = op(seg[ls], seg[rs]); } // 单点修改 void update(int indx, int l, int r, int node = 1) { if (l == r) { // 题意不同，这里更新操作不同 seg[node] ^= 1; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (indx \u0026lt;= mid) update(indx, l, mid, ls); else update(indx, mid + 1, r, rs); seg[node] = op(seg[ls], seg[rs]); } // 区间查找 int get(int ql, int qr, int l, int r, int node = 1) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return seg[node]; // push_down(l, r, node); // 保证单点的情况下这句话可以注释掉 int mid = (l + r) \u0026gt;\u0026gt; 1; int ret = 0; // 题意不同，初始化不同 if (ql \u0026lt;= mid) ret = get(ql, qr, l, mid, ls); if (qr \u0026gt; mid) ret = op(get(ql, qr, mid + 1, r, rs), ret); return ret; } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-模板代码区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-函数代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ void dfs(int u, int fa) { p[u].x = ++tim; rep(u, i, edge) { int v = edge[i].to; if (v == fa) continue; dfs(v, u); } p[u].y = tim; } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-函数代码区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-主代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ void problem() { int n = IO(); init(n); for (int i = 1; i \u0026lt; n; ++i) { int u = IO(), v = IO(); add(u, v), add(v, u); } dfs(1, -1); build(1, n); int m = IO(); string q; while (m--) { getstr(q); int u = IO(); if (q[0] == \u0026#39;Q\u0026#39;) print(get(p[u].x, p[u].y, 1, n), \u0026#39;\\n\u0026#39;); else update(p[u].x, 1, n); } } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-主代码区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ int main() { // int t = 1; // t = IO(); // while (t--) problem(); while (1) problem(); return 0; } ","date":"2021-07-30T17:45:26+08:00","permalink":"https://example.com/2021/poj3321-apple-tree/","title":"POJ3321 Apple Tree"},{"content":" 题意：建图，1表示u、v之间连一条有向边权值为w，2表示u向[l, r]区间内所有点连一条权值为w的有向边，3表示[l, r]区间内的所有点向u连一条权值为w的有向边\n直接线段树优化建图便可，具体做法就是建一个根结点连向子结点的出树，再建一个子结点连向根结点的入树，相连的是每个节点的内存池编号。\n每个结点表示一个区间，若是点与区间相连，直接树上查询区间，使点向相应区间的编号建边，反之编号向点建边\n最后直接在这两个树构成的图上跑最短路便可\n值得扩展的是，如果是区间与区间相连权值为w，直接新编一个点，先使前区间与该点相连，权值为w，再使该点与后区间相连权值为0\n本题只有点与点连，点与区间连\n直接看代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define debug(x) printf(#x\u0026#34; = %lld\\n\u0026#34;, (ll)x) #define bug puts(\u0026#34;bug\u0026#34;) #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() #define ls (node \u0026lt;\u0026lt; 1) #define rs ((node \u0026lt;\u0026lt; 1) | 1) using namespace std; /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-快读与快输-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026amp;\u0026amp; c != -1; c = getchar()) { if (c == \u0026#39;-\u0026#39;) f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c ^ \u0026#39;0\u0026#39;); } return f ? -x : x; } void getstr(string \u0026amp;s) { s.clear(); int c = getchar(); while (c \u0026lt; 33 \u0026amp;\u0026amp; c != -1) c = getchar(); if (c == -1) exit(0); for(;c \u0026gt; 32; c = getchar()) s.pb(c); } void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } void print(const string\u0026amp; s) { for (char c : s) putchar(c); } template \u0026lt;typename T\u0026gt; void print(T x, char c) { print(x); putchar(c); } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-快读与快输-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-不可修改区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ // gcd template \u0026lt;typename T\u0026gt; T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u0026gt;\u0026gt;= 1, a = a * a % p) if (b \u0026amp; 1) res = res * a % p; return res; } // 数组读入 template \u0026lt;typename T\u0026gt; inline void fill_w(T *a, int cnt) { for (int i = 0; i \u0026lt; cnt; ++i) a[i] = IO();} /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-不可修改区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-可修改区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ /*↓可修改区*/ // 自定义结构体 struct pii { int x, y; bool operator\u0026lt; (const pii\u0026amp; j) { return x != j.x ? x \u0026lt; j.x : y \u0026lt; j.y; } }; /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-可修改区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-全局变量区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ const int mod = 1e9 + 7; const int inf = (1LL \u0026lt;\u0026lt; 31) - 1; const ll INF = 1e17; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 2e5 + 1e3, M = 1e6 + 10; bool vis[N \u0026lt;\u0026lt; 4]; ll dis[N \u0026lt;\u0026lt; 4]; int head[N \u0026lt;\u0026lt; 4], cnt; int ram; // 内存池编号 /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-全局变量区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-模板代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ //初始化 void init(int n) { fill_n(head, n + 5, -1); cnt = -1; } struct edges { int to, next; ll w; void add(int t, int n, ll w) { to = t, next = n, this-\u0026gt;w = w; } }edge[N \u0026lt;\u0026lt; 4]; //无向图则需要乘2 inline void add(int u, int v, ll w) { edge[++cnt].add(v, head[u], w); head[u] = cnt; } struct qnode{ int v; ll w; qnode(int v = 0, ll w = 0) : v(v), w(w) {} bool operator\u0026lt; (const qnode \u0026amp;t) const { return w \u0026gt; t.w; } }; void dij(int n, int s) {//n 为顶点数， m 为边数 for (int i = 0; i \u0026lt;= n; ++i) dis[i] = INF, vis[i] = 0; dis[s] = 0; priority_queue\u0026lt;qnode\u0026gt; heap; heap.push(qnode(s, dis[s])); while (heap.size()) { int u = heap.top().v; heap.pop(); if (vis[u]) continue; vis[u] = true; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; ll w = edge[i].w; if (!vis[v] \u0026amp;\u0026amp; dis[u] + w \u0026lt; dis[v]) { //松弛 dis[v] = dis[u] + w; heap.push(qnode(v, dis[v])); } } } } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-模板代码区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-函数代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ struct nodes{ int l, r; }seg[N \u0026lt;\u0026lt; 4]; int build(int l, int r, int flag) { // flag 0 in, 1 out if (l == r) return l; int mid = (l + r) \u0026gt;\u0026gt; 1, now = ++ram; seg[now].l = build(l, mid, flag); seg[now].r = build(mid + 1, r, flag); if (flag) add(now, seg[now].l, 0), add(now, seg[now].r, 0); //out else add(seg[now].l, now, 0), add(seg[now].r, now, 0); // in return now; } // flag 0 u -\u0026gt; [ql, qr], 1 [ql, qr] -\u0026gt; u void modify(int u, ll w, int ql, int qr, int l, int r, int node, int flag) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) { // printf(\u0026#34;%d %d %d %lld %d %d\\n\u0026#34;, u, l, r, w, flag, node); flag ? add(node, u, w) : add(u, node, w); return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (ql \u0026lt;= mid) modify(u, w, ql, qr, l, mid, seg[node].l, flag); if (qr \u0026gt; mid) modify(u, w, ql, qr, mid + 1, r, seg[node].r, flag); } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-函数代码区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-主代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ void problem() { int n = IO(), m = IO(), s = IO(); ram = n; init((n \u0026lt;\u0026lt; 2) + 100); int rootin = build(1, n, 0), rootout = build(1, n, 1); while (m--) { int q = IO(), u = IO(), l, r, v; if (q == 1) { v = IO(); add(u, v, IO()); } else if (q == 2) { l = IO(), r = IO(); modify(u, IO(), l, r, 1, n, rootout, 0); } else { l = IO(), r = IO(); modify(u, IO(), l, r, 1, n, rootin, 1); } } dij(ram, s); for (int i = 1; i \u0026lt;= n; ++i) print(dis[i] \u0026lt; INF ? dis[i] : -1, \u0026#39; \u0026#39;); } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-主代码区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ int main() { // int t = 1; // t = IO(); // while (t--) problem(); while (1) problem(); return 0; } ","date":"2021-07-30T17:07:02+08:00","permalink":"https://example.com/2021/cf786b-legacy/","title":"Cf786B Legacy"},{"content":" 题意：一个长度为n的全为1的数组，每次将某点变为0，或者将上一次变为0的点变为1，又或者询问经过某点的最上连续1的序列的长度 为了使线段树能够做到区间合并后更新，显然要维护三个东西，分别是本区间中最长的连续1的长度 maxv ，本区间从左端开始最长的连续1的长度 l ，和本区间从右端点开始最长的连续1的长度 r 。 直接看代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define debug(x) printf(#x\u0026#34; = %lld\\n\u0026#34;, (ll)x) #define bug puts(\u0026#34;bug\u0026#34;) #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() #define ls (node \u0026lt;\u0026lt; 1) #define rs ((node \u0026lt;\u0026lt; 1) | 1) using namespace std; /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-快读与快输-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026amp;\u0026amp; c != -1; c = getchar()) { if (c == \u0026#39;-\u0026#39;) f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c ^ \u0026#39;0\u0026#39;); } return f ? -x : x; } void getstr(string \u0026amp;s) { s.clear(); int c = getchar(); while (c \u0026lt; 33 \u0026amp;\u0026amp; c != -1) c = getchar(); if (c == -1) exit(0); for(;c \u0026gt; 32; c = getchar()) s.pb(c); } void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } void print(const string\u0026amp; s) { for (char c : s) putchar(c); } template \u0026lt;typename T\u0026gt; void print(T x, char c) { print(x); putchar(c); } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-快读与快输-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-不可修改区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ // gcd template \u0026lt;typename T\u0026gt; T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u0026gt;\u0026gt;= 1, a = a * a % p) if (b \u0026amp; 1) res = res * a % p; return res; } // 数组读入 template \u0026lt;typename T\u0026gt; inline void fill_w(T *a, int cnt) { for (int i = 0; i \u0026lt; cnt; ++i) a[i] = IO();} /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-不可修改区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-可修改区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ /*↓可修改区*/ // 自定义结构体 struct pii { int x, y; bool operator\u0026lt; (const pii\u0026amp; j) { return x != j.x ? x \u0026lt; j.x : y \u0026lt; j.y; } }; struct pjj { int l, r, maxv; }; /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-可修改区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-全局变量区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ const int mod = 1e9 + 7; const int inf = (1LL \u0026lt;\u0026lt; 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e5 + 10, M = 1e6 + 10; pjj seg[N \u0026lt;\u0026lt; 1]; /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-全局变量区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-模板代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-模板代码区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-函数代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ void push_up(int l, int r, int node) { seg[node].maxv = max({seg[ls].maxv, seg[rs].maxv, seg[ls].r + seg[rs].l}); int mid = (l + r) \u0026gt;\u0026gt; 1; seg[node].l = seg[ls].l, seg[node].r = seg[rs].r; if (seg[ls].l == mid - l + 1) seg[node].l += seg[rs].l; if (seg[rs].r == r - mid) seg[node].r += seg[ls].r; } void build(int l, int r, int node = 1) { if (l == r) { seg[node].l = seg[node].r = seg[node].maxv = 1; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, ls), build(mid + 1, r, rs); push_up(l, r, node); } void modify(int indx, int val, int l, int r, int node = 1) { if (l == r) { seg[node].maxv = seg[node].l = seg[node].r = val; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (indx \u0026lt;= mid) modify(indx, val, l, mid, ls); else modify(indx, val, mid + 1, r, rs); push_up(l, r, node); } int get(int indx, int l, int r, int node = 1) { if (l == r) return seg[node].maxv; int mid = (l + r) \u0026gt;\u0026gt; 1; if (indx \u0026lt;= mid) { if (mid - indx + 1 \u0026lt;= seg[ls].r) return seg[rs].l + seg[ls].r; else return get(indx, l, mid, ls); } else { if (indx - mid \u0026lt;= seg[rs].l) return seg[ls].r + seg[rs].l; else return get(indx, mid + 1, r, rs); } } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-函数代码区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-主代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ void problem() { int n = IO(), m = IO(); build(1, n); string q; vi\u0026lt;int\u0026gt; last; // int k = 0; while(m--) { getstr(q); if (q[0] == \u0026#39;D\u0026#39;){ int x = IO(); modify(x, 0, 1, n); last.pb(x); } else if (q[0] == \u0026#39;Q\u0026#39;) print(get(IO(), 1, n), \u0026#39;\\n\u0026#39;); else { modify(last.back(), 1, 1, n); last.pop_back(); } } } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-主代码区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ int main() { // int t = 1; // t = IO(); // while (t--) problem(); while (1) problem(); return 0; } ","date":"2021-07-30T14:09:14+08:00","permalink":"https://example.com/2021/hdu1540-tunnel-warfare/","title":"HDU1540 Tunnel Warfare"},{"content":" 题意：有N个人排队，每一个人都有一个val来对应，每一个后来人都会插入当前队伍的某一个位置pos。要求把队伍最后的状态输出。 这道题如果是直接平衡树做的话直接就是 $O(nlogn)$ 的时间复杂度，但杀鸡焉用牛刀 因为当前插队的人只会影响后面的人，固我们可以考虑倒过来插队，假设当前正在插入第 $x$ 个人，则一定是在前 $x-1$ 个相对位置中挑一个位置插入，且一旦插入后其相对前 $x-1$ 个人的位置不会再改变。 固我们可以这样做：先从最后一个人（即第 $n$ 个人）开始插，在其前 $n-1$ 个人中找其位置，然后此位置将固定为第 $n$ 个人的位置，再来给第 $n-1$ 个插入位置，此时是在前 $n-2$ 个人中找相对位置，注意这时候已经被第 $n$ 个人占用的位置是直接忽略的，以此来寻找第 $n-1$ 个人的位置。后面类推 这个过程模拟起来便是用一个数组，开始时全部初始化为1，当要找第 $x$ 个位置时，就找前缀和为 $x$ 的位置，将此位置置为0，这时对于下一个要找的位置 $y$ 依旧是找前缀和恰好（注意是恰好）为 $y$ 的位置，再将其置为0，以此类推，一直为第1个人找到位置 上诉过程是可以用线段树（或者树状数组）的单点修改来实现，至于找前缀和恰好为 $x$ 的位置可以用二分加查询来找，固这样的时间复杂度为 $O(nlog^2n)$ 但这样的时间复杂度我不能接受，可以观察我们找前缀和恰好为 $x$ 的步骤，二分是没有必要的，可以在线段树内找这个位置（线段树的强大），这样时间复杂度就是 $O(nlogn)$ 具体看代码线段树函数部分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define debug(x) printf(#x\u0026#34; = %lld\\n\u0026#34;, (ll)x) #define bug puts(\u0026#34;bug\u0026#34;) #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() #define ls (node \u0026lt;\u0026lt; 1) #define rs ((node \u0026lt;\u0026lt; 1) | 1) using namespace std; /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-快读与快输-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026amp;\u0026amp; c != -1; c = getchar()) { if (c == \u0026#39;-\u0026#39;) f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c ^ \u0026#39;0\u0026#39;); } return f ? -x : x; } void getstr(string \u0026amp;s) { int c = getchar(); while (c \u0026lt; 33 \u0026amp;\u0026amp; c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u0026gt; 32; c = getchar()) s.pb(c); } void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } void print(const string\u0026amp; s) { for (char c : s) putchar(c); } template \u0026lt;typename T\u0026gt; void print(T x, char c) { print(x); putchar(c); } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-快读与快输-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-不可修改区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ // gcd template \u0026lt;typename T\u0026gt; T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u0026gt;\u0026gt;= 1, a = a * a % p) if (b \u0026amp; 1) res = res * a % p; return res; } // 数组读入 template \u0026lt;typename T\u0026gt; inline void fill_w(T *a, int cnt) { for (int i = 0; i \u0026lt; cnt; ++i) a[i] = IO();} /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-不可修改区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-可修改区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ /*↓可修改区*/ // 自定义结构体 struct pii { int x, y; bool operator\u0026lt; (const pii\u0026amp; j) { return x != j.x ? x \u0026lt; j.x : y \u0026lt; j.y; } }; /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-可修改区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-全局变量区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ const int mod = 1e9 + 7; const int inf = (1LL \u0026lt;\u0026lt; 31) - 1; const ll INF = 1e18; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e5 + 10, M = 1e6 + 10; pii p[N \u0026lt;\u0026lt; 1]; int seg[N \u0026lt;\u0026lt; 3], que[N \u0026lt;\u0026lt; 1]; /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-全局变量区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-模板代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-模板代码区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-函数代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ void push_up(int node) { seg[node] = seg[ls] + seg[rs]; } void build(int l, int r, int node = 1) { if (l == r) { seg[node] = 1; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, ls), build(mid + 1, r, rs); push_up(node); } void modify(int k, int val, int l, int r, int node = 1) { if (l == r) { seg[node] = 0, que[l] = val; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (seg[ls] \u0026gt;= k) modify(k, val, l, mid, ls); // 找前缀和恰好为k的 else modify(k - seg[ls], val, mid + 1, r, rs); push_up(node); } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-函数代码区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-主代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ void problem() { int n = IO(); for (int i = 0; i \u0026lt; n; ++i) { p[i].x = IO(), p[i].y = IO(); } reverse(p, p + n); build(1, n); for (int i = 0; i \u0026lt; n; ++i) { modify(p[i].x + 1, p[i].y, 1, n); } for (int i = 1; i \u0026lt;= n; ++i) print(que[i], i == n ? \u0026#39;\\n\u0026#39; : \u0026#39; \u0026#39;); } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-主代码区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ int main() { // int t = 1; // t = IO(); // while (t--) problem(); while (1) problem(); return 0; } ","date":"2021-07-29T14:00:38+08:00","permalink":"https://example.com/2021/acwing260%E4%B9%B0%E7%A5%A8/","title":"AcWing260买票"},{"content":" 题意：给定一个长度为n的序列a，给定m个查询，每次查询区间[L,R]范围内不同元素的和。 此题我的思路是利用离线操作和区间查询，其中区间查询方便起见用了树状数组 考虑记录每个下标上的数上一次出现在哪里，假设用一个数组 last 记录，则问题就转化为：每次询问 [l, r] 区间中 last 数组小于 l 的数的和 这样为了方便查询，先将所有询问记录下来，离线操作。即将所有询问按其 l 值进行升序排序，然后再遍历排好序的查询，对于每次查询，将所有 last 严格小于 l 数 a[i] 插入带树状数组中（按下标 i 插入），则当前查询的答案便是区间 [l, r] 的和。 为了方便上述的插入操作，构建一个结构体（记录原数组的值、下标和last值）然后再按last排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define rep(u, i, e) for (int i = head[u]; ~i; i = e[i].next) #define pb push_back #define debug(x) printf(#x\u0026#34; = %lld\\n\u0026#34;, (ll)x) #define bug puts(\u0026#34;bug\u0026#34;) #define umap unordered_map #define uset unordered_set #define vi vector #define all(x) x.begin(), x.end() #define lb(x) (x \u0026amp; (-x)) using namespace std; /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-快读与快输-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026amp;\u0026amp; c != -1; c = getchar()) { if (c == \u0026#39;-\u0026#39;) f = 1; } if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c ^ \u0026#39;0\u0026#39;); } return f ? -x : x; } void getstr(string \u0026amp;s) { int c = getchar(); while (c \u0026lt; 33 \u0026amp;\u0026amp; c != -1) c = getchar(); if (c == -1) exit(0); s.clear(); for(;c \u0026gt; 32; c = getchar()) s.pb(c); } void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } void print(const string\u0026amp; s) { for (char c : s) putchar(c); } template \u0026lt;typename T\u0026gt; void print(T x, char c) { print(x); putchar(c); } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-快读与快输-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-不可修改区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ // gcd template \u0026lt;typename T\u0026gt; T gcd(T a, T b, T m = 0) { while (b) m = a % b, a = b, b = m; return a; } // 快速幂 ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u0026gt;\u0026gt;= 1, a = a * a % p) if (b \u0026amp; 1) res = res * a % p; return res; } // 数组读入 template \u0026lt;typename T\u0026gt; inline void fill_w(T *a, int cnt) { for (int i = 0; i \u0026lt; cnt; ++i) a[i] = IO();} /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-不可修改区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-可修改区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ /*↓可修改区*/ // 自定义结构体 struct pii { int l, r, indx; bool operator\u0026lt; (const pii\u0026amp; j) { return l != j.l ? l \u0026lt; j.l : r \u0026lt; j.r; } }; struct pjj { ll a; int indx, last; bool operator\u0026lt; (const pjj\u0026amp; j) { return last \u0026lt; j.last; } }; /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-可修改区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-全局变量区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ const int mod = 2333; const int inf = (1LL \u0026lt;\u0026lt; 31) - 1; const ll llf = 1e18; const double eps = 1e-5, PI = acos(-1); const int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1}; // 上左下右，顺时针 const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1}; const int N = 1e5 + 10, M = 2e6 + 10; ll ans[N], bit[N]; umap\u0026lt;ll, int\u0026gt; mp; pii ask[N]; pjj arr[N]; /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-全局变量区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-模板代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ void modify(int indx, ll val, int n) { while(indx \u0026lt;= n) { bit[indx] += val; indx += lb(indx); } } ll get(int indx) { ll res = 0; while(indx \u0026gt; 0) { res += bit[indx]; indx -= lb(indx); } return res; } ll get(int l, int r) { return get(r) - get(l - 1); } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-模板代码区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-函数代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-函数代码区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ /*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓-主代码区-↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/ void problem() { int n = IO(); for (int i = 1; i \u0026lt;= n; ++i) { arr[i].a = IO(), arr[i].indx = i; arr[i].last = mp[arr[i].a]; mp[arr[i].a] = i; } sort(arr + 1, arr + 1 + n); int m = IO(); for (int i = 1; i \u0026lt;= m; ++i) { ask[i].l = IO(), ask[i].r = IO(); ask[i].indx = i; } sort(ask + 1, ask + 1 + m); for (int i = 1, j = 1; i \u0026lt;= m; ++i) { while (j \u0026lt;= n \u0026amp;\u0026amp; arr[j].last \u0026lt; ask[i].l) { modify(arr[j].indx, arr[j].a, n); j += 1; } ans[ask[i].indx] = get(ask[i].l, ask[i].r); } for (int i = 1; i \u0026lt;= m; ++i) print(ans[i], \u0026#39;\\n\u0026#39;); fill_n(bit, n + 5, 0); mp.clear(); } /*↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑-主代码区-↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/ int main() { int t = 1; // prework(); t = IO(); while (t--) problem(); // while (1) problem(); return 0; } 当然，本题也可以用主席树来做，具体看洛谷1972的刷题记录 ","date":"2021-07-28T22:20:40+08:00","permalink":"https://example.com/2021/hdu3333-turing-tree/","title":"HDU3333 Turing Tree"},{"content":"1. 树形dp 树的最大独立集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 /* Loj 10160 每个点都有一个快乐值，子结点和父节点不能同时被选，问你最大的快乐值 dp[i][0]表示第i号结点不选时最大的快乐值 dp[i][1]表示第i号结点选时的最大的快乐值 */ #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int M = 6e3 + 5; inline long long IO() {} // 快读略 struct es{ int to, nxt; }e[M \u0026lt;\u0026lt; 1]; int head[M], cnt; inline void init() { memset(head, -1, sizeof head); cnt = 0; } inline void add(int u, int v) { e[++cnt] = {.to = v, .nxt = head[u]}; head[u] = cnt; } int n, h[M], vis[M], dp[M][2]; void dfs(int u) { dp[u][1] = h[u]; for (int i = head[u]; ~i; i = e[i].nxt) { int v = e[i].to; dfs(v); dp[u][0] += max(dp[v][0], dp[v][1]); dp[u][1] += dp[v][0]; } } int main() { int n = read(); for (int i = 1; i \u0026lt;= n; ++i) h[i] = read(); int u = read(), v = read(); init(); while (u | v) { add(v, u); vis[u] = true; u = read(), v = read(); } int root = 0; for (int i = 1; i \u0026lt;= n; ++i) { if (!vis[i]) root = i; } dfs(root); printf(\u0026#34;%d\\n\u0026#34;, max(dp[root][0], dp[root][1])); return 0; } 树的最小支配集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 /* Loj 10157 每个点都有点权，一个点可以看守连着他的边上的点，选一些点出来，使他们能够看守整颗树上所有的点 问你最小选出来的权值 dp[0][i]表示i点被选上，则其 += min({dp[0][son], dp[2][son], dp[1][son]}) dp[1][i]表示i点没被选上，但是其父亲被选上了，则其 += min(dp[0][son], dp[2][son]) dp[2][i]表示i点没被选上，但是去其中某几个儿子被选上了，注意这个比较难转移，转移方式如下 先求出所有儿子min(dp[0][son], dp[2][son])的总和，然后在递归完后选出最小是那个儿子的dp[0][son] 即dp[2][u] = min(dp[2][u], sum - min(dp[2][v], dp[0][v]) + dp[0][v]);这行 */ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; #define ll long long #include \u0026lt;cctype\u0026gt; inline long long IO() {} // 快读略 const int maxn = 1e5, maxm = 1e5; const int INF = 0x3f3f3f3f; int head[maxn], cnt, dis[maxn]; //初始化 void init() { memset(head, -1, sizeof head); // memset(vis, false, sizeof vis); cnt = 0; } struct edges { int to, next; int w; edges(int to = 0, int next = -1, int w = 0) : to(to), next(next), w(w) {} }edge[maxm \u0026lt;\u0026lt; 1]; //无向图则需要乘2 inline void add(int u, int v, int w = 0) { if (cnt == 0) init(); edge[++cnt] = edges(v, head[u], w); head[u] = cnt; } const int M = 1e4, inf = 0x3f3f3f3f; int n, m, dp[3][M], vis[M], c[M]; void dfs(int u, int fa) { dp[0][u] = c[u], dp[2][u] = inf; int sum = 0; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa) continue; dfs (v, u); dp[0][u] += min({dp[0][v], dp[2][v], dp[1][v]}); if (fa != -1) dp[1][u] += min(dp[2][v], dp[0][v]); sum += min(dp[2][v], dp[0][v]); } for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa) continue; dp[2][u] = min(dp[2][u], sum - min(dp[2][v], dp[0][v]) + dp[0][v]); } } int main() { n = IO(); init(); for (int i = 0; i \u0026lt; n; ++i) { int u = IO(), w = IO(), k = IO(); c[u] = w; while (k--) { int v = IO(); add(u, v), add(v, u); } } dfs(1, -1); printf(\u0026#34;%d\u0026#34;, min(dp[0][1], dp[2][1])); return 0; } 树的最小点覆盖 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 /* Loj10156 每个点都能看到他所连着的边，问你选出最少的点使树上所有的边都能被看到 dp[0][i]表示不选i点的最小选择数 则其 += dp[1][son] dp[1][i]表示选i点的最小选择数，则其 += min(dp[0][son], dp[1][son]) */ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; #define ll long long #include \u0026lt;cctype\u0026gt; inline long long IO() {} // 快读略 const int maxn = 1e5, maxm = 1e5; const int INF = 0x3f3f3f3f; int head[maxn], cnt, dis[maxn]; //初始化 void init() { memset(head, -1, sizeof head); // memset(vis, false, sizeof vis); cnt = 0; } struct edges { int to, next; int w; edges(int to = 0, int next = -1, int w = 0) : to(to), next(next), w(w) {} }edge[maxm \u0026lt;\u0026lt; 1]; //无向图则需要乘2 inline void add(int u, int v, int w = 0) { if (cnt == 0) init(); edge[++cnt] = edges(v, head[u], w); head[u] = cnt; } const int M = 1e4; int n, m, dp[2][M], vis[M]; void dfs(int u, int fa) { dp[1][u] = 1; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa) continue; dfs(v, u); dp[1][u] += min(dp[0][v], dp[1][v]); dp[0][u] += dp[1][v]; } } int main() { n = IO(); for (int i = 0; i \u0026lt; n; ++i) { int u = IO(), k = IO(); while (k--) { int v = IO(); add(u, v), add(v, u); } } dfs(0, -1); // printf(\u0026#34;%d\\n\u0026#34;, ans); printf(\u0026#34;%d\u0026#34;, min(dp[0][0], dp[1][0])); return 0; } 树的直径 两次搜索法 该方法只适用于边权为正整数情况 第一次搜索从任意一点出发找到最远点s 第二次搜索从s点出发找到最远点，并记录到达此点的距离，就是直径 一次DP法 一次DP法又分两种，两者各有好处 一种是下面例题中的方式，核心就是记录从一个点出发的最远点和次远点 另一种是上述的优化 1 2 3 4 5 6 7 8 9 10 11 dp[N]; // 记录到达结点的最远点 ans; //记录直径 void dfs(int u, int fa) { for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == u) continue; dfs(v); ans = max(ans, dp[u] + dp[v] + edge[i].w); dp[u] = max(dp[u], dp[v] + edge[i].w); } } 例题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 /* Loj 10159 树的直径：树上最长路径 本题需要求出所有直径（直径可能不唯一）上的所有点 解决方法：每次递归算出结点到其儿子中的最长路径和次长路径，然后相加 维护好全局变量ans，最终答案就是ans */ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; #define ll long long #include \u0026lt;cctype\u0026gt; inline long long IO() {} // 快读略 const int maxn = 2e5 + 5, maxm = 2e5 + 5; const int INF = 0x3f3f3f3f; int head[maxn], cnt, dis[maxn]; //初始化 void init() { memset(head, -1, sizeof head); // memset(vis, false, sizeof vis); cnt = 0; } struct edges { int to, next; int w; edges(int to = 0, int next = -1, int w = 0) : to(to), next(next), w(w) {} }edge[maxm \u0026lt;\u0026lt; 1]; //无向图则需要乘2 inline void add(int u, int v, int w = 0) { if (cnt == 0) init(); edge[++cnt] = edges(v, head[u], w); head[u] = cnt; } const int M = 2e5, inf = 0x3f3f3f3f; int dp[M], t[M], ans = 0, d1[M], d2[M]; vector\u0026lt;int\u0026gt; res; int dfs(int u, int fa) { d1[u] = 0, d2[u] = 0; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa) continue; int len = dfs(v, u) + 1; if (len \u0026gt;= d1[u]) { d2[u] = d1[u], d1[u] = len; } else if (len \u0026gt; d2[u]) { d2[u] = len; } } ans = max(ans, d1[u] + d2[u]); return d1[u]; } void dfs(int u, int fa, int d) { for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa) continue; if (d1[v] == d) dfs(v, u, d - 1), res.push_back(v); } } void solve(int u, int fa) { if (d1[u] + d2[u] == ans) { res.push_back(u); if (d1[u] != d2[u]) dfs(u, fa, d2[u] - 1); dfs(u, fa, d1[u] - 1); } for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa) continue; solve(v, u); } } int main() { int n = IO(); init(); for (int i = 1; i \u0026lt; n; ++i) { int u = IO(), v = IO(); add(u, v), add(v, u); } dfs(0, -1); solve(0, -1); sort(res.begin(), res.end()); auto x = unique(res.begin(), res.end()); auto i = res.begin(); while (i != x) { printf(\u0026#34;%d\\n\u0026#34;, *i); i++; } return 0; } 树的重心 树的重心的一些重要性质： 一棵树最少有一个重心，最多有两个重心，若有两个重心，则他们相邻（即连有直接边） 树上所有点到某个点的距离和里，到重心的距离和最小；若有两个重心，则其距离和相同 若以重心为根，则所有子树的大小都不超过整棵树的一半 在一棵树上添加或删除一个叶子节点，其重心最多平移一条边的距离 两棵树通过连一条边组合成新树，则新树重心在原来两棵树的重心的连线上 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 /* Poj 1655 树的重心：重心是指树中的一个结点，如果将这个结点删除后剩余的各个连通块中结点数的最大值最小，则称为树的重心 本题需要求出重心，如果有多个输出最小编号的结点，并输出重心被删除后连通块结点数的最大值 */ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cctype\u0026gt; inline long long IO() {} // 快读略 using namespace std; const int maxn = 1e5 + 5, maxm = 2e5 + 5, inf = 0x3f3f3f3f; int head[maxn], cnt; //初始化 void init() { memset(head, -1, sizeof head); cnt = 0; } struct edges { int to, next; }edge[maxm \u0026lt;\u0026lt; 1]; //无向图则需要乘2 inline void add(int u, int v) { edge[++cnt].to = v, edge[cnt].next = head[u]; head[u] = cnt; } int ans, siz; int dfs(int u, int fa, const int \u0026amp;n) { int tot = 1, num = 0; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa) continue; int tmp = dfs(v, u, n); tot += tmp, num = max(num, tmp); } int res = max(n - tot, num); if (siz \u0026gt;= res) { if (siz == res) ans = min(u, ans); else ans = u, siz = res; } return tot; } void solve() { int n = IO(); init(), siz = inf; for (int i = 1; i \u0026lt; n; ++i) { int u = IO(), v = IO(); add(u, v), add(v, u); } dfs(1, -1, n); printf(\u0026#34;%d %d\\n\u0026#34;, ans, siz); } int main() { int t = IO(); while (t--) solve(); return 0; } 树的中心 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 /* 例题：无 树的中心：找出一个点，使该点到其他点的最远距离最小，则这个点就是树的中心 解题思路： 从u点到其他点的最远距离分为两类 1.从u点向下走的最远距离，用d1[u]表示 2.从u点向上走的最远距离，用up[u]表示 则从u点到其他点的最远距离就是 max(d1[u], up[u]); 则中心到其他点的最远距离就是ans = min{dp[i]} 其中d1[u]可用求树的直径的方法求出 记得同时维护d2[u]即次长距离，和维护最长的路是哪个儿子 关于up的计算方式要用父亲节点来更新儿子节点，与求d1是相反的 如果u的儿子结点son在最长的路径上则 up[son] = w[son] + max(up[u], d2[u]) 否则 up[son] = w[son] + max(up[u], d1[u]) 输入 5 2 1 1 3 2 1 4 3 1 5 1 1 输出中心到其他节点的最长长度 2 */ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int maxn = 1e5, maxm = 2e5, inf = 0x3f3f3f3f; int head[maxn], cnt; //初始化 void init() { memset(head, -1, sizeof head); cnt = 0; } struct edges { int to, next; int w; }edge[maxm \u0026lt;\u0026lt; 1]; //无向图则需要乘2 inline void add(int u, int v, int w) { edge[++cnt].to = v, edge[cnt].next = head[u]; edge[cnt].w = w, head[u] = cnt; } int d1[maxn], d2[maxn], maxv[maxn], up[maxn]; int dfs1(int u, int fa) { d1[u] = d2[u] = 0; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa) continue; int d = dfs1(v, u) + edge[i].w; if (d \u0026gt;= d1[u]) { d2[u] = d1[u], d1[u] = d; maxv[u] = v; } else if (d \u0026gt; d2[u]) { d2[u] = d; } } return d1[u]; } void dfs2(int u, int fa) { for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa) continue; if (maxv[u] == v) { up[v] = max(up[u], d2[u]) + edge[i].w; } else { up[v] = max(up[u], d1[u]) + edge[i].w; } dfs2(v, u); } } int main() { int n; init(); scanf(\u0026#34;%d\\n\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt; n; ++i) { int u, v, w; scanf(\u0026#34;%d %d %d\\n\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;w); add(u, v, w), add(v, u, w); } dfs1(1, -1); dfs2(1, -1); int res = 0x3f3f3f3f; for (int i = 1; i \u0026lt;= n; ++i) { res = min(res, max(up[i], d1[i])); } printf(\u0026#34;%d\u0026#34;, res); return 0; } 依赖背包问题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 /* Loj 10154选课 学生不可能学完大学开设的所有课程，因此必须在入学时选定自己要学的课程。 每个学生可选课程的总数是给定的。请找出一种选课方案使得你能得到的学分最多， 并满足先修课优先的原则。假定课程间不存在时间上的冲突。 输入的第一行包括两个正整数 ，分别表示待选课程数和可选课程数。 接下来 行每行描述一门课，课号依次为 。每行两个数，依次表示这门课先修课课号（若不存在，则该项值为 ）和该门课的学分。 输出一行，表示实际所选课程学分之和。 dp[i][j]代表第i门课程选j个课的最大学分和 题中的课程号是从1开始的，并不是一颗树，而是森林，我们假设有一个课程0，连接所有森林的根结点 */ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #define pb push_back using namespace std; #define ll long long #include \u0026lt;cctype\u0026gt; inline long long IO() {} const int maxn = 1e4, maxm = 1e4; const int INF = 0x3f3f3f3f; const int M = 310; int n, m, dp[M][M], tmp[M], w[M]; vector\u0026lt;int\u0026gt; mp[M]; int dfs(int u) { dp[u][1] = w[u];//初始化 int num = 1; for (int v : mp[u]) { int siz = dfs(v); for (int i = 1; i \u0026lt;= num; ++i) tmp[i] = dp[u][i]; for (int i = 1; i \u0026lt;= num; ++i) { for (int j = 0; j \u0026lt;= siz; ++j) { dp[u][i + j] = max(dp[u][i + j], tmp[i] + dp[v][j]); } } num += siz; } return num; //返回包括自己加上子树有多少个节点 } int main() { n = IO(), m = IO(); for (int i = 1; i \u0026lt;= n; ++i) { int u = IO(); mp[u].pb(i), w[i] = IO(); } dfs(0); printf(\u0026#34;%d\u0026#34;, dp[0][m + 1]); // 假设0号结点必选 return 0; } 基环树dp 换根 最长上升子序列 朴素动态规划 1 2 3 4 5 6 7 8 9 10 dp[N], ans = 1; for (int i = 1; i \u0026lt;= n; ++i) { dp[i] = 1; for (int j = 1; j \u0026lt; i; ++j) { if (a[j] \u0026lt; a[i]) { // 严格上升用 \u0026lt; , 否则用 \u0026lt;= dp[i] = max(dp[i], dp[j] + 1); } } ans = max(ans, dp[i]); } 贪心 1 // 坑（未补） 树状数组（或线段树）优化动态规划（直接优化） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 inline long long IO() {} using namespace std; const int N = 1e5 + 5, M = 1e6 + 5, inf = 1e9; int a[M]; unordered_map\u0026lt;int, int\u0026gt; mp; void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } #define lb(x) (x \u0026amp; (-x)) int bit[M], n; int get(int i) { int res = 0; while (i) { res = max(res, bit[i]), i -= lb(i); } return res; } void update(int i, int v, int\u0026amp; len) { while(i \u0026lt;= len) { bit[i] = max(bit[i], v), i += lb(i); } } void problem() { int n = IO(); vector\u0026lt;int\u0026gt; arr; for (int i = 0; i \u0026lt; n; ++i) a[i] = IO(), arr.push_back(a[i]); sort(arr.begin(), arr.end()); arr.erase(unique(arr.begin(), arr.end()), arr.end()); int cnt = 0, res = 0, len = arr.size(); for (int x : arr) mp[x] = ++cnt; for (int i = 0; i \u0026lt; n; ++i) { int ans = get(mp[a[i]] - 1) + 1; res = max(ans, res); update(mp[a[i]], ans, len); } print(res); } int main() { int n = 1; while (n--) { problem(); } return 0; } 树状数组（或线段树）优化（将值排序，求下标的最长上升子序列） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #define ll long long #define all(x) x.begin(), x.end() inline long long IO() {} using namespace std; const int N = 1e5 + 5, M = 1e6 + 5, inf = 1e9; int num[N], sum[410]; ll a[210]; void print(ll x) {} //快输 struct pii{ int x, indx; }p[N]; #define lb(x) (x \u0026amp; (-x)) int bit[N], n; int get(int i) { int res = 0; while (i) { res = max(res, bit[i]), i -= lb(i); } return res; } void update(int i, int v) { while(i \u0026lt;= n) { bit[i] = max(bit[i], v), i += lb(i); } } void problem() { n = IO(); for (int i = 0; i \u0026lt; n; ++i) p[i].x = IO(), p[i].indx = i + 1; sort(p, p + n, [] (pii \u0026amp;i, pii \u0026amp;j) { if (i.x == j.x) return i.indx \u0026gt; j.indx; return i.x \u0026lt; j.x; }); int res = 0; for (int i = 0; i \u0026lt; n; ++i) { int ans = get(p[i].indx - 1) + 1; res = max(ans, res); update(p[i].indx, ans); } print(res); } int main() { int n = 1; while (n--) { problem(); } return 0; } ","date":"2021-07-27T20:46:34+08:00","permalink":"https://example.com/2021/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%A5%97%E8%B7%AF%E6%9D%BF%E5%AD%90/","title":"动态规划套路板子"},{"content":"二维几何（未完善，已弃） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;vector\u0026gt; /** * 本板子属于半成品，有些功能并没有验证 * 函数说明： * 关于点的函数 * 点的Point(double, double) 构造函数 * + 向量加法 * - 向量减法 * == 判断两个点是否相等 * *(Point) 向量点乘 * *(double) 向量伸长(没有除法，要用除法直接乘倒数) * ^ 向量叉乘 * \u0026lt; 点对点的比较 * double len() 向量的长度，也可以用来求两个点的距离 * double len2() const; 向量长度的平方 * double dist(Point); 判断p点到这个点的距离 * double angle(Point, Point); // 传入两个点a b， 返回 角apb 的弧度 * Point rotate(double angle) 向量逆时针旋转angle弧度 * Point rotate(Point, double) 点让点p逆时针旋转angle弧度 * void print() 将点输出 * int init() 输入点的坐标 返回值和scanf相同 * 其他非结构体函数 * angle(Point\u0026amp;, Point\u0026amp;) 计算两个向量的夹角 * * 关于线的函数 * Line(Point, Point) 构造函数 * Line(Point, double) 根据一个点和一个倾斜角 0 \u0026lt;= angle \u0026lt; PI确定直线 （未验证） * double len() 返回线段的长度 * Point vec(); 获取该线的向量 * double point(double t) 返回距离点p向前t倍向量的点 * double angle() 返回直线的倾斜角 范围[0, PI) (未验证) * int PointAndLine(Point); // 点和直线的关系，1 点在线左边，2 右边， 3 线上面 * double disPointToLine(const Point\u0026amp;) 点到这条直线的距离 * double disPointToSeg(const Point\u0026amp;) 点到这条线段的距离（未验证） * Point getPro(const Point\u0026amp;) 点在这条线上的投影 （未验证） * Point getSym(const Point\u0026amp;) 点关于这条线的对称点 （未验证） * bool isOnLine(const Point\u0026amp;) 验证该点是否在这条直线上（未验证） * bool isOnSeg(const Point\u0026amp;) 验证该点是否在这条线段上（未验证） * Point cross(Line\u0026amp;) 直线和这条直线的交点，前提是相交 * void print() 输出这条线段 * * 其他非结构体 * int LineAndLine(Line\u0026amp;, Line\u0026amp;) 直线和直线的关系 0平行 1重合 2相交 （未验证） * Point getLineInter(const Line\u0026amp;, const Line\u0026amp;) 求两直线的交点,必须相交才能调用 （此函数有问题） * int SegAndSeg(const Line\u0026amp; l1, const Line\u0026amp; l2) 两个线段的关系 0不相交 1非规范相交(其中一个线段的端点和另一个线段相交) 2规范相交 （未验证） * int LineAndSeg(const Line\u0026amp; line, const Line\u0026amp; seg) 直线和线段的关系，0不相交 1非规范相交 2规范相交 （未验证） * * 关于圆的函数 * Circle(Point, double) 构造函数 * Circle(Point, Point, Point) 过三点的圆 * double area() const; 返回圆的面积 * double circum() const 返回圆的周长 * int PointAndCircle(Point\u0026amp;) 点和圆的关系 返回 0圆外 1圆上 2圆内 * int LineAndCircle(Point\u0026amp;) 点和圆的关系 返回 0不相交 1相交 2相交两个点（未验证） * int CircleAndCircle(Circle\u0026amp;) 圆和圆的关系 返回 0内含 1内切 2相交两点 3外切 4外离 （未验证） * * 关于三角形的函数 * Triangle(Point, Point, Point) 构造函数 * double area() const 返回三角形函数 * Circle outerCircle() 获取三角形的外接圆 * * 关于多边形的函数 * Polygon(vector\u0026lt;Point\u0026gt;\u0026amp;) 构造函数 * double circum(); 求凸包的周长 * void graham(Polygon\u0026amp;) 求凸包 传入值为需要求出的凸包的点集 * int PointAndPolgon(Point\u0026amp;) 判断点与多边形的关系，0外 1内 2边上 3点上 （未实现） * double minRectCover() 点集的最小矩形覆盖，自己必须是（逆时针）凸包才能调用 （未实现） * Circle minCircleCover() 点集的最小圆覆盖 */ using namespace std; const double eps = 1e-8, PI = acos(-1.0); int dcmp(double x) { if (fabs(x) \u0026lt; eps) return 0; return x \u0026gt; 0 ? 1 : -1; } /******************************点*******************************/ /* 除了结构体内部函数还有 angle(Point\u0026amp; a, Point\u0026amp; b) // 两个向量的夹角 */ struct Point { double x, y; Point(double x = 0, double y = 0) : x(x), y(y) {} Point operator + (const Point\u0026amp;) const; Point operator - (const Point\u0026amp;) const; double operator * (const Point\u0026amp;) const; // 点乘 double operator ^ (const Point\u0026amp;) const; // 叉乘 bool operator == (const Point\u0026amp;) const; bool operator \u0026lt; (const Point\u0026amp;) const; // 排序需要 Point operator * (double); //向量伸长b倍 double len() const; // 向量的长度 double len2() const; // 向量长度的平方 double dist(Point); // 判断p点到这个点的距离 double angle(Point, Point); // 传入两个点a b， 返回 角apb 的弧度 Point rotate(double); // 向量逆时针旋转a弧度后 Point rotate(Point\u0026amp;, double); // 点绕p点顺时针旋转a弧度后 void print() { printf(\u0026#34;%.2f %.2f\u0026#34;, x, y); } int init() { return scanf(\u0026#34;%lf%lf\u0026#34;, \u0026amp;x, \u0026amp;y); } }; Point Point::operator + (const Point\u0026amp; b) const { return Point(x + b.x, y + b.y); } Point Point::operator - (const Point\u0026amp; b) const { return Point(x - b.x, y - b.y); } // 点乘 double Point::operator * (const Point\u0026amp; b) const { return x * b.x + y * b.y; } // 叉乘 double Point::operator ^ (const Point\u0026amp; b) const { return x * b.y - y * b.x; } bool Point::operator == (const Point\u0026amp; b) const { return !dcmp(x - b.x) \u0026amp;\u0026amp; !dcmp(y - b.y); } bool Point::operator \u0026lt; (const Point\u0026amp; b) const { return (!dcmp(x - b.x)) ? dcmp(y - b.y) \u0026lt; 0 : x \u0026lt; b.x; } // 向量的长度 double Point::len() const { return hypot(x, y); } // 向量长度平方 double Point::len2() const { return x * x + y * y; } // 判断p点到这个点的距离 double Point::dist(Point p) { return hypot(x - p.x, y - p.y); } // 向量伸长b倍 Point Point::operator * (double b) { return Point(x * b, y * b); } // 返回 角apb 的弧度 double Point::angle(Point a, Point b) { Point p = *this; return fabs(atan2(fabs((a - p) ^ (b - p)), (a - p) * (b - p))); } // 向量逆时针旋转a弧度后 // cosx -sinx // sinx cosx Point Point::rotate(double a) { return Point(x * cos(a) - y * sin(a), x * sin(a) + y * cos(a)); } // 点绕p点顺时针旋转a弧度后 Point Point::rotate(Point \u0026amp;p, double a) { Point vec = (*this) - p; return vec.rotate(a) + p; } // 两个向量的夹角 double angle(Point\u0026amp; a, Point\u0026amp; b) { return acos(a * b / a.len() / b.len()); } /******************************线*******************************/ /* 除了结构体内部函数还有 int LineAndLine(Line\u0026amp; l1, Line\u0026amp;) 直线和直线的关系 0平行 1重合 2相交 Point getLineInter(const Line\u0026amp; l1, const Line\u0026amp; l2) 求两直线的交点,必须相交才能调用 int SegAndSeg(const Line\u0026amp; l1, const Line\u0026amp; l2) 两个线段的关系 0不相交 1非规范相交(其中一个线段的端点和另一个线段相交) 2规范相交 int LineAndSeg(const Line\u0026amp; line, const Line\u0026amp; seg) 直线和线段的关系，0不相交 1非规范相交 2规范相交 */ struct Line { Point s, e; Line() {} Line(Point s, Point e) : s(s), e(e) {} Line(Point, double); // 根据一个点和一个倾斜角0\u0026lt;= angle \u0026lt; PI确定直线 double len(); // 线段的长度 Point vec() const; // 获取该线的向量 Point point(double); // P = s + vt double angle(); // 直线的倾斜角[0, PI) int PointAndLine(Point); // 点和直线的关系，1 点在线左边，2 右边， 3 线上面 double disPointToLine(const Point\u0026amp;); // 点到这条直线的距离 double disPointToSeg(const Point\u0026amp;); // 点到这条线段的距离 Point getPro(const Point\u0026amp;); // 点到这条线的投影 Point getSym(const Point\u0026amp;); // 点关于这条线的对称点 bool isOnLine(const Point\u0026amp;); // 点是否在这条直线上 bool isOnSeg(const Point\u0026amp;); // 点是否在这条线段上 Point cross(Line\u0026amp;); // 直线和这条直线的交点，前提是相交才能调用 void print(); // 输出线段 }; Line::Line(Point p, double angle) : s(p) { if (!dcmp(angle - PI / 2)) e = s + Point(0, 1); else e = s + Point(1, tan(angle)); } double Line::len() { return s.dist(e); } Point Line::vec() const { return e - s; } Point Line::point(const double t){ return (s + (vec() * t)); } double Line::angle() { double ret = atan2(e.y - s.y, e.x - s.x); if (dcmp(ret) \u0026lt; 0) ret += PI; if (!dcmp(ret - PI)) ret -= PI; return ret; } int Line::PointAndLine(Point p) { int c = dcmp((p - s) ^ vec()); if (c \u0026lt; 0) return 1; return c ? 2 : 3; } void Line::print() { printf(\u0026#34;(%f,%f) -\u0026gt; (%f,%f)\u0026#34;, s.x, s.y, e.x, e.y); } double Line::disPointToLine(const Point\u0026amp; p) { return fabs((p - s) ^ vec()) / len(); } double Line::disPointToSeg(const Point\u0026amp; p) { if (s == e) return (s - p).len(); Point v1 = p - s, v2 = p - e, v = vec(); if (dcmp(v1 * v) \u0026lt; 0) return v1.len(); if (dcmp(v2 * v) \u0026gt; 0) return v2.len(); return disPointToLine(p); } Point Line::getPro(const Point\u0026amp; p) { Point v = vec(); return s + v * (v * (p - s) / v.len2()); } Point Line::getSym(const Point\u0026amp; p) { Point q = getPro(p); return Point(2 * q.x - p.x, 2 * q.y - p.y); } bool Line::isOnLine(const Point\u0026amp; p) { return !dcmp((p - s) ^ (p - e)); } bool Line::isOnSeg(const Point\u0026amp; p) { return isOnLine(p) \u0026amp;\u0026amp; (dcmp((p - s) * (p - e)) \u0026lt;= 0); } Point Line::cross(Line\u0026amp; l) { Point l_vec = l.vec(); double a1 = l_vec ^ (s - l.s); double a2 = l_vec ^ (e - l.s); return Point((s.x * a2 - e.x * a1) / (a2 - a1), (s.y *a2 - e.y * a1) / (a2 - a1)); } // 直线和直线的关系 0平行 1重合 2相交 int LineAndLine(Line\u0026amp; l1, Line\u0026amp; l2) { if (!dcmp(l1.vec() ^ l2.vec())) return l2.isOnLine(l1.s); return 2; } // 求两个直线的交点，必须相交才能调用 Point getLineInter(Line\u0026amp; l1, Line\u0026amp; l2) { Point v = l1.s - l2.s, l1_vec = l1.vec(), l2_vec = l2.vec(); double t = (l2_vec ^ v) / (l1_vec ^ l2_vec); return l1.point(t); } // 判断两个线段的关系 int SegAndSeg(const Line\u0026amp; l1, const Line\u0026amp; l2) { Point l1_vec = l1.vec(), l2_vec = l2.vec(); int d1 = dcmp(l1_vec ^ (l2.s - l1.s)); int d2 = dcmp(l1_vec ^ (l2.e - l1.s)); int d3 = dcmp(l2_vec ^ (l1.s - l2.s)); int d4 = dcmp(l2_vec ^ (l1.e - l2.s)); if((d1 ^ d2) == -2 \u0026amp;\u0026amp; (d3 ^ d4) == -2) return 2; return (!d1 \u0026amp;\u0026amp; dcmp((l2.s - l1.s) * (l2.s - l1.e)) \u0026lt;= 0) || (!d2 \u0026amp;\u0026amp; dcmp((l2.e - l1.s) * (l2.e - l1.e)) \u0026lt;= 0) || (!d3 \u0026amp;\u0026amp; dcmp((l1.s - l2.s) * (l1.s - l2.e)) \u0026lt;= 0) || (!d4 \u0026amp;\u0026amp; dcmp((l1.e - l2.s) * (l1.e - l2.e)) \u0026lt;= 0); } // 直线和线段的关系，0不相交 1非规范相交 2规范相交 int LineAndSeg(const Line\u0026amp; line, const Line\u0026amp; seg) { Point line_vec = line.vec(); int d1 = dcmp(line_vec ^ (seg.s - line.s)); int d2 = dcmp(line_vec ^ (seg.e - line.s)); if ((d1 ^ d2) == -2) return 2; return d1 == 0 || d2 == 0; } /******************************圆*******************************/ struct Circle { Point p; double r; Circle() {} Circle(Point p, double r) : p(p), r(r) {} Circle(Point, Point , Point); // 过三点一个圆 double area() const; // 面积 double circum() const; // 周长 int PointAndCircle(Point\u0026amp;); // 点和圆的关系 0圆外 1圆上 2圆内 int LineAndCircle(Line\u0026amp;); // 直线和圆的关系 0不相交 1相切 2相交两点 int CircleAndCircle(Circle\u0026amp;); // 圆和圆的关系 0内含 1内切 2相交两点 3外切 4外离 }; double Circle::area() const { return PI * r * r; } double Circle::circum() const { return 2 * PI *r; } Circle::Circle(Point a, Point b, Point c) { Point v1 = b - a, v2 = c - b; Line l1((a + b) * 0.5, ((a + b) * 0.5) + Point(-v1.y, v1.x)); Line l2((b + c) * 0.5, ((b + c) * 0.5) + Point(-v2.y, v2.x)); p = getLineInter(l1, l2); r = (p - a).len(); } int Circle::PointAndCircle(Point\u0026amp; a) { int d = dcmp((a - p).len() - r); if (d \u0026gt; 0) return 0; if (d \u0026lt; 0) return 2; return 1; } int Circle::LineAndCircle(Line\u0026amp; l) { int d = dcmp(l.disPointToLine(p) - r); if (d \u0026gt; 0) return 0; if (d \u0026lt; 0) return 2; return 1; } int Circle::CircleAndCircle(Circle\u0026amp; c) { double dist = (c.p - p).len(); if (dcmp(dist - r - c.r) \u0026gt; 0) return 4; if (!dcmp(dist - r - c.r)) return 3; double l = fabs(r - c.r); if (dcmp(dist - r - c.r) \u0026lt; 0 \u0026amp;\u0026amp; dcmp(dist - l) \u0026gt; 0) return 2; return dcmp(dist - l) == 0; } /****************************三角形******************************/ struct Triangle{ Point p[3]; Triangle() {} Triangle(Point A, Point B, Point C); double area() const ; // 三角形面积 Circle outerCircle(); // 外接圆 }; Triangle::Triangle(Point A, Point B, Point C) { p[0] = A, p[1] = B, p[2] = C; } double Triangle::area() const { double ret = 0; for (int i = 0; i \u0026lt; 3; ++i) { ret += p[i] ^ p[(i + 1) % 3]; } return fabs(ret) / 2; } // r = a * b * c / 4S // 两条边的中垂线的交点，也可用kuangbin的方法，但此方法不需要再次调用Line的函数 Circle Triangle::outerCircle() { double A1 = 2.0 * (p[1].x - p[0].x), B1 = 2.0 * (p[1].y - p[0].y); double A2 = 2.0 * (p[2].x - p[1].x), B2 = 2.0 * (p[2].y - p[1].y); double C1 = 0, C2 = 0; for (int i = 0, j = 1, k = -1; i \u0026lt; 2; ++i, ++j, k = 1) { C1 += (p[i].x * p[i].x + p[i].y * p[i].y) * k; C2 += (p[j].x * p[j].x + p[j].y * p[j].y) * k; } double x = ((C1 * B2) - C2 * B1) / ((A1 * B2) - A2 * B1); double y = ((A1 * C2) - A2 * C1) / ((A1 * B2) - A2 * B1); return Circle(Point(x, y), (Point(x, y) - p[0]).len()); } /****************************多边形/点集******************************/ struct Polygon { vector\u0026lt;Point\u0026gt; p; // vector\u0026lt;Line\u0026gt; l; Polygon(){} Polygon(vector\u0026lt;Point\u0026gt;\u0026amp; p) : p(p) {}; double circum(); // 求凸包的周长 void graham(Polygon\u0026amp;); // 凸包 int PointAndPolygon(Point\u0026amp;); // 判断点与多边形的关系，0外 1内 2边上 3点上 double minRectCover(); // 最小矩形覆盖，自己必须是（逆时针）凸包才能调用 Circle minCircleCover(); // 点集的最小圆覆盖 }; double Polygon::circum() { int n = p.size(); if (n \u0026lt; 2) return 0.0; if (n == 2) return (p[0] - p[1]).len(); double ret = 0; for (int i = 0; i \u0026lt; n; ++i) { ret += (p[(i + 1) % n] - p[i]).len(); } return ret; } void Polygon::graham(Polygon\u0026amp; res) { int indx = 0, n = p.size(); for (int i = 1; i \u0026lt; n; ++i) if (p[i] \u0026lt; p[indx]) indx = i; swap(p[0], p[indx]); sort(p.begin() + 1, p.end(), [\u0026amp;](Point\u0026amp; i, Point\u0026amp; j) { int d = dcmp(atan2(i.y - p[0].y, i.x - p[0].x) - atan2(j.y - p[0].y, j.x - p[0].x)); if (d) return d \u0026lt; 0; return i.x \u0026lt; j.x; }); res.p.emplace_back(p[0]); if (n == 1) return; res.p.emplace_back(p[1]); if (n == 2) { if (p[0] == p[1]) res.p.pop_back(); return; } int x = res.p.size(); for (int i = 2; i \u0026lt; n; ++i, ++x) { while (x \u0026gt;= 2 \u0026amp;\u0026amp; dcmp((res.p[x - 2] - res.p[x - 1]) ^ (res.p[x - 2] - p[i])) \u0026lt;= 0) { --x; res.p.pop_back(); } res.p.emplace_back(p[i]); } if (res.p.size() == 2 \u0026amp;\u0026amp; (res.p[0] == res.p[1])) res.p.pop_back(); } Circle Polygon::minCircleCover() { random_shuffle(p.begin(), p.end()); Circle res(p[0], 0); int n = p.size(); for (int i = 1; i \u0026lt; n; ++i) { if (res.PointAndCircle(p[i])) continue; // 在圆内 res = Circle(p[i], 0); for (int j = 0; j \u0026lt; i; ++j) { if (res.PointAndCircle(p[j])) continue; // 在圆内 res = Circle((p[i] + p[j]) * 0.5, (p[i] - p[j]).len() * 0.5); for (int k = 0; k \u0026lt; j; ++k) { if (res.PointAndCircle(p[k])) continue; // 在圆内 res = Circle(p[i], p[j], p[k]); } } } return res; } vector\u0026lt;Point\u0026gt; vt; int main() { int t; while(scanf(\u0026#34;%d\u0026#34;, \u0026amp;t), t) { Point p; for (int i = 0; i \u0026lt; t; ++i) { p.init(); vt.emplace_back(p); } Polygon pol(vt), ans; pol.graham(ans); printf(\u0026#34;%.2f\\n\u0026#34;, ans.circum()); vt.clear(); } return 0; } ","date":"2021-07-27T20:45:06+08:00","permalink":"https://example.com/2021/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E6%9D%BF%E5%AD%90/","title":"计算几何板子"},{"content":"1. KMP 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // O(len + n) const int M = 1e6 + 5; // 下标都是从0开始 // nxt[i]表示第i位失配时，前nxt[i] - 1的不必再从新匹配了，即第i位前（不包括第i位）有nxt[i]长度与前缀相等 // 同时，求next数组可以想象成自己模式串自己匹配自己，即KMP的思想：在某个点失配时，证明前面的匹配的长度是已知的， // 利用该已知信息就得到了KMP算法，观察代码也能发现十分类似 // O(len) void getnext(char *x, int len, int *nxt) { int i = 0, j; j = nxt[0] = -1; while (i \u0026lt; len) { while(j != -1 \u0026amp;\u0026amp; x[i] != x[j]) j = nxt[j]; nxt[++i] = ++j; } } // y是主串 int nxt[M]; // 时间复杂度O(n)思考极端情况，每次匹配到最后一个才失配 int kmpCount(char *y, int n, char *x, int m) { // 返回匹配的个数，包含相交的 int i = 0, j = 0, ans = 0; getnext(x, m, nxt); while (i \u0026lt; n) { while (j != -1 \u0026amp;\u0026amp; y[i] != x[j]) j = nxt[j]; ++i, ++j; // i一直在增，没有往回走 if (j \u0026gt;= m) ++ans, j = nxt[j]; // 如果要不包含相交的，则此处j=0 } return ans; } 2. 字符串Hash 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 unsigned int DJBHash(const char *str) { unsigned int hash = 5381; while (*str) hash += (hash \u0026lt;\u0026lt; 5) + (*str++); return (hash \u0026amp; 0x7fffffff); //7个f } unsigned int BKDRHash(const char *str) { unsigned int seed = 131; // 31 131 1313 13131 131313... unsigned int hash = 0; while (*str) hash = hash * seed + (*str++); return (hash \u0026amp; 0x7fffffff); } ull strhash(const char *s) { ull seed = 1313, res = 0; // 31 131 1313 13131 while (*s) res = res * seed + (*s++); return res; } 3. 马拉车 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 string s,t; int p[maxn*2+5]; string init(string s){ t=\u0026#34;\u0026#34;; t.push_back(\u0026#39;$\u0026#39;); t.push_back(\u0026#39;#\u0026#39;); for(int i=0;i\u0026lt;s.size();i++){ t.push_back(s[i]); t.push_back(\u0026#39;$\u0026#39;); } t.push_back(\u0026#39;^\u0026#39;); return t; } int manacher(string s){ init(s); int id=0,mx=0; for(int i=1;i\u0026lt;t.size()-1;i++){ if(mx\u0026gt;i)p[i]=min(p[id*2-i],mx-i); else p[i]=1; for(;t[i+p[i]]==t[i-p[i]];p[i]++); if(p[i]+i\u0026gt;mx){ mx=p[i]+i; id=i; } } int res=p[0]-1; for(int i=0;i\u0026lt;t.size();i++)res=max(res,p[i]-1); return res; } 4. exkmp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 void pre_exkmp(char x[], int m, int next[]) { next[0] = m; int j = 0; while (j + 1 \u0026lt; m \u0026amp;\u0026amp; x[j] == x[j + 1]) j++; next[1] = j; int k = 1; for (int i = 2; i \u0026lt; m; i++) { int p = next[k] + k - 1; int L = next[i - k]; if (i + L \u0026lt; p + 1) next[i] = L; else { j = max(0, p - i + 1); while (i + j \u0026lt; m \u0026amp;\u0026amp; x[i + j] == x[j]) j++; next[i] = j; k = i; } } } void exkmp(char x[], int m, char y[], int n, int next[], int extend[]) { pre_exkmp(x, m, next); int j = 0; while (j \u0026lt; n \u0026amp;\u0026amp; j \u0026lt; m \u0026amp;\u0026amp; x[j] == y[j]) j++; extend[0] = j; int k = 0; for (int i = 1; i \u0026lt; n; i++) { int p = extend[k] + k - 1; int L = next[i - k]; if (i + L \u0026lt; p + 1) extend[i] = L; else { j = max(0, p - i + 1); while (i + j \u0026lt; n \u0026amp;\u0026amp; j \u0026lt; m \u0026amp;\u0026amp; y[i + j] == x[j]) j++; extend[i] = j; k = i; } } } 5. Trie 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int trie[M][30], ed[M], ram; void insert(char* s, int id) { int n = strlen(s), p = 0; for (int i = 0; i \u0026lt; n; ++i) { int c = s[i] - \u0026#39;a\u0026#39;; if (!trie[p][c]) trie[p][c] = ++ram; p = trie[p][c]; } ed[p] = id; } int search(char* s) { int n = strlen(s), p = 0; for (int i = 0; i \u0026lt; n; ++i) { int c = s[i] - \u0026#39;a\u0026#39;; if (!trie[p][c]) return -1; p = trie[p][c]; } return ed[p]; } ","date":"2021-07-27T20:43:47+08:00","permalink":"https://example.com/2021/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9D%BF%E5%AD%90/","title":"字符串板子"},{"content":"图论的时间复杂度计算方式：一般不是看每个点遍历时遍历了多少条边，因为这样想有时会陷入死循环的思维。有时可以这样想：从里到外分析，首先分析最内部几条操作每执行一次的时间复杂度，然后往外分析，其进入这些操作的实际次数。每条边被遍历多少遍，每个点被遍历多少遍，然后再看不同操作是受边的影响还是点的影响，最后再针对不同操作的时间复杂度乘上他的边或点的遍历次数，最后一般是取其中的最大值。\n例如分析dijkstra堆优化的时间复杂度，松弛操作的时间复杂度为$log$级别，然后思考是每条边被遍历后就松弛吗？显然不是，只有满足if条件的才会被松弛，即已经被计算出最短路的点不可能再进入if内，\n前置 存图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const int N = 1e5 + 10, M = 2e5 + 10; const int INF = 0x3f3f3f3f; int head[N], cnt; //初始化 void init(int n) { fill_n(head, n + 5, -1); cnt = -1; } struct edges { int to, next; int w; void add(int t, int n, int w) { to = t, next = n, this-\u0026gt;w = w; } }edge[N \u0026lt;\u0026lt; 1]; //无向图则需要乘2 inline void add(int u, int v, int w) { edge[++cnt].add(v, head[u], w); head[u] = cnt; } 1. 最短路 dijkstra 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 const int N = 1e5 + 5, inf = 0x3f3f3f3f; int dis[N], vis[N]; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; mp[N]; struct qnode{ int v; int w; qnode(int v = 0, int w = 0) : v(v), w(w) {} bool operator\u0026lt; (const qnode \u0026amp;t) const { return w \u0026gt; t.w; } }; // O(mlogn) void dij(int n, int s) {//n 为顶点数， m 为边数 for (int i = 0; i \u0026lt;= n; ++i) dis[i] = inf, vis[i] = 0; dis[s] = 0; priority_queue\u0026lt;qnode\u0026gt; heap; heap.push(qnode(s, dis[s])); while (heap.size()) { int u = heap.top().v; heap.pop(); if (vis[u]) continue; vis[u] = 1; for (auto [v, w] : mp[u]) { if (/* !vis[v] */ \u0026amp;\u0026amp; dis[u] + w \u0026lt; dis[v]) { //松弛 dis[v] = dis[u] + w; heap.push(qnode(v, dis[v])); } } } } bellman-ford 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 const int N = 1e5 + 10, M = 2e5 + 10, inf = 0x3f3f3f3f; int dis[N]; struct edges { int u, v, w; edges(int u = 0, int v = 0, int w = 0) : u(u), v(v), w(w) {} } edge[M]; bool bf(int n, int m, int s) { // n个点， m个边， s为起点 fill_n(dis, n + 1, inf); dis[s] = 0; for (int k = 1; k \u0026lt; n; k++) { int ok = 1; for (int i = 1; i \u0026lt;= m; i++) { if (dis[edge[i].v] \u0026gt; dis[edge[i].u] + edge[i].w) { //松弛 dis[edge[i].v] = dis[edge[i].u] + edge[i].w; ok = 0; } } if (ok) break; // 小优化，无松弛操作 } for (int i = 1; i \u0026lt;= m; i++) { if (dis[edge[i].v] \u0026gt; dis[edge[i].u] + edge[i].w) { return false; // 有负环 } } return true;// 无负环 } spfa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 const int N = 1e5 + 10, inf = 0x3f3f3f3f; int dis[N], num[N], head[N], cnt, inq[N]; //num 数组是判断是否有负环 vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; mp[N]; bool spfa(int n, int s) {// n个点， s为起点 for (int i = 0; i \u0026lt;= n; ++i) { dis[i] = inf, num[i] = inq[i] = 0; } queue\u0026lt;int\u0026gt; q; q.push(s); inq[s] = num[s] = 1, dis[s] = 0; while (q.size()) { int u = q.front(); q.pop(); inq[u] = 0; for (auto [v, w] : mp[u]) { if (dis[v] \u0026gt; dis[u] + w) { dis[v] = dis[u] + w; if (!inq[v]) { q.push(v); inq[v] = true, num[v]++; if (num[v] \u0026gt;= n) return false; //如果从1号点到x的最短路中包含至少n个点（不包括自己），则存在环 } } } } return true; // 无环 } floyd 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const int M = 2e2; int n, m; //顶点数和边数 int dis[M][M]; void floyd() { for (int k = 0; k \u0026lt; n; k++) { for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { if (dis[i][j] \u0026gt; dis[i][k] + dis[k][j]) { dis[i][j] = dis[i][k] + dis[k][j]; } } } } } void init() { memset(dis, 0x3f, sizeof dis); for (int i = 0; i \u0026lt; M; ++i) dis[i][i] = 0; } 2. 生成树 kruskal 适合稀疏图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #define ll long long using namespace std; #include \u0026lt;cctype\u0026gt; inline long long IO() {} //省略快读 const int M = 2e5 + 10, N = 5e5 + 5; int fa[M]; struct edges { int u, v; ll w; } e[N]; bool cmp(edges\u0026amp; i, edges\u0026amp; j) { return i.w \u0026lt; j.w; } int findset(int x) { return x == fa[x] ? x : fa[x] = findset(fa[x]); } bool un(int a, int b) { int fa1 = findset(a), fa2 = findset(b); if (fa1 == fa2) return false; fa[fa1] = fa2; return true; } ll kruskal(int n, int m) { sort(e, e + m, cmp); for (int i = 0; i \u0026lt;= n; ++i) fa[i] = i; int cnt = 0; ll ans = 0; for (int i = 0; i \u0026lt; m; ++i) { if (un(e[i].u, e[i].v)) { ans += e[i].w; if (++cnt == n - 1) break; } } return n - 1 == cnt ? ans : -1; } int main() { int n = IO(), m = IO(); for (int i = 0; i \u0026lt; m; ++i) e[i].u = IO(), e[i].v = IO(), e[i].w = IO(); printf(\u0026#34;%lld\\n\u0026#34;, kruskal(n, m)); return 0; } 3. tarjan 4. 网络流 Edmonds-Karp算法，速度较慢 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class EK { struct edges { int to, next; ll cap, flow;// flow为记录当前路径流的流量，cap为容量 }; vector\u0026lt;edges\u0026gt; e; static const ll inf = 1e18; vector\u0026lt;int\u0026gt; head, vis, pre;// vis记录是否在队内, pre记录前驱内存池编号 vector\u0026lt;ll\u0026gt; minc; // minc记录增广路的最小流 int n; // 点的个数 int bfs(int s, int t) { queue\u0026lt;int\u0026gt; q; for (int i = 0; i \u0026lt;= n; ++i) vis[i] = 0, pre[i] = -1; q.push(s), vis[s] = 1, minc[s] = inf;// 初始化minc为无穷大 while (q.size()) { int u = q.front(); q.pop(); for (int i = head[u]; ~i; i = e[i].next) { int v = e[i].to; if (vis[v] || e[i].cap == e[i].flow) continue; vis[v] = 1, pre[v] = i; minc[v] = min(minc[u], e[i].cap - e[i].flow);// 更新最小流 if (v == t) return 1;//找到了终点（汇点） q.push(v); } } return 0; } public: EK(int n = 0) { init(n); } void init(int n) { this-\u0026gt;n = n; e.clear(); head.resize(n + 1, -1); pre.resize(n + 1), vis.resize(n + 1), minc.resize(n + 1); } void add_edge(int u, int v, ll cap, int f = 1) { e.push_back({v, head[u], cap, 0}); head[u] = e.size() - 1; if (f) add_edge(v, u, 0, 0); } ll maxflow(int s, int t) { // 计算最大流 ll ans = 0, \u0026amp;dif = minc[t]; while (bfs(s, t)) { ans += dif; for (int i = pre[t]; ~i; i = pre[e[i ^ 1].to]) { e[i].flow += dif; // 正向边flow+ e[i ^ 1].flow -= dif; // 反向边flow- } } return ans; } void clearflow() { // 将流清空 for (auto\u0026amp; x : e) x.flow = 0; } }; dinic, 当前弧优化+多路增广优化+炸点优化(模板题),复杂度$O(n^2m)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 class Dinic { struct edges { int to, next; ll cap, flow;// flow为记录当前路径流的流量，cap为容量 }; vector\u0026lt;edges\u0026gt; e; static const ll inf = 1e18; vector\u0026lt;int\u0026gt; head, cur, deep; int n; // bfs求增广路，一次求出多条增广路 int bfs(int s, int t) { queue\u0026lt;int\u0026gt; q; for (auto\u0026amp; x : deep) x = 0; deep[s] = 1, q.push(s); while (q.size()) { int u = q.front(); q.pop(); for (int i = head[u]; ~i; i = e[i].next) { int v = e[i].to; if (deep[v] || e[i].cap == e[i].flow) continue; deep[v] = deep[u] + 1; q.push(v); } } return deep[t] != 0; } ll dfs(int u, int t, ll flow) { if (u == t) return flow; ll nowflow = 0; for (int i = cur[u]; ~i; i = e[i].next) { cur[u] = i;// 当前弧优化 int v = e[i].to; if (deep[v] != deep[u] + 1 || e[i].cap == e[i].flow) continue; if (ll low = dfs(v, t, min(flow - nowflow, e[i].cap - e[i].flow))) { e[i].flow += low, e[i ^ 1].flow -= low; nowflow += low;// 多路增广优化 if (nowflow == flow) break; } } if (!nowflow) deep[u] = -2;// 炸点优化 return nowflow; } public: Dinic(int n = 0) { init(n); } void init(int n) { this-\u0026gt;n = n; head.resize(n + 1, -1); deep.resize(n + 1); } void add_edge(int u, int v, ll cap, int f = 1) { e.push_back({v, head[u], cap, 0}); head[u] = e.size() - 1; if (f) add_edge(v, u, 0, 0); } ll maxflow(int s, int t) { ll ans = 0; while (bfs(s, t)) { cur = head;// 预处理，方便当前弧优化 ans += dfs(s, t, inf);// 进过多路增广优化可不用循环 } return ans; } void clearflow() { for (auto\u0026amp; x : e) x.flow = 0; } }; 最小费用最大流，将ek算法中的bfs换成spfa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class MCMF{ struct edges { int to, next; ll cap, cost, flow;;// flow为记录当前路径流的流量，cap为容量 }; vector\u0026lt;edges\u0026gt; e; static const ll inf = 1e15; vector\u0026lt;int\u0026gt; head, pre, inq; vector\u0026lt;ll\u0026gt; dist; int n; int spfa(int s, int t) {// 利用spaf找最小费用的路，即最短路 for (int i = 0; i \u0026lt;= n; ++i) inq[i] = 0, dist[i] = inf, pre[i] = -1; queue\u0026lt;int\u0026gt; q; inq[s] = 1, q.push(s), dist[s] = 0; while (q.size()) { int u = q.front(); q.pop(); inq[u] = 0; for (int i = head[u]; ~i; i = e[i].next) { int v = e[i].to; ll \u0026amp;cost = e[i].cost; if (dist[v] \u0026gt; dist[u] + cost \u0026amp;\u0026amp; e[i].cap \u0026gt; e[i].flow) { dist[v] = dist[u] + cost; pre[v] = i;//记录当前点的前驱的内存池编号 if (inq[v]) continue; inq[v] = 1 , q.push(v); } } } return pre[t] != -1;// 如果说t没有前驱则说明找不到增广路了 } public: MCMF(int n = 0) { init(n); } void add_edge(int u, int v, ll cap, ll cost, int f = 1) { e.push_back({v, head[u], cap, cost, 0}); head[u] = e.size() - 1; if (f) add_edge(v, u, 0, -cost, 0);// 建立反向弧，费用相反 } void init(int n) { this-\u0026gt;n = n; head.resize(n + 1, -1); pre.resize(n + 1), inq.resize(n + 1); dist.resize(n + 1); } pair\u0026lt;ll, ll\u0026gt; mcmf(int s, int t) { ll maxflow = 0, mincost = 0; while (spfa(s, t)) { ll low = inf; for (int i = pre[t]; ~i; i = pre[e[i ^ 1].to]) { low = min(low, e[i].cap - e[i].flow);//寻找最小流 } for (int i = pre[t]; ~i; i = pre[e[i ^ 1].to]) { e[i].flow += low; e[i ^ 1].flow -= low; mincost += low * e[i].cost; } maxflow += low; } return make_pair(maxflow, mincost); } void clearflow() { for (auto\u0026amp; x : e) x.flow = 0; } }; 5. 二分图 匈牙利算法，时间复杂度$O(ev)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int match[M]; bool vis[M]; bool dfs(int u) { for (int \u0026amp;v : gp[u]) { if (vis[v]) continue; vis[v] = true; if (!match[v] || dfs(match[v])) { match[u] = v, match[v] = u; return true; } } return false; } // 主函数里 fill_n(match, n + 1, 0); // n是点的个数 for (int i = 1; i \u0026lt;= n; ++i) { if (match[i]) continue; fill_n(vis, n + 1, false); dfs(i); } ","date":"2021-07-27T20:42:27+08:00","permalink":"https://example.com/2021/%E5%9B%BE%E8%AE%BA%E6%9D%BF%E5%AD%90/","title":"图论板子"},{"content":"1. 并查集 简便的路径压缩版 1 2 3 4 5 6 7 8 9 10 11 const int M = 1e5 + 10; int fa[M]; void init(int n) { for (int i = 0; i \u0026lt;= n; i++) fa[i] = i; } int findset(int x) { return x == fa[x] ? x : fa[x] = findset(fa[x]); } void unite(int a, int b) { fa[findset(a)] = findset(b); } 网络赛版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class UF { public: int n; // 当前连通分量数目 int cnt; vector\u0026lt;int\u0026gt; size; vector\u0026lt;int\u0026gt; parent; explicit UF(int _n): n(_n + 1), cnt(_n + 1), size(_n + 1, 1), parent(_n + 1) { iota(parent.begin(), parent.end(), 0); } int findset(int x) { return parent[x] == x ? x : parent[x] = findset(parent[x]); } bool unite(int x, int y) { x = findset(x); y = findset(y); if (x == y) { return false; } if (size[x] \u0026lt; size[y]) { swap(x, y); } parent[y] = x; size[x] += size[y]; --cnt; return true; } bool conn(int x, int y) { x = findset(x); y = findset(y); return x == y; } }; 2. 树状数组 单点修改与区间查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 修改复杂度与查询复杂度O(logn) template\u0026lt;class T\u0026gt; class fenwich { #define lowbit(x) ((x) \u0026amp; (-x)) vector\u0026lt;T\u0026gt; v; int len; T get_pre(int i) { T res = 0; for(; i \u0026gt; 0; i -= lowbit(i)) res += v[i]; return res; } public: fenwich (int len) : v(len + 1, 0), len(len) {} void resize(int n, T x = 0) { v.resize(n + 1, x), len = n; } void modify(int i, T val) { // 单点修改，用此函数建树 for (; i \u0026lt;= len \u0026amp;\u0026amp; i \u0026gt; 0; i += lowbit(i)) v[i] += val; } T get(int l, int r) { // 区间查询 if (l \u0026gt; r) return 0; return get_pre(r) - get_pre(l - 1); } #undef lowbit }; 区间修改，区间查询 设$d[i] = a[i] - a[i - 1]$ 则 $a[ x ] = \\sum_{i = 1}^{x}{d_i}$ 设 $sum[ x ] = \\sum_{i = 1}^{x}{a_i}$ 即 $sum[ x ] = d[1] + d[1] + d[2] + d[1] + d[2] + d[3] + …… + d[1] + ……+ d[n]$ 化简得 $sum[ x ] = \\sum_{i = 1}^{x}{d_i \\times (n - i + 1)}$ 得 $sum[ x ] = (n + 1) \\times \\sum_{i = 1}^{x}{d_i} - \\sum_{i = 1}^{x}{i \\times d_i}$ 固开两个树状数组，一个维护差分数组$d_i$，一个维护$i \\times d_i$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 template\u0026lt;class T\u0026gt; class Fenwich { #define lowbit(x) ((x) \u0026amp; (-x)) vector\u0026lt;T\u0026gt; d, id; int len; void update(int indx, T val, vector\u0026lt;T\u0026gt;\u0026amp; vt) { for (; indx \u0026lt;= len \u0026amp;\u0026amp; indx \u0026gt; 0; indx += lowbit(indx)) vt[indx] += val; } T get_pre(int indx, vector\u0026lt;T\u0026gt;\u0026amp; vt) { T res = 0; for (; indx \u0026gt; 0; indx -= lowbit(indx)) res += vt[indx]; return res; } public: Fenwich(int n) : d(n + 1, 0), id(n + 1, 0), len(n) {} void resize(int n, T x = 0) { d.resize(n + 1, 0), id.resize(n + 1, 0); len = n; } void modify(int l, int r, T val) { // 区间修改，单点修改和建树也调用此函数 update(l, val, d), update(r + 1, -val, d); update(l, val * l, id), update(r + 1, (-val) * (r + 1), id); } T get(int l, int r) { T res = get_pre(r, d) * (r + 1) - get_pre(r, id); res -= get_pre(l - 1, d) * l - get_pre(l - 1, id); return res; } #undef lowbit }; 3. 线段树 精简版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 // 宏 #define ls ((node) \u0026lt;\u0026lt; 1) #define rs (((node) \u0026lt;\u0026lt; 1) | 1) // 变量 const int N = 2e5 + 5; ll seg[N \u0026lt;\u0026lt; 2], lazy[N \u0026lt;\u0026lt; 2], arr[N]; // 操作 ll op(ll a, ll b) { return a + b; } // 题意不同，函数内部不同 void push_down(int l, int r, int node) { if (!lazy[node]) return; // 这里如果0也有意义的话多开一个数组标记 int mid = (l + r) \u0026gt;\u0026gt; 1; lazy[ls] += lazy[node], lazy[rs] += lazy[node]; seg[ls] += (mid - l + 1) * lazy[node]; seg[rs] += (r - mid) * lazy[node]; lazy[node] = 0; } // 初始化 void build(int l, int r, int node) { if (l == r) { seg[node] = arr[l]; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, ls), build(mid + 1, r, rs); seg[node] = op(seg[ls], seg[rs]); } // 单点修改 void update(int indx, ll v, int l, int r, int node) { if (l == r) { // 题意不同，这里更新操作不同 seg[node] = v; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (indx \u0026lt;= mid) update(indx, v, l, mid, ls); else update(indx, v, mid + 1, r, rs); seg[node] = op(seg[ls], seg[rs]); } // 区间修改 void update(int ql, int qr, ll v, int l, int r, int node) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) { // 题意不同，这里更新操作不同 lazy[node] += v; seg[node] += (r - l + 1) * v; return; } push_down(l, r, node); int mid = (l + r) \u0026gt;\u0026gt; 1; if (ql \u0026lt;= mid) update(ql, qr, v, l, mid, ls); if (qr \u0026gt; mid) update(ql, qr, v, mid + 1, r, rs); seg[node] = op(seg[ls], seg[rs]); } // 区间查找 ll get(int ql, int qr, int l, int r, int node) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return seg[node]; push_down(l, r, node); // 保证单点的情况下这句话可以注释掉 int mid = (l + r) \u0026gt;\u0026gt; 1; ll ret = 0; // 题意不同，初始化不同 if (ql \u0026lt;= mid) ret = get(ql, qr, l, mid, ls); if (qr \u0026gt; mid) ret = op(get(ql, qr, mid + 1, r, rs), ret); return ret; } #undef ls #undef rs 结构体版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int M = 1e6; typedef long long ll; template\u0026lt;class T\u0026gt; struct Tree{ #define ls(node) (node \u0026lt;\u0026lt; 1) #define rs(node) ((node \u0026lt;\u0026lt; 1) | 1) Tree(int len = 10): len(len) {} T sum[M \u0026lt;\u0026lt; 2], lazy[M \u0026lt;\u0026lt; 2], arr[M]; int len; private: void pushup(const int node) {// 写题目要求维护的代码，如求和，最大最小…… sum[node] = max(sum[ls(node)], sum[rs(node)]); } void pushdown(int l, int r, const int node) {//同pushup int mid = (l + r) \u0026gt;\u0026gt; 1; lazy[ls(node)] += lazy[node], lazy[rs(node)] += lazy[node]; sum[ls(node)] += (mid - l + 1) * lazy[node]; sum[rs(node)] += (r - mid) * lazy[node]; lazy[node] = 0; } void build(int l, int r, int node) { if (l == r) { sum[node] = arr[l]; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, ls(node)), build(mid + 1, r, rs(node)); pushup(node); } void update(int ql, int qr, T v, int l, int r, int node) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) { sum[node] += (r - l + 1) * v;//更新操作根据题目要求更改 lazy[node] += v; return; } if (lazy[node]) pushdown(l, r, node); int mid = (l + r) \u0026gt;\u0026gt; 1; if (ql \u0026lt;= mid) update(ql, qr, v, l, mid, ls(node)); if (qr \u0026gt; mid) update(ql, qr, v, mid + 1, r, rs(node)); pushup(node); } T getAsk(int ql, int qr, int l, int r, int node) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return sum[node];//上同 if (lazy[node]) pushdown(l, r, node); T res = 0; int mid = (l + r) \u0026gt;\u0026gt; 1; if (ql \u0026lt;= mid) res = getAsk(ql, qr, l, mid, ls(node)); if (qr \u0026gt; mid) res = max(res, getAsk(ql, qr, mid + 1, r, rs(node))); return res; } public: //以下为可以，直接调用的函数 void build() { build(1, len, 1); } void update(int ql, int qr, T v) { update(ql, qr, v, 1, len, 1); } void update(int index, T v) { update(index, index, v, 1, len, 1); } T getAsk(int ql, int qr) { return getAsk(ql, qr, 1, len, 1); } void clear() { memset(arr, 0, sizeof(T) * (len + 10)); memset(sum, 0, sizeof(T) * (len \u0026lt;\u0026lt; 2)); memset(lazy, 0, sizeof(T) * (len \u0026lt;\u0026lt; 2)); } T\u0026amp; operator[] (int x) { return arr[x]; } }; int main(){ return 0; } 类版-网络赛 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; /** * 使用说明： * 本线段树板子可用于多数 网络赛 * 需要注意的是此板子在性能方面由于三层封装，固较简洁版的线段树性能慢，但灵活性高（适合网络赛抢时间） * 使用时只需要修改 \u0026#34;可修改区的上下界\u0026#34; 中间的代码部分 * lazy使用结构体封装是应付在某些题目在区间修改时有两种操作，下面给的例题有示例 * vals是最终题目需要维护的东西（sum, max, min……），针对不同的操作只需修改结构体内的加法（+）操作即可 * 同时若题目需要区间修改，则直接修改区间修改部分的代码即可，单点修改同理 * 注意：区间修改针对不同的操作，lazy中的加等于（+=）也要具体根据题意修改 * 例题1：洛谷 */ /****************************可修改区上界******************************/ template\u0026lt;class T\u0026gt; struct lazy{ T lazy1; lazy(T lazy1 = 0){ this-\u0026gt;lazy1 = lazy1; } void operator+= (const lazy\u0026lt;T\u0026gt; \u0026amp;b) { this-\u0026gt;lazy1 += b.lazy1;//常见操作 } inline void del() { this-\u0026gt;lazy1 = 0; // 常见操作 } }; template\u0026lt;class T\u0026gt; struct vals{ T sum; //初始化构造，用来方便做运算的初始化- vals(int x = 0) { sum = x;//常见初始化，方便后面做 + 的操作 } // 操作区 constexpr vals operator+ (const vals\u0026amp; b){ vals res; res.sum = this-\u0026gt;sum + b.sum;//常见操作 return res; } //建树初始化区 inline void init(const T \u0026amp;v) { // this-\u0026gt;sum = v; // 常见操作，即和本身一样 } // 区间更新区 inline void update(const int \u0026amp;l, const int \u0026amp;r, const lazy\u0026lt;T\u0026gt; \u0026amp;v) { // this-\u0026gt;sum += (r - l + 1) * v.lazy1;// 常见操作 // printf(\u0026#34;%d %d %d %d\\n\u0026#34;, l, r, v, (r - l + 1) * v); // 常见操作 } // 单点更新区 inline void update(const lazy\u0026lt;T\u0026gt; \u0026amp;v) { // this-\u0026gt;sum += v; // 常见操作 } //初始化，通常在多组输入题时才调用 inline void del() { this-\u0026gt;sum = 0; } }; /****************************可修改区下界******************************/ /********************************以下区域建议不动（除特殊题目）*************************************/ template\u0026lt;class T\u0026gt; class segtree{ private: const static int maxn = 1e5 + 10; const int start = 1; struct lazy_tabs{ lazy\u0026lt;T\u0026gt; v; bool flag; lazy_tabs (bool flag = false) : flag(flag) {} // 懒标记更新 void update(const lazy\u0026lt;T\u0026gt; \u0026amp;v) { this-\u0026gt;v += v, flag = true; } // 懒标记删除 void del() { this-\u0026gt;v.del(), flag = false; } }lazy_tab[maxn \u0026lt;\u0026lt; 2]; vals\u0026lt;T\u0026gt; val[maxn \u0026lt;\u0026lt; 2]; //计算左右孩子节点下标 inline static constexpr int ls(const int \u0026amp;indx) { return indx \u0026lt;\u0026lt; 1;} inline static constexpr int rs(const int \u0026amp;indx) { return indx \u0026lt;\u0026lt; 1 | 1;} // 上放 inline void push_up(const int \u0026amp;pos) { val[pos] = val[ls(pos)] + val[rs(pos)]; } // 下放 void push_down(const int \u0026amp;l, const int \u0026amp;r, const int \u0026amp;pos) { if (!lazy_tab[pos].flag) return; // 若没有标记则返回 const auto \u0026amp;v = lazy_tab[pos].v; lazy_tab[ls(pos)].update(v), lazy_tab[rs(pos)].update(v); const int mid = (l + r) \u0026gt;\u0026gt; 1; val[ls(pos)].update(l, mid, v), val[rs(pos)].update(mid + 1, r, v); // 更新儿子节点 lazy_tab[pos].del(); } // 建树 void build(const int \u0026amp;l, const int \u0026amp;r, const int \u0026amp;pos, const T *a) { if (l == r) { val[pos].init(a[l]); return; } const int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, ls(pos), a), build(mid + 1, r, rs(pos), a); push_up(pos); } // 单点修改 void update(const int \u0026amp;indx, const int \u0026amp;l, const int \u0026amp;r, const lazy\u0026lt;T\u0026gt; \u0026amp;v, const int \u0026amp;pos) { if (l == r) { val[pos].update(v); return; } const int mid = (l + r) \u0026gt;\u0026gt; 1; if (indx \u0026lt;= mid) update(indx, l, mid, ls(pos)); else update(indx, mid + 1, r, rs(pos)); push_up(pos); } //区间修改 void update(const int \u0026amp;ql, const int \u0026amp;qr, const lazy\u0026lt;T\u0026gt; \u0026amp;v, const int \u0026amp;l, const int \u0026amp;r, const int \u0026amp;pos) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) { // 如果在查询区间内 lazy_tab[pos].update(v); //懒更新 val[pos].update(l, r, v); // 区间值更新 return; } push_down(l, r, pos); const int mid = (l + r) \u0026gt;\u0026gt; 1; if (ql \u0026lt;= mid) update(ql, qr, v, l, mid, ls(pos)); if (qr \u0026gt; mid) update(ql, qr, v, mid + 1, r, rs(pos)); push_up(pos); } //区间查询 vals\u0026lt;T\u0026gt; get(const int \u0026amp;ql, const int \u0026amp;qr, const int \u0026amp;l, const int \u0026amp;r, const int \u0026amp;pos) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return val[pos]; push_down(l, r, pos); vals\u0026lt;T\u0026gt; res; const int mid = (l + r) \u0026gt;\u0026gt; 1; if (ql \u0026lt;= mid) res = res + get(ql, qr, l, mid, ls(pos)); if (qr \u0026gt; mid) res = res + get(ql, qr, mid + 1, r, rs(pos)); return res; } public: /***********************一下均可调用****************************************/ int n; segtree (int n = -1) : n(n) {} // 建树 void build(T *a) { build(start, n, start, a); } // 查询 vals\u0026lt;T\u0026gt; get(int ql, int qr) { return get(ql, qr, start, n, start); } //单点修改 void update(int indx, lazy\u0026lt;T\u0026gt; val) { update(indx, start, n, val, start); } //区间修改 void update(int ql, int qr, lazy\u0026lt;T\u0026gt; val) { update(ql, qr, val, start, n, start); } //清空- // 切记，先用再清空，因为通常是多组输入时太调用 void clear() { assert(n != -1); int len = n \u0026lt;\u0026lt; 2; assert(n \u0026lt; maxn); for (int i = 1; i \u0026lt;= len; ++i) { lazy_tab[i].del(); val[i].del(); } } }; int main() { #ifndef ONLINE_JUDGE freopen(\u0026#34;D:/MYCODE/vsCode-c/test.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;D:/MYCODE/vsCode-c/test.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif return 0; } 4. ST表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const int M = 1e5 + 5; int st[M][30], lg[M]; // st表预处理, 注意下标从1开始到n结束 void init(int *a, int n) { lg[0] = -1; for (int i = 1; i \u0026lt;= n; ++i) lg[i] = lg[i \u0026gt;\u0026gt; 1] + 1, st[i][0] = a[i]; for (int j = 1; j \u0026lt;= lg[n]; ++j) { int k = 1 \u0026lt;\u0026lt; (j - 1); for (int i = 1; i + k - 1 \u0026lt;= n; ++i) { st[i][j] = max(st[i][j - 1], st[i + k][j - 1]); } } } // 询问 // 尽可能让l + 2^(len) - 1接近r int get(int l, int r) { int x = lg[r - l + 1]; return max(st[l][x], st[r - (1 \u0026lt;\u0026lt; x) + 1][x]); } 5. 分块 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const int N = 1e5 + 5, M = 500; #define ll long long ll a[N]; int belong[N]; struct blocks { int l, r; ll lazy; blocks() : lazy(0){} }b[M]; // 以下函数是基本不变的 void build(int n) { int siz = sqrt(n), cnt = n / siz; if (n % siz) ++cnt; for (int i = 1; i \u0026lt;= cnt; ++i) { b[i].l = (i - 1) * siz + 1; b[i].r = i * siz; } b[cnt].r = n; for (int i = 1; i \u0026lt;= n; ++i) belong[i] = (i - 1) / siz + 1; } 6. 莫队 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int M = 1e5 + 10; int n, m, block, arr[M], pos[M], ans[M], res; struct MO{ int l, r, k; MO(int l = 0, int r = 0, int k = 0) : l(l), r(r), k(k) {} }q[M]; bool cmp(MO a, MO b) { if (pos[a.l] ^ pos[b.l]) {//不在同一个块 return pos[a.l] \u0026lt; pos[b.l]; } if (pos[a.l] \u0026amp; 1) return a.r \u0026lt; b.r; return b.r \u0026lt; a.r; } void add(int x) { } void del(int x) { } void solve() { int l = 1, r = 0; for (int i = 0; i \u0026lt; m; i++) { while (l \u0026gt; q[i].l) add(--l); while (r \u0026lt; q[i].r) add(++r); while (l \u0026lt; q[i].l) del(l++); while (r \u0026gt; q[i].r) del(r--); ans[q[i].k] = res;//res根据题目意思来 } } void init() { scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); block = sqrt(n); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, arr + i); pos[i] = i / block; } for (int i = 0; i \u0026lt; m; i++) { int l, r; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;l, \u0026amp;r); q[i] = MO(l, r, i); } sort(q, q + m, cmp); } int main() { init(); solve(); return 0; } 7. 平衡树 fhq treap 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 // 洛谷板子题 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;random\u0026gt; #include \u0026lt;cctype\u0026gt; inline long long IO() {} using namespace std; const int N = 4e5 + 10; mt19937 rnd(233); struct treap{ int val, l, r, size, key; }fhq[N]; int root, cnt; inline void update(int now) { fhq[now].size = fhq[fhq[now].l].size + fhq[fhq[now].r].size + 1; } int new_node(int val) { fhq[++cnt] = {.val = val, .l = 0, .r = 0, .size = 1, .key = rnd()}; return cnt; } void split(int now, int val, int \u0026amp;x, int \u0026amp;y) { if (!now) { x = y = 0; return; } if (fhq[now].val \u0026lt;= val) x = now, split(fhq[now].r, val, fhq[now].r, y); else y = now, split(fhq[now].l, val, x, fhq[now].l); update(now); } int merge(int x, int y) { if (!x || !y) return x | y; // 大根堆 if (fhq[x].key \u0026gt; fhq[y].key) { //右下角 fhq[x].r = merge(fhq[x].r, y), update(x); return x; } // 左下角 fhq[y].l = merge(x, fhq[y].l), update(y); return y; } // 插入 inline void insert(int val) { int x, y; split(root, val, x, y); root = merge(merge(x, new_node(val)), y); } // 按值删除 inline void del(int val) { int x, y, z; split(root, val, x, z); split(x, val - 1, x, y); y = merge(fhq[y].l, fhq[y].r); root = merge(merge(x, y), z); } // 按值获取排名 inline int getrank(int val) { int x, y, ans; split(root, val - 1, x, y); ans = fhq[x].size + 1; root = merge(x, y); return ans; } // 按排名获取值 inline int getval(int rank) { int now = root; while (now) { if (fhq[fhq[now].l].size + 1 == rank) break; else if (fhq[fhq[now].l].size \u0026gt;= rank) now = fhq[now].l; else rank -= fhq[fhq[now].l].size + 1, now = fhq[now].r; } return fhq[now].val; } // 求前驱，即严格比val小的最大值 inline int pre(int val) { int x, y; split(root, val - 1, x, y); int now = x; while (fhq[now].r) now = fhq[now].r; root = merge(x, y); return fhq[now].val; } // 求后继，即严格比val大的最小值 inline int nxt(int val) { int x, y; split(root, val, x, y); int now = y; while (fhq[now].l) now = fhq[now].l; root = merge(x, y); return fhq[now].val; } int main() { int t = IO(); while (t--) { int q = IO(), val = IO(); if (q == 1) insert(val); else if (q == 2) del(val); else if (q == 3) printf(\u0026#34;%d\\n\u0026#34;, getrank(val)); else if (q == 4) printf(\u0026#34;%d\\n\u0026#34;, getval(val)); else if (q == 5) printf(\u0026#34;%d\\n\u0026#34;, pre(val)); else printf(\u0026#34;%d\\n\u0026#34;, nxt(val)); } return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 #include \u0026lt;memory\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;random\u0026gt; using namespace std; // typedef mt19937 rnd(233); template \u0026lt;typename T\u0026gt; struct Node { T v; int size, key, lazy; Node *l, *r; explicit Node (T v) : v(v), size(1), key(rnd()), lazy(0), l(0), r(0) {} Node (Node\u0026amp;\u0026amp; p) noexcept : v(p.v), size(p.size), key(p.key), lazy(p.lazy), l(p.l), r(p.r) { p.l = p.r = nullptr; } Node (const Node\u0026amp; p) : v(p.v), size(p.size), key(p.key), lazy(p.lazy), l(0), r(0) { if (p.l) l = new Node(*p.l); if (p.r) r = new Node(*p.r); } friend int sz(Node* x) { return x ? x-\u0026gt;size : 0; } void update () { size = sz(l) + sz(r) + 1; } void push_down() { if (lazy) { swap(l, r), lazy = 0; if (l) l-\u0026gt;lazy ^= 1; if (r) r-\u0026gt;lazy ^= 1; } } void split_by_val(T val, Node*\u0026amp; x, Node*\u0026amp; y) { this-\u0026gt;push_down(); if (v \u0026lt;= val) { x = this; if (r) r-\u0026gt;split_by_val(val, r, y); else r = y = nullptr; } else { y = this; if (l) l-\u0026gt;split_by_val(val, x, l); else x = l = nullptr; } this-\u0026gt;update(); } void split_by_size(int _size, Node*\u0026amp; x, Node*\u0026amp; y) { this-\u0026gt;push_down(); if (sz(l) \u0026lt; _size) { x = this; if (r) r-\u0026gt;split_by_size(_size - sz(l) - 1, r, y); else r = y = nullptr; } else { y = this; if (l) l-\u0026gt;split_by_size(_size, x, l); else x = l = nullptr; } update(); } friend Node* merge_node(Node* x, Node* y) { if (!x || !y) return x ? x : y; if (x-\u0026gt;key \u0026gt; y-\u0026gt;key) { x-\u0026gt;push_down(); x-\u0026gt;r = merge_node(x-\u0026gt;r, y), x-\u0026gt;update(); return x; } y-\u0026gt;push_down(); y-\u0026gt;l = merge_node(x, y-\u0026gt;l), y-\u0026gt;update(); return y; } void clear() { if (l) l-\u0026gt;clear(), delete l, l = nullptr; if (r) r-\u0026gt;clear(), delete r, r = nullptr; } void out(void (*print)(T v)) { push_down(); if (l) l-\u0026gt;out(print); print(v); if (r) r-\u0026gt;out(print); } ~Node() { clear(); } }; template \u0026lt;class T\u0026gt; Node\u0026lt;T\u0026gt;* build(const vector\u0026lt;T\u0026gt;\u0026amp; v, int l, int r) { if (l \u0026gt; r) return nullptr; if (l == r) return new Node\u0026lt;T\u0026gt;(v[r]); int mid = (l + r) \u0026gt;\u0026gt; 1; return merge_node(build(v, l, mid), build(v, mid + 1, r)); } int cnt = 0; template \u0026lt;class T\u0026gt; class treap { using node = Node\u0026lt;T\u0026gt;*; public: treap() : p(nullptr) {} explicit treap(const vector\u0026lt;T\u0026gt;\u0026amp; v) : p (build(v, 0, v.size() - 1)) {} explicit treap(node\u0026amp;\u0026amp; _p) : p(_p) { _p = nullptr; } treap(const treap\u0026amp; t) : p(nullptr) { if (t.p) p = new Node\u0026lt;T\u0026gt;(*t.p); } treap(treap\u0026amp;\u0026amp; t) noexcept : p(t.p) { t.p = nullptr; } friend void swap(treap\u0026amp; first, treap\u0026amp; second) noexcept { std::swap(first.p, second.p); } treap\u0026amp; operator=(treap other) { swap(*this, other); return *this; } int size() { return p ? p-\u0026gt;size : 0; } void split_by_val(T val, treap\u0026amp; x, treap\u0026amp; y) { x = y = nullptr; if (p != nullptr) { p-\u0026gt;split_by_val(val, x.p, y.p); if (p != x.p \u0026amp;\u0026amp; p != y.p) p = nullptr; } } void split_by_size(int size, treap\u0026amp; x, treap\u0026amp; y) { if (p != nullptr) { int del = (p != x.p \u0026amp;\u0026amp; p != y.p); p-\u0026gt;split_by_size(size, x.p, y.p); if (del) p = nullptr; } } treap merge(treap\u0026amp; t) { p = merge_node(p, t.p), t.p = nullptr; return *this; } friend treap merge(treap\u0026amp; x, treap\u0026amp; y) { treap ret; ret.p = merge_node(x.p, y.p), x.p = y.p = nullptr; return ret; } friend treap merge(treap\u0026amp;\u0026amp; x, treap\u0026amp; y) { treap ret; ret.p = merge_node(x.p, y.p), x.p = y.p = nullptr; return ret; } void insert(T val) { node x = NULL, y = NULL; if (p) p-\u0026gt;split_by_val(val, x, y); p = merge_node(merge_node(x, new Node\u0026lt;T\u0026gt;(val)), y); } void erase(T val) { // 没有特判树中没有的值 node x = NULL, y = NULL, z = NULL, tmp = NULL; if (p) p-\u0026gt;split_by_val(val, x, z); if (x) x-\u0026gt;split_by_val(val - 1, x, y); tmp = y, y = merge_node(y-\u0026gt;l, y-\u0026gt;r); if (tmp) delete tmp; p = merge_node(merge_node(x, y), z); } int get_rank(T val) { node x = NULL, y = NULL; if (p) p-\u0026gt;split_by_val(val - 1, x, y); int ret = sz(x) + 1; p = merge_node(x, y); return ret; } T get_val(int rank) { // 必须保证在范围内才可查 node now = p; while (now) { if (sz(now-\u0026gt;l) + 1 == rank) break; else if (sz(now-\u0026gt;l) \u0026gt;= rank) now = now-\u0026gt;l; else rank -= sz(now-\u0026gt;l) + 1, now = now-\u0026gt;r; } return now-\u0026gt;v; } // 求前驱，即严格比val小的最大值 T get_pre(T val) { // 必须要保证有前驱 node x = NULL, y = NULL; if (p) p-\u0026gt;split_by_val(val - 1, x, y); node now = x; // 否则x为nullptr while (now-\u0026gt;r) now = now-\u0026gt;r; p = merge_node(x, y); return now-\u0026gt;v; } // 求后继，即严格比val大的最小值 T get_next(T val) { // 必须要保证有后继 node x = NULL, y = NULL; if (p) p-\u0026gt;split_by_val(val, x, y); node now = y; // 否则y为nullptr while (now-\u0026gt;l) now = now-\u0026gt;l; p = merge_node(x, y); return now-\u0026gt;v; } void reverse() { if (p) p-\u0026gt;lazy ^= 1; } void out(void (*print)(T v) = nullptr) { if (print == nullptr) print = [](T v) { printf(\u0026#34;%d \u0026#34;, v); }; if (p) p-\u0026gt;out(print); putchar(\u0026#39;\\n\u0026#39;); } void clear() { if (p != nullptr) { p-\u0026gt;clear(); delete p, p = nullptr; } } ~treap() { if (p != nullptr) { p-\u0026gt;clear(); delete p, p = nullptr; } } private: node p; }; const int N = 2e5 + 5; treap\u0026lt;int\u0026gt; fhq[N]; void test03() { int n, m; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 0; i \u0026lt; n; ++i) { vector\u0026lt;int\u0026gt; v; int len, x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;len); for (int j = 0; j \u0026lt; len; ++j) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); v.push_back(x); } fhq[i] = treap\u0026lt;int\u0026gt;(v); } while (m--) { int x, y, h; scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;h); x -= 1, y -= 1; treap\u0026lt;int\u0026gt; tmp; fhq[x].split_by_size(h, tmp, fhq[x]); tmp.reverse(); fhq[y] = merge(tmp, fhq[y]); } for (int i = 0; i \u0026lt; n; ++i) fhq[i].out(); } void test02() { int n, m; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); vector\u0026lt;int\u0026gt; v; for (int i = 1; i \u0026lt;= n; ++i) { // fhq.insert(i); v.push_back(i); } auto fhq = treap\u0026lt;int\u0026gt;(v); // puts(\u0026#34;(bug 2)\u0026#34;); while (m--) { int l, r; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;l, \u0026amp;r); treap\u0026lt;int\u0026gt; x, y, z; fhq.split_by_size(r, y, z); y.split_by_size(l - 1, x, y); y.reverse(); fhq = merge(merge(x, y), z); } // fhq.out([](int x) { // printf(\u0026#34;{%d}\u0026#34;, x); // }); fhq.out(); // puts(\u0026#34;(bug 3)\u0026#34;); } void test01() { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); treap\u0026lt;int\u0026gt; p; // puts(\u0026#34;(bug 3)\u0026#34;); while (t--) { int q, val; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;q, \u0026amp;val); if (q == 1) p.insert(val); else if (q == 2) p.erase(val); else if (q == 3) printf(\u0026#34;%d\\n\u0026#34;, p.get_rank(val)); else if (q == 4) printf(\u0026#34;%d\\n\u0026#34;, p.get_val(val)); else if (q == 5) printf(\u0026#34;%d\\n\u0026#34;, p.get_pre(val)); else printf(\u0026#34;%d\\n\u0026#34;, p.get_next(val)); } // puts(\u0026#34;(bug 1)\u0026#34;); } auto main() -\u0026gt; int { #ifndef ONLINE_JUDGE freopen(\u0026#34;D:/MYCODE/vsCode-c/test.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;D:/MYCODE/vsCode-c/test.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif // test01(); // test02(); test03(); // int array_temp[100]; // int a = array_temp[200]; return 0; } spaly 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;climits\u0026gt; using namespace std; const int N = 1e5 + 5; template \u0026lt;class T\u0026gt; class BST { static constexpr T inf_max = INT_MAX, inf_min = -inf_max; // LLONG_MAX public: struct node { node *ch[2] = {NULL}, *p = NULL; int size, cnt, rev = 0; T val; void init(T v, node *fa) { p = fa, val = v, cnt = size = 1, ch[0] = ch[1] = NULL, rev = 0; } void clear() { val = cnt = size = rev = 0; if (this-\u0026gt;ch[0]) delete this-\u0026gt;ch[0], this-\u0026gt;ch[0] = NULL; if (this-\u0026gt;ch[1]) delete this-\u0026gt;ch[1], this-\u0026gt;ch[1] = NULL; } } *root = NULL; BST() { root=NULL, insert(inf_max), insert(inf_min); } ~BST() { clear(root); } private: #define sons(x, k) (x-\u0026gt;ch[k] ? x-\u0026gt;ch[k]-\u0026gt;size : 0) void push_up(node* x) { x-\u0026gt;size = sons(x, 0) + sons(x, 1) + x-\u0026gt;cnt; } void push_down(node *x) { if (x \u0026amp;\u0026amp; x-\u0026gt;rev) { swap(x-\u0026gt;ch[0], x-\u0026gt;ch[1]); if (x-\u0026gt;ch[0]) x-\u0026gt;ch[0]-\u0026gt;rev ^= 1; if (x-\u0026gt;ch[1]) x-\u0026gt;ch[1]-\u0026gt;rev ^= 1; x-\u0026gt;rev = 0; } } void rotate(node *x) { // 能进次函数，x必有父亲 node *y = x-\u0026gt;p, *z = y-\u0026gt;p; int k = x == y-\u0026gt;ch[1]; if (x-\u0026gt;ch[k ^ 1]) x-\u0026gt;ch[k ^ 1]-\u0026gt;p = y; if (z) z-\u0026gt;ch[y == z-\u0026gt;ch[1]] = x; y-\u0026gt;ch[k] = x-\u0026gt;ch[k ^ 1], x-\u0026gt;p = z, x-\u0026gt;ch[k ^ 1] = y, y-\u0026gt;p = x; push_up(y), push_up(x); } void splay(node *x, node *p) { // 将x放到p的儿子的位置 for (node *y = x-\u0026gt;p, *z = NULL; y != p; rotate(x), y = x-\u0026gt;p) { if ((z = y-\u0026gt;p) != p) rotate((y-\u0026gt;ch[1] == x) ^ (z-\u0026gt;ch[1] == y) ? x : y); } if (!p) root = x; } node* FindKth(int k) { // 寻找排第k的数 if (root-\u0026gt;size \u0026lt; k || k \u0026lt; 1) return NULL; node *u = root; while (u) { push_down(u); if (sons(u, 0) \u0026gt;= k) u = u-\u0026gt;ch[0]; else if (sons(u, 0) + u-\u0026gt;cnt \u0026gt;= k) return u; else k -= sons(u, 0) + u-\u0026gt;cnt, u = u-\u0026gt;ch[1]; } return NULL; } void output(node *u) { if (!u) return; push_down(u); output(u-\u0026gt;ch[0]); if (u-\u0026gt;val \u0026lt; inf_max \u0026amp;\u0026amp; u-\u0026gt;val \u0026gt; inf_min) printf(\u0026#34;%d \u0026#34;, u-\u0026gt;val); output(u-\u0026gt;ch[1]); } void clear(node *u) { if (u == NULL) return; clear(u-\u0026gt;ch[0]), clear(u-\u0026gt;ch[1]), u-\u0026gt;clear(); } public: node* pre_next(T val, int f) { // 0:pre , 1:next find(val); if (val \u0026lt; root-\u0026gt;val \u0026amp;\u0026amp; f) return root; if (root-\u0026gt;val \u0026lt; val \u0026amp;\u0026amp; !f) return root; node *u = root-\u0026gt;ch[f]; while (u-\u0026gt;ch[f ^ 1]) u = u-\u0026gt;ch[f ^ 1]; // splay(u, NULL); // 这里可以不用splay了，但如果找完之后需要查询排名，则可以直接splay，直接调用find_kth也行 return u; } node* find_range(T l, T r) { // 寻找值为[l,r]区间的结点 node *pre = pre_next(l, 0), *nxt = pre_next(r, 1); splay(pre, NULL), splay(nxt, pre); return nxt-\u0026gt;ch[0]; } int find(T val) { // 查找值为val 的值，找到则返回个数，否则返回0 node *u = root; while (u-\u0026gt;ch[u-\u0026gt;val \u0026lt; val] \u0026amp;\u0026amp; val != u-\u0026gt;val) u = u-\u0026gt;ch[u-\u0026gt;val \u0026lt; val]; splay(u, NULL); return u-\u0026gt;val == val ? u-\u0026gt;cnt : 0; } int insert(T val) { // 插入一个数，1表示新插入，0以前插入过 node *u = root, *p = NULL; while (u \u0026amp;\u0026amp; u-\u0026gt;val != val) p = u, u = u-\u0026gt;ch[u-\u0026gt;val \u0026lt; val]; if (u) u-\u0026gt;cnt += 1; else { u = new node, u-\u0026gt;init(val, p); if (p) p-\u0026gt;ch[p-\u0026gt;val \u0026lt; val] = u; } splay(u, NULL); return u-\u0026gt;cnt == 1; } void erase(T val, int all) { // all = 1 表示彻底删除值为val的，否则删除1个，必须保证val存在，否则空指针错误 node *del = find_range(val, val), *nxt = del-\u0026gt;p; if (del-\u0026gt;cnt \u0026gt; 1 \u0026amp;\u0026amp; !all) del-\u0026gt;cnt -= 1, splay(del, NULL); else delete nxt-\u0026gt;ch[0], nxt-\u0026gt;ch[0] = NULL; } node* find_kth(int k) { return FindKth(k + 1); } // 不包括负无穷，固找k+1 node* lower_bound(T val) { return pre_next(val - 1, 1); } node* upper_bound(T val) { return pre_next(val, 1); } int find_rank(T val) { // 看看val在树中的排名，有多个返回最小的排名 splay(pre_next(val - 1, 1), NULL); return root-\u0026gt;ch[0] ? root-\u0026gt;ch[0]-\u0026gt;size : 1; } void reverse(int l, int r) { node *L = find_kth(l - 1), *R = find_kth(r + 1); splay(L, NULL), splay(R, L); R-\u0026gt;ch[0]-\u0026gt;rev ^= 1; } void output() { output(root); } void clear() { clear(root), delete root, root = NULL; insert(inf_min), insert(inf_max); } #undef sons }; auto main() -\u0026gt; int { BST\u0026lt;int\u0026gt; tree; int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { int x = 0, val; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;x, \u0026amp;val); if (x == 1) tree.insert(val); else if (x == 2) tree.erase(val, 0); else if (x == 3) printf(\u0026#34;%d\\n\u0026#34;, tree.find_rank(val)); else if (x == 4) printf(\u0026#34;%d\\n\u0026#34;, tree.find_kth(val)-\u0026gt;val); else if (x == 5) printf(\u0026#34;%d\\n\u0026#34;, tree.pre_next(val, 0)-\u0026gt;val); else printf(\u0026#34;%d\\n\u0026#34;, tree.pre_next(val, 1)-\u0026gt;val); } return 0; } 8. 左偏树 9. 主席树 主席树（静态）洛谷模板题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cctype\u0026gt; inline long long IO() {} // 快读略 using namespace std; /*************************************离散化********************************************/ // vt存放可用于查询原本的数（用离散化值），打表后用于查询离散化表（用下标） vector\u0026lt;int\u0026gt; vt; inline int get_id(const int \u0026amp;x) { return lower_bound(vt.begin(), vt.end(), x) - vt.begin() + 1; } inline void erase_vt() { sort(vt.begin(), vt.end()); vt.erase(unique(vt.begin(), vt.end()), vt.end()); } // 打表, 注意，原数组下标要从1开始，返回离散化后的表大小 inline int id_table(int n, int *a, vector\u0026lt;int\u0026gt; \u0026amp;res) { res.emplace_back(0); for (int i = 1; i \u0026lt;= n; ++i) res.emplace_back(get_id(a[i])); return vt.size(); } /*************************************主席树********************************************/ const int N = 2e5 + 5; struct nodes{ int l, r, sum; nodes() : sum(0) {} }hjt[N \u0026lt;\u0026lt; 5]; int root[N], cnt; // 记录每个根结点的内存池编号， 内存池 int build(int l, int r) { int now = ++cnt; // 内存申请 if (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; hjt[now].l = build(l, mid); hjt[now].r = build(mid + 1, r); } return now; } // 插入新节点的操作 int update(int pre, int l, int r, int x) { int now = ++cnt; // 内存申请 hjt[now] = hjt[pre], ++hjt[now].sum; // 继承 if (l \u0026lt; r) { // 寻找拼接点 int mid = (l + r) \u0026gt;\u0026gt; 1; if (x \u0026lt;= mid) hjt[now].l = update(hjt[now].l, l, mid, x); // 如果x在左边，则让当前新节点的左孩子接继承后的左孩子 else hjt[now].r = update(hjt[now].r, mid + 1, r, x); // 否则同理 } return now; } // 返回第qr版本的主席树 - 第ql版本的主席树， 注意返回的是离散化后的值 int get(int ql, int qr, int l, int r, int k) { if (l == r) return l; int mid = (l + r) \u0026gt;\u0026gt; 1; int dif = hjt[hjt[qr].l].sum - hjt[hjt[ql].l].sum; if (k \u0026lt;= dif) return get(hjt[ql].l, hjt[qr].l, l, mid, k); // 左孩子上 return get(hjt[ql].r, hjt[qr].r, mid + 1, r, k - dif); // 右孩子上 } /*************************************主函数********************************************/ int a[N]; int main() { int n = IO(), m = IO(); for (int i = 1; i \u0026lt;= n; ++i) a[i] = IO(), vt.emplace_back(a[i]); erase_vt(); vector\u0026lt;int\u0026gt; id; int siz = id_table(n, a, id); root[0] = build(1, siz); for (int i = 1; i \u0026lt;= n; ++i) root[i] = update(root[i - 1], 1, siz, id[i]); while (m--) { int l = IO(), r = IO(), k = IO(); printf(\u0026#34;%d\\n\u0026#34;, vt[get(root[l - 1], root[r], 1, siz, k) - 1]); } return 0; } 10. LCA 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 // 洛谷板子题 // 注意，尽量让结点编号从1开始 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #define ll long long inline long long IO() {} // 快读略 using namespace std; const int maxn = 5e5 + 5, maxm = 5e5 + 5; const int INF = 0x3f3f3f3f; int head[maxn], cnt; struct edges { int to, next; void add(int t, int n) { to = t, next = n; } }edge[maxm \u0026lt;\u0026lt; 1]; //无向图则需要乘2 inline void add(int u, int v) { edge[++cnt].add(v, head[u]); head[u] = cnt; } int fa[maxn][35], dep[maxn], lg[maxn]; /* 另一种写法 void dfs(int u, int f) { deep[u] = deep[f] + 1; fa[u][0] = f; for (int i = 1; (1 \u0026lt;\u0026lt; i) \u0026lt;= deep[u]; ++i) fa[u][i] = fa[fa[u][i - 1]][i - 1]; for (int\u0026amp; v : mp[u]) { if (v ^ f) dfs(v, u); } } int lca(int a, int b) { if (deep[a] \u0026lt; deep[b]) swap(a, b); for (int i = 18; ~i; --i) if (deep[fa[a][i]] \u0026gt;= deep[b]) a = fa[a][i]; if (a == b) return a; for (int i = 20; ~i; --i) { if (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i]; } return fa[a][0]; } */ void dfs(int u, int f) { fa[u][0] = f; dep[u] = dep[f] + 1; for (int i = 1; i \u0026lt;= lg[dep[u]]; ++i) fa[u][i] = fa[fa[u][i - 1]][i - 1]; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v ^ f) dfs(v, u); } } void init(int root, int n) { // 通过检查代码，反向51行dep[root] = -1没意义，具体细节以后填这个坑 dep[root] = lg[0] = -1; memset(head, -1, sizeof head); cnt = 0; for (int i = 1; i \u0026lt;= n; ++i) lg[i] = lg[i \u0026gt;\u0026gt; 1] + 1; } int lca(int a, int b) { if (dep[a] \u0026lt; dep[b]) swap(a, b); while (dep[a] \u0026gt; dep[b]) a = fa[a][lg[dep[a] - dep[b]]]; if (a == b) return a; for (int i = lg[dep[a]]; ~i; --i) { if (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i]; } return fa[a][0]; } int main() { int n = IO(), m = IO(), root = IO(); init(root, n); for (int i = 1; i \u0026lt; n; ++i) { int u = IO(), v = IO(); add(u, v), add(v, u); } dfs(root, 0); while (m--) { int a = IO(), b = IO(); printf(\u0026#34;%d\\n\u0026#34;, lca(a, b)); } return 0; } 11. 树链剖分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 // 洛谷板子题,链的操作时间复杂度是O(nlognlogn) #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;bitset\u0026gt; using namespace std; #define ll long long const int N = 1e5 + 5, M = 2e5 + 5; const int maxn = 1e5 + 5, maxm = 2e5 + 5; const int INF = 0x3f3f3f3f; int head[maxn], cnt; //初始化 void init() { memset(head, -1, sizeof head); cnt = -1; } struct edges { int to, next; void add(int t, int n) { to = t, next = n; } }edge[maxm \u0026lt;\u0026lt; 1]; //无向图则需要乘2 inline void add(int u, int v) { edge[++cnt].add(v, head[u]); head[u] = cnt; } /*******************************树链剖分**********************************/ int fa[N], dep[N], siz[N], son[N]; void dfs1(int u, int f) { fa[u] = f, siz[u] = 1; dep[u] = dep[f] + 1; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == f) continue; dfs1(v, u); siz[u] += siz[v]; if (siz[v] \u0026gt; siz[son[u]]) son[u] = v; // 找重儿子 } } int v[N]; // 点上的权值 // top:当前节点所在链的顶端节点 int tim, dfn[N], top[N], w[N]; // w的下标是时间戳，对应的是相应时间戳上的点的点权 void dfs2(int u, int t) { dfn[u] = ++tim, top[u] = t; w[tim] = v[u]; if (!son[u]) return; dfs2(son[u], t); for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa[u] || v == son[u]) continue; dfs2(v, v); } } /*******************************线段树******************************/ inline int ls(const int\u0026amp; x) { return x \u0026lt;\u0026lt; 1;} inline int rs(const int\u0026amp; x) { return x \u0026lt;\u0026lt; 1 | 1;} ll seg[N \u0026lt;\u0026lt; 2], lazy[N \u0026lt;\u0026lt; 2], p; int n, m; inline ll op(const ll\u0026amp; a, const ll\u0026amp; b) { // seg[x] = max(seg[ls(x)], seg[rs(x)]); return (a + b) % p; } inline void push_down(const int\u0026amp; l, const int\u0026amp; r, const int\u0026amp; node) { if (!lazy[node]) return; lazy[ls(node)] += lazy[node], lazy[rs(node)] += lazy[node]; lazy[ls(node)] %= p, lazy[rs(node)] %= p; int mid = (l + r) \u0026gt;\u0026gt; 1; seg[ls(node)] = (lazy[node] * (mid - l + 1) + seg[ls(node)]) % p; seg[rs(node)] = (lazy[node] * (r - mid) + seg[rs(node)]) % p; lazy[node] = 0; } void build(int l, int r, int node = 1) { if (l == r) { seg[node] = w[l]; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, ls(node)), build(mid + 1, r, rs(node)); seg[node] = op(seg[ls(node)], seg[rs(node)]); } void update(int ql, int qr, ll x, int l = 1, int r = n, int node = 1) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) { lazy[node] = (lazy[node] + x) % p; seg[node] = (seg[node] + (r - l + 1) * x) % p; return; } push_down(l, r, node); int mid = (l + r) \u0026gt;\u0026gt; 1; if (ql \u0026lt;= mid) update(ql, qr, x, l, mid, ls(node)); if (qr \u0026gt; mid) update(ql, qr, x, mid + 1, r, rs(node)); seg[node] = op(seg[ls(node)], seg[rs(node)]); } int get(int ql, int qr, int l = 1, int r = n, int node = 1) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return seg[node]; push_down(l, r, node); int mid = (l + r) \u0026gt;\u0026gt; 1, res = 0; if (ql \u0026lt;= mid) res = get(ql, qr, l, mid, ls(node)); if (qr \u0026gt; mid) res = op(res, get(ql, qr, mid + 1, r, rs(node))); return res; } /********************************树上操作**********************************/ void update_chain(int x, int y, ll z) {// 将树从 x 到 y 结点最短路径上所有节点的值都加上 z。 while (top[x] != top[y]) { if (dep[top[x]] \u0026lt; dep[top[y]]) swap(x, y); update(dfn[top[x]], dfn[x], z); x = fa[top[x]]; } if (dep[x] \u0026gt; dep[y]) swap(x, y); update(dfn[x], dfn[y], z); } ll get_chain(int x, int y) {//求树从 x 到 y 结点最短路径上所有节点的值之和。 int res = 0; while (top[x] != top[y]) { if (dep[top[x]] \u0026lt; dep[top[y]]) swap(x, y); res = op(res, get(dfn[top[x]], dfn[x])); x = fa[top[x]]; } if (dep[x] \u0026gt; dep[y]) swap(x, y); return op(res, get(dfn[x], dfn[y])); } void update_son(int x, ll z) {// 将以 x 为根节点的子树内所有节点值都加上 z update(dfn[x], dfn[x] + siz[x] - 1, z); } ll get_son(int x) {// 求以 x 为根节点的子树内所有节点值之和 return get(dfn[x], dfn[x] + siz[x] - 1); } /********************************主函数************************************/ int main() { std::ios::sync_with_stdio(false); cout.tie(0), cin.tie(0); init(); int root; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; root \u0026gt;\u0026gt; p; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; v[i]; for (int i = 1; i \u0026lt; n; ++i) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; add(u, v), add(v, u); } dfs1(root, root), dfs2(root, root); build(1, n); while (m--) { int q, x, y, z; cin \u0026gt;\u0026gt; q \u0026gt;\u0026gt; x; if (q == 1) { cin \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z; update_chain(x, y, z % p); } else if (q == 2) { cin \u0026gt;\u0026gt; y; cout \u0026lt;\u0026lt; get_chain(x, y) \u0026lt;\u0026lt; endl; } else if (q == 3) { cin \u0026gt;\u0026gt; z; update_son(x, z); } else { cout \u0026lt;\u0026lt; get_son(x) \u0026lt;\u0026lt; endl; } } return 0; } 12. 树上点差分 设将树上两点u，v之间路径上的所有点权都增加val，lca为u和v的最近公共祖先，fa为lca的父亲，则树上差分为\n1 2 3 4 dif[u] += val; dif[v] += val; dif[lca] -= val; dif[fa] -= val; 后面求某子树的结点权值和就是该点的权值，初始化dif也可以用上面的步骤初始化，当然$O(n)$预处理也是可以的，$dif[ u ] = a[ u ] - \\sum a[ son ]$\n,其中son表示u结点的直接儿子\n13. dfs序 1 2 3 4 5 6 7 8 9 10 11 12 13 vector\u0026lt;int\u0026gt; mp[N]; ll val[N], valx[N]; int tim; pair\u0026lt;int, int\u0026gt; px[N]; void dfsx(int u, int fa) { px[u].first = ++tim; valx[tim] = val[u]; // 用valx存dfs序对应的val数组 for (int v : mp[u]) { if (v == fa) continue; dfsx(v, u); } px[u].second = tim; } 点修改，子树权值和查询：利用树状数组在dfs序上单点修改和区间查询 树链修改，点查询：利用树上差分思想，用树状数组在dfs序上单点修改和区间查询 树链修改，子树权值和查询：和利用树状数组实现区间修改和查询的思想是同理的 查询u子树权值和，对于其子结点son的贡献为：$val[ son ] \\times (dep[ son ] - dep[ u ] + 1)$ 拆括号： $val[ son ] \\times dep[ son ] - val[ son ] * (dep[ u ] - 1)$ u子树的权值和为 $\\sum_{v = start[ u ]}^{end[ u ]} val[ v ] \\times dep[ v ] - (dep[ u ] - 1) \\times \\sum_{ v = start[ u ]}^{end[ u ]} val[v]$ 维护两个数组：val[v] * dep[v] 和 val[v] 点修改，树链和查询：都这样了，上树剖吧 14.链表模拟 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 using namespace std; class Link { // 头结点：0，尾结点：1 public: Link() : l(2, 0), r(2, 0), val(2, 0), num(1) { r[0] = 1, l[1] = 0; } int insert(int i, int x) { // 在内存池编号为i的后面插入x，返回新的内存池编号 val.push_back(x); l.push_back(i), r.push_back(r[i]); l[r[i]] = ++num, r[i] = num; return num; } int erase(int i) { // 删除内存池标号为i的，返回其下一个内存池标号 l[r[i]] = l[i], r[l[i]] = r[i]; return r[i]; } public: vector\u0026lt;int\u0026gt; l, r, val; int num; }; ","date":"2021-07-27T20:40:18+08:00","permalink":"https://example.com/2021/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%BF%E5%AD%90/","title":"数据结构板子"},{"content":"1. gcd与lcm 1 2 3 4 5 typedef long long ll; //最大公因数，公约数 ll gcd(ll a, ll b, ll m = 1) { while(b) m = a % b, a = b, b = m; return a; } //最小公倍数 ll lcm(ll a, ll b) { return a / gcd(a, b) * b; } 2. ex_gcd 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* 通解为 x\u0026#39; = x + (b / gcd) * k y\u0026#39; = y - (a / gcd) * k */ typedef long long ll; // 扩展欧几里得算法核心函数 void exgcd(ll a, ll b, ll \u0026amp;g, ll \u0026amp;x, ll \u0026amp;y) { if (!b) { g = a, x = 1, y = 0; return; } exgcd(b, a % b, g, y, x); y -= x * (a / b); } /** * 此函数为 求解 ax + by = c * a b c为整数即可, y的解在函数外自求 * 返回 x的最小非负整数解 * 返回 -1 说明无解 */ ll minx(ll a, ll b, ll c) { ll x, y, g; exgcd(a, b, g, x, y); if (c % g != 0) return -1; ll t = abs(b / g); return (x * c / g % t + t) % t; // 返回最小非负整数解 } 3. 素数筛 埃式筛 1 2 3 4 5 6 7 8 9 10 11 12 13 const int M = 1e5 + 5; int pri[M], cnt = 0; bool isp[M]; // 复杂度O(nloglogn) // true 为非素数， false 为素数 void table_prime() { isp[0] = isp[1] = true; for (int i = 2; i \u0026lt; M; i++) { if (isp[i]) continue; pri[cnt++] = i; for (int j = i + i; j \u0026lt; M; j += i) isp[j] = true; } } 线性筛 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 复杂度O(n) const int M = 1e5 + 10; vector\u0026lt;int\u0026gt; pri; int minp[M]; // 存放x的最小素因子 void table(int n = 1e5) { // if x \u0026gt;= 2 \u0026amp;\u0026amp; minp[x] == x 则为素数 for (int i = 1; i \u0026lt;= n; ++i) minp[i] = i; for (int i = 2; i \u0026lt;= n; ++i) { if (minp[i] == i) pri.push_back(i); for (int p : pri) { if (p * i \u0026gt; n) break; minp[p * i] = p; if (i % p == 0) break; } } } 4. 逆元 线性版 1 2 3 4 5 6 7 8 typedef long long ll; // 时间复杂度O(n) void fny(const int \u0026amp;n, ll *inv, const ll mod) { inv[0] = inv[1] = 1; for (ll i = 2; i \u0026lt;= n; i++) { inv[i] =((mod - mod / i) * inv[mod % i]) % mod; } } 扩欧版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 typedef long long ll; void exgcd(ll a, ll b, ll \u0026amp;g, ll \u0026amp;x, ll \u0026amp;y) { if (!b) { g = a, x = 1, y = 0; return; } exgcd(b, a % b, g, y, x); y -= x * (a / b); } // ax=1(mod m) ll inverse(ll a, ll m) {//扩展欧几里得法求逆元，返回-1代表没有逆元 ll g, x, y; exgcd(a, m, g, x, y); return g == 1 ? (x % m + m) % m : -1; } 费马小定理版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //a ^ (p - 1) = 1 (mod p), p为素数 //a ^ (p - 2) = a ^ (-1) (mod p) //a 的逆元为 a ^ (p - 2) typedef long long ll; ll ksm(ll a, ll b, const ll mod = 1e9 + 7) {// 返回a^b % mod if (a == 0 \u0026amp;\u0026amp; b != 0) return 0; ll res = 1; for (a %= mod; b; b \u0026gt;\u0026gt;= 1, a = a * a % mod) if (b \u0026amp; 1) res = res * a % mod; return res; } ll inverse(ll a, ll m) { return ksm(a, m - 2, m); } 5. 快速幂 1 2 3 4 5 6 7 8 typedef long long ll; ll ksm(ll a, ll b, const ll mod = 1e9 + 7) {// 返回a^b % mod if (a == 0 \u0026amp;\u0026amp; b != 0) return 0; ll res = 1; for (a %= mod; b; b \u0026gt;\u0026gt;= 1, a = a * a % mod) if (b \u0026amp; 1) res = res * a % mod; return res; } 6. 矩阵快速幂 结构体版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 const ll MOD = 1e9 + 7; #define MO(x) ((x) % MOD) struct Mat { ll mat[10][10]; int n; // n * n 阶矩阵 Mat(int n = 2) : n(n) { memset(mat, 0, sizeof mat); }//记得修改 void to_one() { for (int i = 0; i \u0026lt; n; i++) mat[i][i] = 1; } Mat operator*(const Mat a) const { Mat res; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { ll sum = 0; for (int k = 0; k \u0026lt; n; k++) { sum += MO(this-\u0026gt;mat[i][k] * a.mat[k][j]); } res.mat[i][j] = MO(sum); } } return res; } ll *operator[](int x) { return mat[x]; } }; Mat pow_f(Mat a, ll b) { //a ^ b次幂 Mat ans; ans.to_one(); while (b) { if (b \u0026amp; 1) ans = ans * a; a = a * a; b \u0026gt;\u0026gt;= 1; } return ans; } vector重载运算符版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 using ll = long long; using vi = vector\u0026lt;ll\u0026gt;; using Mat = vector\u0026lt;vi\u0026gt;; const int X = 6; const ll mod = 1e9 + 7; Mat operator* (Mat a, Mat b) { Mat res(X, vi(X, 0)); for (int i = 0; i \u0026lt; X; ++i) for (int j = 0; j \u0026lt; X; ++j) for (int k = 0; k \u0026lt; X; ++k) res[i][j] = (res[i][j] + a[i][k] * b[k][j] % mod) % mod; return res; } // 要保证矩阵A不为0 Mat operator^ (Mat a, long long b) { Mat res(X, vi(X, 0)); for (int i = 0; i \u0026lt; X; ++i) res[i][i] = 1; while (b) { if (b \u0026amp; 1) res = res * a; a = a * a, b \u0026gt;\u0026gt;= 1; } return res; } 7. 高斯消元 高斯消元做多了会发现，容易被卡常，有几种解决办法，将vector换成数组，如果是异或高斯则可以用bitset优化，\n普通浮点数高斯消元，洛谷模板题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 // 洛谷模板题 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int N = 110; const double eps = 1e-6; // 用来控制进度 // 普通的高斯消元是将矩阵转化成上三角的形式，再回带求出答案 double ans[N]; // 用来记录答案 int gauss(int n, int m, vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; \u0026amp;a) { // n行m+1列增广矩阵，下标从0开始 int r, c; // r为当前行和c为当前列 for (r = c = 0; c \u0026lt; m \u0026amp;\u0026amp; r \u0026lt; n; ++ c) { int maxr = r; // 记录最大 for (int i = r + 1; i \u0026lt; n; ++i) if (abs(a[i][c]) \u0026gt; abs(a[maxr][c])) maxr = i; // 寻找从当前行开始向下走的当前列中的绝对值最大值 if (r ^ maxr) swap(a[r], a[maxr]); // 如果不是当前行，则交换两行 if (abs(a[r][c]) \u0026lt; eps) continue; // 如果当前行当前列的最大值为0则不作消元 for (int i = m; i \u0026gt;= c; --i) a[r][i] /= a[r][c]; // 将当前行的当前列开始到最后一列 for (int i = r + 1; i \u0026lt; n; ++i) { if (abs(a[i][c]) \u0026lt; eps) continue; // 如果改行的当前列已经是0，则不作消元 for (int j = m; j \u0026gt;= c; --j) { // 逆向消元，可以少开一个变量 a[i][j] -= a[r][j] * a[i][c]; } } ++r; } if (r \u0026lt; n) { // 无穷解 或者 无解 for (int i = r; i \u0026lt; n; ++r) if (abs(a[i][n]) \u0026lt; eps) return 0; return -1; // 无穷解 } for (int i = n - 1; ~i; --i) { // 回带 for (int j = i + 1; j \u0026lt; n; ++j) { a[i][n] -= a[i][j] * ans[j]; } ans[i] = a[i][n]; } return 1; // 唯一解 } vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; a; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 0; i \u0026lt; n; ++i) { a.push_back({}); for (int j = 0; j \u0026lt;= n; ++j) { double x; scanf(\u0026#34;%lf\u0026#34;, \u0026amp;x); a[i].push_back(x); } } if (gauss(n, n, a) == 1) { for (int i = 0; i \u0026lt; n; ++i) printf(\u0026#34;%.2f\\n\u0026#34;, ans[i]); } else puts(\u0026#34;No Solution\u0026#34;); return 0; } 浮点数高斯约旦消元法， 洛谷模板题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // 洛谷模板题 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const double eps = 1e-6; double ans[110]; // 记录答案 int gauss_j(int n, int m, vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; \u0026amp;a) { // n行m+1列增广矩阵，下标从0开始 int r, c; // r为当前行和c为当前列 for (r = c = 0; c \u0026lt; m \u0026amp;\u0026amp; r \u0026lt; n; ++c) { // int maxr = r; // 记录最大值 for (int i = r + 1; i \u0026lt; n; ++i) if (abs(a[i][c]) \u0026gt; abs(a[maxr][c])) maxr = i; // 寻找从当前行开始向下走的当前列中的绝对值最大值 if (maxr ^ r) swap(a[r], a[maxr]); // 交换两行 if (abs(a[r][c]) \u0026lt; eps) continue; // 如果为当前行中的当前列的值为0 for (int i = 0; i \u0026lt; n; ++i) { // 约旦消元 if (abs(a[i][c]) \u0026lt; eps || i == r) continue; // 如果是当前行或者改行的当前列已经是0 for (int j = m; j \u0026gt;= c; --j) a[i][j] -= a[i][c] / a[r][c] * a[r][j]; } ++r; } if (r \u0026lt; n) return 0; // 无解或者无穷解 for (int i = 0; i \u0026lt; n; ++i) ans[i] = a[i][n] / a[i][i]; // 回带 return 1; } vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; a; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 0; i \u0026lt; n; ++i) { a.push_back({}); for (int j = 0; j \u0026lt;= n; ++j) { double x; scanf(\u0026#34;%lf\u0026#34;, \u0026amp;x); a[i].push_back(x); } } if (gauss_j(n, n, a) == 1) { for (int i = 0; i \u0026lt; n; ++i) printf(\u0026#34;%.2f\\n\u0026#34;, ans[i]); } else puts(\u0026#34;No Solution\u0026#34;); return 0; } 模意义下的高斯消元法，POJ - 2065 SETI 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 // POJ - 2065 SETI #include \u0026lt;cassert\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int gcd(int a, int b) { int m; while(b) m = a % b, a = b, b = m; return a; } int lcm(int a, int b) { return a / gcd(a, b) * b; } int p, ans[310]; // 记录答案 typedef long long ll; ll ksm(ll a, ll b, const ll mod = 1e9 + 7) {// 返回a^b % mod if (a == 0 \u0026amp;\u0026amp; b != 0) return 0; ll res = 1; for (a %= mod; b; b \u0026gt;\u0026gt;= 1, a = a * a % mod) if (b \u0026amp; 1) res = res * a % mod; return res; } int inv(int a, int m) { return ksm(a, m - 2, m); } //模意义下的高斯消元不需要用约旦的方式，因为整数不用考虑精度问题 // n行m+1列增广矩阵，下标从0开始 int gauss(int n, int m, vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; \u0026amp;a, const int \u0026amp;p) { // 传入模p int r, c; // 当前行和当前列 for (r = c = 0; c \u0026lt; m \u0026amp;\u0026amp; r \u0026lt; n; ++c) { int maxr = r; // 记录最大值 for (int i = r + 1; i \u0026lt; n; ++i) if (abs(a[i][c]) \u0026gt; abs(a[maxr][c])) maxr = i; // 寻找当前列中从当前行开始的绝对值的最大值 if (maxr ^ r) swap(a[r], a[maxr]); // 交换两行 if (!a[r][c]) continue; // 如果为0 for (int i = r + 1; i \u0026lt; n; ++i) { if (!a[i][c]) continue; // 如果当前列中 改行已经为0 int LCM = lcm(abs(a[i][c]), abs(a[r][c])); int x = LCM / abs(a[i][c]), y = LCM / abs(a[r][c]); // 使该行乘x，当前行乘y使得他们在当前列的数都变成同一个数 if (a[i][c] * a[r][c] \u0026lt; 0) y = -y; // 如果有一个是负数 for (int j = c; j \u0026lt;= m; ++j) a[i][j] = ((a[i][j] * x - a[r][j] * y) % p + p) % p; } ++r; } for (int i = r; i \u0026lt; n; ++i) if (a[i][c]) return 0; // 无解 if (r \u0026lt; m) return -1; // 无穷解 for (int i = m - 1; ~i; --i) {// 回带 int tmp = a[i][m]; for (int j = i + 1; j \u0026lt; m; ++j) { if (!a[i][j]) continue; tmp -= ans[j] * a[i][j]; tmp = ((tmp % p) + p) % p; } ans[i] = tmp * inv(a[i][i], p) % p; // 求逆元可以换成别的方式求 } return 1; } vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; mat; char str[110]; int main() { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { mat.clear(); scanf(\u0026#34;%d %s\\n\u0026#34;, \u0026amp;p, str + 1); int n = strlen(str + 1); for (int i = 1; i \u0026lt;= n; ++i) { mat.push_back(vector\u0026lt;int\u0026gt;(n + 1, 0)); if (str[i] != \u0026#39;*\u0026#39;) mat[i - 1][n] = str[i] - \u0026#39;a\u0026#39; + 1; for (int j = 0; j \u0026lt; n; ++j) mat[i - 1][j] = ksm(i, j, p); } gauss(n, n, mat, p); for (int i = 0; i \u0026lt; n; ++i) printf(\u0026#34;%d \u0026#34;, ans[i]); puts(\u0026#34;\u0026#34;); } return 0; } 异或的高斯消元法（带解决自由变元的），POJ1681 Painter\u0026rsquo;s Problem 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 //POJ1681 Painter\u0026#39;s Problem #include \u0026lt;vector\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 305; int ans[N], freew[N]; // 记录答案和记录自由变元是哪些 //01矩阵，例如第一行为 a11 * x1 ^ a12 * x2 ^ ... ^ a1n * xn = y1的矩阵 // 初等行变换不再是某行加减某行，而是异或了 int gauss(int n, int m, vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; \u0026amp;a) { // n行m+1列增广矩阵，下标从0开始 int num = 0, r, c; // 自由变元的个数 当前行 当前列 for (int i = 0; i \u0026lt; n; ++i) ans[i] = freew[i] = 0; // 初始化答案和自由变元 for (r = c = 0; r \u0026lt; n \u0026amp;\u0026amp; c \u0026lt; m; ++c) { int maxr = r; // 记录最大值 for (int i = r + 1; i \u0026lt; n \u0026amp;\u0026amp; !a[maxr][c]; ++i) maxr = i; // 查找1 if (maxr ^ r) swap(a[r], a[maxr]); // 交换两行 if (!a[r][c]) {// 如果这个数是0， 则说明第c个变元是自由变元 freew[num++] = c; // 记录自由变元 continue; } for (int i = r + 1; i \u0026lt; n; ++i) { // 消元，消成一个上三角 if (!a[i][c]) continue; //如果该行的当前列是0则该行不作消元 for (int j = m; j \u0026gt;= c; --j) a[i][j] ^= a[r][j]; // 直接异或，和加法不同 } ++r; } for (int i = r; i \u0026lt; n; ++i) if (a[i][m]) return -1; // 无解 int cnt = 1 \u0026lt;\u0026lt; (n - r), ret = 1 \u0026lt;\u0026lt; 29; // 自由变元的取值方案数， 记录最小操作数 for (int i = 0; i \u0026lt; cnt; ++i) { // 状态压缩求解 int res = 0, indx = i; // 当前方案的最小操作数， 操作方案 for (int j = 0; j \u0026lt; num; ++j, indx \u0026gt;\u0026gt;= 1) { ans[freew[j]] = indx \u0026amp; 1; res += indx \u0026amp; 1; // 如果是1则说明这个地方需要操作，固操作数+1 } for (int j = r - 1; j \u0026gt;= 0; --j) { ans[j] = a[j][m]; // 记录答案 for (int k = j + 1; k \u0026lt; m; ++k) { if (a[j][k]) ans[j] ^= ans[k]; // 如果这个数的系数不为0 } res += ans[j]; // 增加操作数 } ret = min(res, ret); // 取最小值 } return ret; } vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; mat; int n; const int dx[] = {0, 1, 0, -1, 0}; const int dy[] = {0, 0, 1, 0, -1}; char g[30][30]; bool check(int r, int c) { return r \u0026gt;= 0 \u0026amp;\u0026amp; c \u0026gt;= 0 \u0026amp;\u0026amp; r \u0026lt; n \u0026amp;\u0026amp; c \u0026lt; n; } int main() {\tint _; scanf(\u0026#34;%d\u0026#34;, \u0026amp;_); for (int t = 1; t \u0026lt;= _; ++t) { mat.clear(); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); mat.resize(n * n, vector\u0026lt;int\u0026gt;(n * n + 1, 0)); for (int i = 0, r = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; n; ++j, ++r) { for (int k = 0; k \u0026lt; 5; ++k) { int nr = i + dx[k], nc = j + dy[k]; if (check(nr, nc)) mat[r][nr * n + nc] = 1; } } } for (int i = 0, r = 0; i \u0026lt; n; ++i) { scanf(\u0026#34;%s\u0026#34;, g[i]); for (int j = 0; j \u0026lt; n; ++j, ++r) { if (g[i][j] == \u0026#39;w\u0026#39;) mat[r][n * n] = 1; } } int res = gauss(n * n, n * n, mat); printf(\u0026#34;%d\\n\u0026#34;, res); } return 0; } 矩阵求逆，时间复杂度O($2 \\times n^3$)，洛谷板子题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 // 洛谷板子题 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; typedef long long ll; using namespace std; const long long mod = 1e9 + 7; ll ksm(ll a, ll b, const ll mod = 1e9 + 7) {// 返回a^b % mod if (a == 0 \u0026amp;\u0026amp; b != 0) return 0; ll res = 1; for (a %= mod; b; b \u0026gt;\u0026gt;= 1, a = a * a % mod) if (b \u0026amp; 1) res = res * a % mod; return res; } // 模意义下的高斯消元不需要用约旦的方式，因为整数不用考虑精度问题 // 利用高斯消元，剩下的是上三角，所以要倒过来回带 // n行n + n列增广矩阵，下标从0开始，求矩阵逆，被卡常尝试将vector换成数组 int gauss(int n, vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt;\u0026amp; a, vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt;\u0026amp; ans) { ans.resize(n, vector\u0026lt;ll\u0026gt;(n, 0)); for (int i = 0; i \u0026lt; n; ++i) ans[i][i] = 1; for (int i = 0; i \u0026lt; n; ++i) { for (int j = i + 1; j \u0026lt; n; ++j) { if (a[j][i]) { swap(a[j], a[i]); swap(ans[j], ans[i]); break; } } if (!a[i][i]) return -1; ll x = ksm(a[i][i], mod - 2, mod); for (int j = 0; j \u0026lt; n; ++j) { // 此行都乘1/a[i][i]，使得a[i][i] = 1 a[i][j] = a[i][j] * x % mod; ans[i][j] = ans[i][j] * x % mod; } for (int j = i + 1; j \u0026lt; n; ++j) { x = a[j][i]; // x为倍数即row_j - row_i * x for (int k = 0; k \u0026lt; n; ++k) { a[j][k] = ((a[j][k] - a[i][k] * x) % mod + mod) % mod; ans[j][k] = ((ans[j][k] - ans[i][k] * x) % mod + mod) % mod; } } } for (int i = n - 1; i \u0026gt;= 0; --i) { // 回带， for (int j = i + 1; j \u0026lt; n; ++j) {// 不知道为什么这样写快一些 ll x = a[i][j]; // row_i - row_j * x for (int k = 0; k \u0026lt; n; ++k) { a[i][k] = ((a[i][k] - a[j][k] * x) % mod + mod) % mod; ans[i][k] = ((ans[i][k] - ans[j][k] * x) % mod + mod) % mod; } } } return 1; } auto main() -\u0026gt; int { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; vt(n, vector\u0026lt;ll\u0026gt;(n, 0)); for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; n; ++j) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;vt[i][j]); } } vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; ans; int res = gauss(n, vt, ans); if (res \u0026lt; 0) return puts(\u0026#34;No Solution\u0026#34;), 0; for (auto\u0026amp; v : ans) { for (ll\u0026amp; x : v) { printf(\u0026#34;%lld \u0026#34;, x); } puts(\u0026#34;\u0026#34;); } return 0; } 8. 卢卡斯定理 lucas 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const ll mod = 10007;// 注意lucas算法，mod必须为质数 ll fac[mod + 10], inv[mod + 10]; void fny(const int \u0026amp;n, ll *inv, const ll mod) { fac[0] = fac[1] = inv[0] = inv[1] = 1; for (ll i = 2; i \u0026lt;= n; i++) { inv[i] =((mod - mod / i) * inv[mod % i]) % mod; fac[i] = fac[i - 1] * i % mod; } } ll comb(ll n, ll m) { if (m \u0026gt; n) return 0; return fac[n] * inv[fac[n - m] * fac[m] % mod] % mod; } ll lucas(ll n, ll m) { // 本函数不考虑comb的时间复杂度的话就是O(logmod) if (m == 0) return 1; if (n \u0026lt; mod) return comb(n, m); return comb(n % mod, m % mod) * lucas(n / mod, m / mod) % mod; } exlucas 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 ll ksm(ll a, ll b, const ll mod = 1e9 + 7) {// 返回a^b % mod if (a == 0 \u0026amp;\u0026amp; b != 0) return 0; ll res = 1; for (a %= mod; b; b \u0026gt;\u0026gt;= 1, a = a * a % mod) if (b \u0026amp; 1) res = res * a % mod; return res; } void exgcd(ll a, ll b, ll \u0026amp;g, ll \u0026amp;x, ll \u0026amp;y) { if (!b) { g = a, x = 1, y = 0; return; } exgcd(b, a % b, g, y, x); y -= x * (a / b); } // ax=1(mod m) ll inverse(ll a, ll m) {//扩展欧几里得法求逆元，返回-1代表没有逆元 ll g, x, y; exgcd(a, m, g, x, y); return g == 1 ? (x % m + m) % m : -1; } ll crt(ll *a, ll *b, int n) {// x % b[i] = a[i], 返回最小的x， b[i]中互质， O(nlogn) ll mul = 1, ret = 0; for (int i = 0; i \u0026lt; n; ++i) mul *= b[i]; for (int i = 0; i \u0026lt; n; ++i) { ll minlcm = mul / b[i]; ll inv = inverse(minlcm, b[i]); // 求逆元 ret = (ret + minlcm * inv * a[i]) % mul; } return (ret + mul) % mul; } ll cal(ll n, ll p, ll pk) { // 计算n!中取出所有p因子后mod pk的结果 if (n == 0) return 1; ll res = 1; for (int i = 1; i \u0026lt; pk; ++i) { if (i % p) res = res * i % pk; } res = ksm(res, n / pk, pk); int len = n % pk; for (int i = 1; i \u0026lt;= len; ++i) { if (i % p) res = res * i % pk; } return res * cal(n / p, p, pk) % pk; } ll comb(ll n, ll m, ll p, ll pk) {// 计算C(n, m) % pk的结果，其中p^k = pk if (n \u0026lt; m) return 0; ll up = cal(n, p, pk), down = cal(m, p, pk) * cal(n - m, p, pk) % pk, cnt = 0; for (ll i = n; i; i /= p) cnt += i / p; for (ll i = m; i; i /= p) cnt -= i / p; for (ll i = n - m; i; i /= p) cnt -= i / p; return up * inverse(down, pk) % pk * ksm(p, cnt, pk) % pk; } //直接调用此函数即可 ll exlucas(ll n, ll m, ll p) { // 计算C(n, m) % p，其中p不为质数 ll b[50], a[50], len = 0, tmp = p; for (ll i = 2; i * i \u0026lt;= tmp; ++i) { if (tmp % i) continue; b[len] = 1; while (tmp % i == 0) b[len] *= i, tmp /= i; a[len] = comb(n, m, i, b[len]); len += 1; } if (tmp \u0026gt; 1) b[len] = tmp, a[len] = comb(n, m, tmp, tmp), len += 1; return crt(a, b, len); } 9. 线性基 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 struct LB { using ll = long long; ll d[65], cnt, num; // cnt 原序列的个数， num 基的个数 bool re; LB () : cnt(0), num(0), re(false) { memset(d, 0, sizeof d); } // 添加一个数x void add(ll x) { ++cnt; for (int i = 60; ~i \u0026amp;\u0026amp; x; --i) { if ((x \u0026gt;\u0026gt; i) \u0026amp; 1) { if (d[i]) x ^= d[i]; else d[i] = x, x = 0, ++num, re = 0; } } } // 询问是否能异或出x bool check(ll x) { for (int i = 60; ~i \u0026amp;\u0026amp; x; --i) { if ((x \u0026gt;\u0026gt; i) \u0026amp; 1) { if (d[i]) x ^= d[i]; else return true; } } return false; } ll get_max() { ll res = 0; for (int i = 60; ~i; --i) { if ((d[i] ^ res) \u0026gt; res) res ^= d[i]; } return res; } // 求的是线性基的异或最小值，不是原序列，否则要特判是否为0 ll get_min() { for (int i = 0; i \u0026lt;= 60; ++i) { if (d[i]) return d[i]; } } void rebuild() { for (int i = 0; i \u0026lt;= 60; ++i) { for (int j = 0; j \u0026lt; i; ++j) { if ((d[i] \u0026gt;\u0026gt; j) \u0026amp; 1) { d[i] ^= d[j]; } } } re = true; } ll k_th(ll k) { if (!re) rebuild(); if (k == 1 \u0026amp;\u0026amp; num \u0026lt; cnt) return 0; // 如果异或得到0 if (num \u0026lt; cnt) --k; ll res = 0; for (int i = 0; i \u0026lt;= 60; ++i) { if (d[i]) { if (k \u0026amp; 1) res ^= d[i]; k \u0026gt;\u0026gt;= 1; } } return res; } }; 10. 中国剩余定理 Crt 1 2 3 4 5 6 7 8 9 10 ll crt(ll *a, ll *b, int n) {// x % b[i] = a[i], 返回最小的x， b[i]中互质， O(nlogn) ll mul = 1, ret = 0; for (int i = 0; i \u0026lt; n; ++i) mul *= b[i]; for (int i = 0; i \u0026lt; n; ++i) { ll minlcm = mul / b[i]; ll inv = inverse(minlcm, b[i]); // 求逆元 ret = (ret + minlcm * inv * a[i]) % mul; } return (ret + mul) % mul; } ExCrt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ll mul(ll a, ll b, ll p) { // 快速乘 if (a \u0026gt;= p) a %= p; if (b \u0026gt;= p) b %= p; if (p \u0026lt;= 1000000000) return a * b % p; if (p \u0026lt;= 1000000000000ll) return (((a * (b \u0026gt;\u0026gt; 20) % p) \u0026lt;\u0026lt; 20) + (a * (b \u0026amp; ((1 \u0026lt;\u0026lt; 20) - 1)))) % p; ll d = (ll)floor(a * (long double)b / p + 0.5); ll ret = (a * b - d * p) % p; if (ret \u0026lt; 0) ret += p; return ret; } void exgcd(ll a, ll b, ll \u0026amp;g, ll \u0026amp;x, ll \u0026amp;y) { if (!b) { g = a, x = 1, y = 0; return; } exgcd(b, a % b, g, y, x); y -= x * (a / b); } ll excrt(ll *a, ll *b, int n) {// x % b[i] = a[i], 返回最小的x，下标从0开始 ll res = a[0], minlcm = b[0], x, y, g; for (int i = 1; i \u0026lt; n; ++i) { ll c = (a[i] - res % b[i] + b[i]) % b[i]; exgcd(minlcm, b[i], g, x, y); if (c % g != 0) return -1; // 无解 x = mul(x, c / g, b[i] / g);// 快速乘 res += x * minlcm; minlcm *= b[i] / g; res = (res % minlcm + minlcm) % minlcm; } return (res % minlcm + minlcm) % minlcm; } 11. 欧拉函数 求单个数的欧拉函数 1 2 3 4 5 6 7 8 9 10 11 int euler_phi(int n) { int ans = n; for (int i = 2; i * i \u0026lt;= n; ++i) { if (n % i == 0) { ans = ans / i * (i - 1); while (n % i == 0) n /= i; } } if (n \u0026gt; 1) ans = ans / n * (n - 1); return ans; } 线性复杂度O(n) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const int M = 1e6 + 5; int phi[M], minp[M]; vector\u0026lt;int\u0026gt; pri; void table_phi(int n = 1e5) { for (int i = 1; i \u0026lt;= n; ++i) minp[i] = i; phi[1] = 1; for (int i = 2; i \u0026lt;= n; ++i) { if (minp[i] == i) pri.push_back(i), phi[i] = i - 1; for (int p : pri) { if (i * p \u0026gt; n) break; minp[i * p] = p; if (i % p == 0) { phi[i * p] = p * phi[i]; break; } phi[i * p] = (p - 1) * phi[i]; } } } 12. 求组合数 递推版，针对取余p为质数（如果有的话），且m较小的情况,O(m) 1 2 3 4 5 6 ll comb(ll n, ll m) { if (n \u0026lt; m) return 0; ll ret = 1; for (int i = 1; i \u0026lt;= m; ++i) ret = ret * (n - i + 1) / i; return ret; } 素因子版，针对取余p不为质数，其n较小的情况，O(nlogn) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 计算分子分母的素数个数差来计算结果O(nlogn),需要用到质数表，和快速幂，cnt为质数个数 // 求C(n, m) % p的结果，其中n, m \u0026lt;= 1e6, p \u0026lt;= 1e9，注意，要打出小于n的所有质数 // p 理论上可以很大，但过大就可能需要快速乘了 ll comb(int n, int m, int p) { if (n \u0026lt; m) return 0; ll res = 1; for (int i = 0; i \u0026lt; cnt \u0026amp;\u0026amp; pri[i] \u0026lt;= n; ++i) { int num = 0; for (int j = n; j; j /= pri[i]) num += j / pri[i]; for (int j = m; j; j /= pri[i]) num -= j / pri[i]; for (int j = n - m; j; j /= pri[i]) num -= j / pri[i]; res = res * ksm(pri[i], num, p) % p; } return res % p; } ​\n13. FFT 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 template \u0026lt;class T\u0026gt; class Poly {// 时间复杂度O(nlogn), 若被卡常，可尝试手写复数 #define cpd complex\u0026lt;double\u0026gt; constexpr static double PI = acos(-1.0); vector\u0026lt;int\u0026gt; rev; void fft(vector\u0026lt;cpd\u0026gt;\u0026amp; vc, int opt, int n) { // opt=1:FFT(系数式-\u0026gt;点值式), opt=-1:IFFT for (int i = 0; i \u0026lt; n; ++i) if (i \u0026lt; rev[i]) swap(vc[i], vc[rev[i]]); // 位逆序置换 for (int h = 2; h \u0026lt;= n; h \u0026lt;\u0026lt;= 1) { // 蝴蝶操作 cpd wn(cos(PI * 2 / h), sin(PI * 2 / h) * opt); // 主n次单位根 for (int j = 0; j \u0026lt; n; j += h) { cpd w(1, 0); for (int k = j; k \u0026lt; j + h / 2; ++k, w *= wn) { cpd tmp = w * vc[k + h / 2], u = vc[k]; vc[k] = u + tmp, vc[k + h / 2] = u - tmp; } } } if (opt == 1) return; for (int i = 0; i \u0026lt; n; ++i) vc[i].real(vc[i].real() / n); } public: vector\u0026lt;T\u0026gt; result; // 用来存最后的答案 void convolution(const vector\u0026lt;T\u0026gt;\u0026amp; a, const vector\u0026lt;T\u0026gt; \u0026amp;b) { // 传入a和b两个多项式，是int就int int Alen = a.size(), Blen = b.size(), m = 1, n = 2; while (n \u0026lt; Alen + Blen) n \u0026lt;\u0026lt;= 1, m += 1; vector\u0026lt;cpd\u0026gt; A(n, cpd(0, 0)), B(n, cpd(0, 0)); rev.resize(1, 0), result.clear(); for (int i = 1; i \u0026lt; n; ++i) rev.push_back((rev[i \u0026gt;\u0026gt; 1] \u0026gt;\u0026gt; 1) | (i \u0026amp; 1) \u0026lt;\u0026lt; (m - 1)); for (int i = 0; i \u0026lt; n; ++i) { if (i \u0026lt; Alen) A[i].real(a[i]); if (i \u0026lt; Blen) B[i].real(b[i]); } fft(A, 1, n), fft(B, 1, n); for (int i = 0; i \u0026lt; n; ++i) A[i] *= B[i]; fft(A, -1, n); // 根据题意自己改最后要的是什么 for (int i = 0; i \u0026lt; Alen + Blen - 1; ++i) result.push_back(round(A[i].real())); } #undef cpd }; 14. FNTT 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 typedef long long ll; ll ksm(ll a, ll b, const ll mod = 1e9 + 7) {// 返回a^b % mod if (a == 0 \u0026amp;\u0026amp; b != 0) return 0; ll res = 1; for (a %= mod; b; b \u0026gt;\u0026gt;= 1, a = a * a % mod) if (b \u0026amp; 1) res = res * a % mod; return res; } template \u0026lt;class T\u0026gt; class Poly { // 被卡常就用int+重写模数乘吧 vector\u0026lt;int\u0026gt; rev; constexpr static ll g = 3, gi = 332748118, mod = 998244353; // g * gi % mod = 1 void ntt(vector\u0026lt;ll\u0026gt;\u0026amp; vt, int opt, int n) { // opt=1:FFT, opt=-1:IFFT for (int i = 0; i \u0026lt; n; ++i) if (i \u0026lt; rev[i]) swap(vt[i], vt[rev[i]]); // 位逆序置换 for (int i = 1; i \u0026lt; n; i \u0026lt;\u0026lt;= 1) { ll gn = ksm(opt ? g : gi, (mod - 1) / (i \u0026lt;\u0026lt; 1), mod); // 单位原根 for (int j = 0; j \u0026lt; n; j += (i \u0026lt;\u0026lt; 1)) { ll g0 = 1; for (int k = 0; k \u0026lt; i; ++k, g0 = g0 * gn % mod) { ll u = vt[j + k], tmp = g0 * vt[i + j + k] % mod; vt[j + k] = (u + tmp) % mod; vt[i + j + k] = (u - tmp + mod) % mod; } } } } public: vector\u0026lt;T\u0026gt; result; // 用来存最后的答案 void convolution(const vector\u0026lt;T\u0026gt;\u0026amp; a, const vector\u0026lt;T\u0026gt; \u0026amp;b) { // 传入a和b两个多项式 int Alen = a.size(), Blen = b.size(), m = 1, n = 2; while (n \u0026lt; Alen + Blen) n \u0026lt;\u0026lt;= 1, m += 1; vector\u0026lt;ll\u0026gt; A(n, 0), B(n, 0); rev.resize(1, 0), result.clear(); for (int i = 1; i \u0026lt; n; ++i) rev.push_back((rev[i \u0026gt;\u0026gt; 1] \u0026gt;\u0026gt; 1) | (i \u0026amp; 1) \u0026lt;\u0026lt; (m - 1)); for (int i = 0; i \u0026lt; n; ++i) { if (i \u0026lt; Alen) A[i] = (a[i] + mod) % mod; if (i \u0026lt; Blen) B[i] = (b[i] + mod) % mod; } ntt(A, 1, n), ntt(B, 1, n); for (int i = 0; i \u0026lt; n; ++i) A[i] = A[i] * B[i] % mod; ntt(A, 0, n); ll inv = ksm(n, mod - 2, mod); for (int i = 0; i \u0026lt; Alen + Blen - 1; ++i) result.push_back(A[i] * inv % mod); } }; 15. 分治FFT 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 //给g[1~n], f[0] = 1, f[i] = sum{ f[i - j] * g[j] }, 求f[0~n], template \u0026lt;class T\u0026gt; class PolyDivide { // 传入的g[0]可设为0 vector\u0026lt;T\u0026gt; g; Poly\u0026lt;T\u0026gt; poly; constexpr static ll mod = 998244353; // 一般都是这个模数 void cdq(int l, int r) { if (l == r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; cdq(l, mid); vector\u0026lt;T\u0026gt; a(result.begin() + l, result.begin() + mid + 1); // 取f函数的[l, mid]范围的数 vector\u0026lt;T\u0026gt; b(g.begin(), g.begin() + r - l + 1); // 去 g函数的 [0, r - l]范围的数 poly.convolution(a, b); // 多项式乘 auto\u0026amp; res = poly.result; for (int i = mid + 1; i \u0026lt;= r; ++i) result[i] = (result[i] + res[i - l]) % mod; cdq(mid + 1, r); // 注意cdq的顺序 } public: vector\u0026lt;T\u0026gt; result; void calculate(vector\u0026lt;T\u0026gt;\u0026amp; g) { // 传入 g[0~n] this-\u0026gt;g = g; result.resize(g.size(), 0); result[0] = 1; // 初始化 f[0] = 1; cdq(0, g.size() - 1); // 计算 f[0~n] } }; ","date":"2021-07-27T16:16:45+08:00","permalink":"https://example.com/2021/%E6%95%B0%E8%AE%BA%E6%9D%BF%E5%AD%90/","title":"数论板子"},{"content":"1. 二分 整数二分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 1 while (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (check(mid)) l = mid + 1; else r = mid; } // 2 while (l \u0026lt; r) { int mid = (l + r + 1) \u0026gt;\u0026gt; 1; if (check(mid)) l = mid; else r = mid - 1; } // 常用 while (l \u0026lt;= r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (check(mid)) ans = mid, l = mid + 1; else r = mid - 1; } 浮点数二分 1 2 3 4 5 6 7 8 9 10 11 12 // 通用版 while (r - l \u0026gt; 1e-5) { double mid = (l + r) / 2; if (check(mid)) l = mid; else r = mid; } // 防卡精度 for (int i = 0; i \u0026lt; 100; ++i) { double mid = (l + r) / 2; if (check(mid)) l = mid; else r = mid; } 2. 离散化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template\u0026lt;class T\u0026gt; struct discrete { vector\u0026lt;T\u0026gt; v; int init() { // 离散化，返回离散化后的个数 sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); return v.size(); } int size() { return v.size(); } void add(const T x) { v.push_back(x); } int operator[] (const T x) {// 查找一个值离散化后的值 return lower_bound(v.begin(), v.end(), x) - v.begin() + 1; } T kth(int k) { return v[k - 1]; } // 查找排第k的是多少，查找范围[1, n] }; 3. 高精 压位版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 #include \u0026lt;vector\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long ll; /* 用前必读： 本高精采用可调压位式运算对于不同需求记得更改下面的压位代码 本代码暂时只支持 高精 + 高精 高精1 - 高精2 （高精1 \u0026gt; 高精2） 高精 * 低精 高精 / 低精 高精 * 高精 高精 % 低精 高精 与 高精 的大小对比 高精 += 高精 高精1 -= 高精2 （高精1 \u0026gt; 高精2） 高精 *= 低精 高精 /= 低精 高精 *= 高精 高精 %= 低精 尚未完成的功能 高精 / 高精 高精 % 高精 高精1 - 高精2 （高精1 \u0026lt; 高精2） …… 其余请读者自己体会，也许还有bug，但对于所有运算均在洛谷模板题上验证过 */ class hint{ public: static const int w = 1e8, wsize = 8;//压位8个0 vector\u0026lt;ll\u0026gt; a; // int len; /* 初始化 */ hint(ll); hint(string); ll\u0026amp; operator[] (int x) { return a[x]; } ll operator[] (int x) const { return a[x]; } int len() const { return a.size(); } /* 比较(未验证) */ bool operator\u0026lt; (const hint \u0026amp;b) const; bool operator\u0026gt; (const hint \u0026amp;b) const { return b \u0026lt; *this; } bool operator\u0026lt;= (const hint \u0026amp;b) const { return !(b \u0026lt; *this); } bool operator\u0026gt;= (const hint \u0026amp;b) const { return !(*this \u0026lt; b); } bool operator!= (const hint \u0026amp;b) const { return b \u0026lt; *this || *this \u0026lt; b; } bool operator== (const hint \u0026amp;b) const { return !(b \u0026lt; *this) \u0026amp;\u0026amp; !(*this \u0026lt; b); } /* 各种运算 */ // hint operator+ (hint\u0026amp;); // 高精 + 高精 friend hint operator+ (const hint\u0026amp;, const hint\u0026amp;); friend hint operator- (const hint\u0026amp;, const hint\u0026amp;); friend hint operator* (const hint\u0026amp;, const hint\u0026amp;); hint operator* (const int\u0026amp;); // 高精 * 低精 hint operator/ (const int\u0026amp;); // 高精 / 低精 hint operator% (const int\u0026amp;); // 高精 % 低精 hint\u0026amp; operator+= (const hint\u0026amp;); // 高精 += 高精 hint\u0026amp; operator*= (const int\u0026amp;); // 高精 *= 低精 hint\u0026amp; operator*= (const hint\u0026amp;); // 高精 *= 高精 hint\u0026amp; operator-= (const hint\u0026amp;); // 高精 -= 高精 hint\u0026amp; operator/= (const int\u0026amp;); // 高精 /= 低精 hint\u0026amp; operator%= (const int\u0026amp;); // 高精 %= 低精 /* 输入输出重载 */ friend istream\u0026amp; operator\u0026gt;\u0026gt; (istream\u0026amp;, hint\u0026amp;) ; friend ostream\u0026amp; operator\u0026lt;\u0026lt; (ostream\u0026amp;, const hint\u0026amp;); }; hint::hint(ll x = 0) { a.clear(); do { a.push_back(x % w); x /= w; } while (x); } hint::hint(string s) { a.clear(); reverse(s.begin(), s.end()); int n = s.size(); for (int i = 0; i \u0026lt; n; i += wsize) { string tmp = s.substr(i, wsize); reverse(tmp.begin(), tmp.end()); a.push_back(stoll(tmp)); } } /* 比较(未验证) */ bool hint::operator\u0026lt; (const hint\u0026amp; b) const { if (len() != b.len()) return len() \u0026lt; b.len(); for (int i = len() - 1; i \u0026gt; 0; --i) { if (a[i] != b.a[i]) return a[i] \u0026lt; b.a[i]; } return 0; } /* 各种运算 */ hint\u0026amp; hint::operator+= (const hint\u0026amp; b) { while (len() \u0026lt; b.len()) a.push_back(0); ll c = 0; int n = len(), m = b.len(); for (int i = 0; i \u0026lt; n; ++i, c /= w) { c += a[i]; if (i \u0026lt; m) c += b[i]; a[i] = c % w; } if (c) a.push_back(c); return *this; } hint operator+ (const hint\u0026amp; a, const hint\u0026amp; b) { hint res = a; return (res += b); } hint\u0026amp; hint::operator-= (const hint\u0026amp; b) { // assert(*this \u0026gt;= b); ll t = 0; for (int i = 0, n = len(), m = b.len(); i \u0026lt; n; ++i) { t = a[i] - t; if (i \u0026lt; m) t -= b[i]; a[i] = (t + w) % w, t = (t \u0026lt; 0); } while (len() \u0026gt; 1 \u0026amp;\u0026amp; !a.back()) a.pop_back(); return *this; } hint operator-(const hint\u0026amp; a, const hint\u0026amp; b) { hint res = a; return (res -= b); } hint\u0026amp; hint::operator*= (const int\u0026amp; b) { ll t = 0; for (int i = 0, n = len(); i \u0026lt; n || t; ++i, t /= w) { t += a[i] * b; if (i \u0026lt; n) a[i] = t % w; else a.push_back(t % w); } while (a.size() \u0026gt; 1 \u0026amp;\u0026amp; !a.back()) a.pop_back(); return *this; } hint hint::operator* (const int\u0026amp; b) { hint res = *this; return (res *= b); } hint operator* (const hint\u0026amp; a, const hint\u0026amp; b) { int n = a.len(), m = b.len(); hint res; res.a.resize(n + m, 0); for (int i = 0; i \u0026lt; n; ++i) { ll up = 0; for (int j = 0; j \u0026lt; m; ++j) { ll tmp = a[i] * b[j] + res[i + j] + up; res[i + j] = tmp % hint::w; up = tmp / hint::w; } if (up) res[i + m] = up; } while (res.len() \u0026gt; 1 \u0026amp;\u0026amp; !res.a.back()) res.a.pop_back(); return res; } hint\u0026amp; hint::operator*= (const hint\u0026amp; b) { return *this = *this * b; } hint\u0026amp; hint::operator/= (const int\u0026amp; b) { ll r = 0; for (int i = len() - 1; i \u0026gt;= 0; --i) { r = r * w + a[i]; if (r \u0026lt; b) a[i] = 0; else a[i] = r / b, r %= b; } while (len() \u0026gt; 1 \u0026amp;\u0026amp; !a.back()) a.pop_back(); return *this; } hint hint::operator/ (const int\u0026amp; b) { hint res = *this; return (res /= b); } hint\u0026amp; hint::operator%= (const int\u0026amp; b) { ll r = 0; for (int i = len() - 1; i \u0026gt;= 0; --i) { r = r * w + a[i]; if (r \u0026gt;= b) r %= b; } return *this = hint(r); } hint hint::operator% (const int\u0026amp; b) { hint res = *this; return res %= b; } /* 输入输出重载 */ istream\u0026amp; operator\u0026gt;\u0026gt; (istream \u0026amp;in, hint \u0026amp;res) { string s; in \u0026gt;\u0026gt; s; res = hint(s); return in; } ostream\u0026amp; operator\u0026lt;\u0026lt; (ostream \u0026amp;out, const hint\u0026amp; res) { out \u0026lt;\u0026lt; res.a.back(); for(int i = res.len() - 2; i \u0026gt;= 0; --i) { out \u0026lt;\u0026lt; setw(8) \u0026lt;\u0026lt; setfill(\u0026#39;0\u0026#39;) \u0026lt;\u0026lt; res[i]; } return out; } int main() { hint a; int b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; a / b; return 0; } 简化版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 #define bint vector\u0026lt;int\u0026gt; int cmp(const bint\u0026amp; x, const bint\u0026amp; y) { // 1:x\u0026gt;y, 0:x=y, -1:x\u0026lt;y if (x.size() != y.size()) { return x.size() \u0026gt; y.size() ? 1 : -1; } for (int i = x.size() - 1; i \u0026gt;= 0; --i) { if (x[i] != y[i]) { return x[i] \u0026gt; y[i] ? 1 : -1; } } return 0; } // 正整数加 bint add(const bint\u0026amp; x, const bint\u0026amp; y) { if (x.size() \u0026lt; y.size()) return add(y, x); bint res; int c = 0, n = x.size(), m = y.size(); for (int i = 0; i \u0026lt; n; ++i, c /= 10) { c += x[i]; if (i \u0026lt; m) c += y[i]; res.push_back(c % 10); } if (c) res.push_back(c); return res; } // 正整数 x \u0026gt;= y bint sub(const bint\u0026amp; x, const bint\u0026amp; y) { bint res; int n = x.size(), m = y.size(); for (int i = 0, t = 0; i \u0026lt; n; ++i, t = (t \u0026lt; 0)) { t = x[i] - t; if (i \u0026lt; m) t -= y[i]; res.push_back((t + 10) % 10); } while (res.size() \u0026gt; 1 \u0026amp;\u0026amp; res.back() == 0) res.pop_back(); return res; } bint mul(const bint\u0026amp; x, const int y) { bint res; int t = 0, n = x.size(); for (int i = 0; i \u0026lt; n || t; ++i, t /= 10) { if (i \u0026lt; n) t += x[i] * y; res.push_back(t % 10); } while (res.size() \u0026gt; 1 \u0026amp;\u0026amp; res.back() == 0) res.pop_back(); return res; } bint mul(const bint\u0026amp; x, const bint\u0026amp; y) { int n = x.size(), m = y.size(); bint res(n + m, 0); for (int i = 0; i \u0026lt; n; ++i) { int up = 0; for (int j = 0; j \u0026lt; m; ++j) { int tmp = x[i] * y[j] + res[i + j] + up; res[i + j] = tmp % 10; up = tmp / 10; } if (up) res[i + m] = up; } while (res.size() \u0026gt; 1 \u0026amp;\u0026amp; res.back() == 0) res.pop_back(); return res; } bint div(const bint\u0026amp; x, const int y, ll \u0026amp;r) { bint res; for (int i = x.size() - 1; i \u0026gt;= 0; --i) { r = r * 10 + x[i]; res.push_back(r / y); r %= y; } reverse(res.begin(), res.end()); while (res.size() \u0026gt; 1 \u0026amp;\u0026amp; res.back() == 0) res.pop_back(); return res; } void print(const bint\u0026amp; x) { for (int i = x.size() - 1; i \u0026gt;= 0; --i) { cout \u0026lt;\u0026lt; x[i]; } } 4. 差分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const int M = 1e5 + 10; int dif[M], arr[M], res[M]; void change(int l, int r, int v) { // [l, r] + v dif[l] += v, dif[r + 1] -= v; } void init(int n) { dif[1] = arr[1]; for (int i = 2; i \u0026lt;= n; ++i) dif[i] = arr[i] - arr[i - 1]; } void get_res(int n) { res[1] = dif[1]; for (int i = 2; i \u0026lt;= n; ++i) { res[i] = dif[i] + res[i - 1]; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // index start from 0 class Dif { using Int = int; public: vector\u0026lt;Int\u0026gt; dif, res; Dif(int n) : dif(n + 1, 0), res(n + 1, 0) {} Dif(const vector\u0026lt;Int\u0026gt;\u0026amp; arr) : dif(arr.size() + 1, 0), res(arr.size() + 1, 0) { dif.front() = arr.front(); for (size_t i = 1; i \u0026lt; arr.size(); ++i) { dif[i] = arr[i] - arr[i - 1]; } } void update(size_t l, size_t r, Int v) { // [l, r] += v dif[l] += v, dif[min(r + 1, dif.size() - 1)] -= v; } void get_res() { res.front() = dif.front(); for (size_t i = 1; i \u0026lt; dif.size(); ++i) { res[i] = dif[i] + res[i - 1]; } } }; 5. 三分 1 2 3 4 5 6 7 8 9 10 11 double ts(int l, int r) { double ans1 = 0x3f3f3f3f, ans2 = 0x3f3f3f3f; while (l \u0026lt; r) { int lmid = l + (r - l) / 3; int rmid = r - (r - l) / 3; ans1 = f(lmid), ans2 = f(rmid); if (ans1 \u0026lt;= ans2) r = rmid - 1; // 凹函数的最小值， 凸函数\u0026lt;=反过来 else l = lmid + 1; } return min(ans1, ans2); //凸函数这里记得改成max } 6. 区间合并 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 vector\u0026lt;PII\u0026gt; merge(vector\u0026lt;PII\u0026gt; seg) { // 传入非空 vector\u0026lt;PII\u0026gt; ret; sort(seg.begin(), seg.end()); int l = -2e9, r = l; for (auto [x, y] : seg) { if (r \u0026lt; x) { if (l != -2e9) ret.push_back({l, r}); l = x, r = y; continue; } r = max(r, y); } ret.push_back({l, r}); return ret; } 7. cout控制宽度和精度 1 2 3 4 5 6 #include \u0026lt;iomanip\u0026gt; // setw()只对其后面紧跟的输出产生作用 cout \u0026lt;\u0026lt; setw(8) \u0026lt;\u0026lt; setfill(\u0026#39;0\u0026#39;) \u0026lt;\u0026lt; 123 \u0026lt;\u0026lt; endl; // 00000123 cout.precision(3); // 之后的输出都置保留3位有效数字 cout.setf(ios::fixed); // 固定小数点，即之后的都保留3位小数 cout.unsetf(ios::fixed); // 取消固定小数点 8. 快读快输 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 inline char getc() {// 重写getchar static char buf[1 \u0026lt;\u0026lt; 21], *p1 = buf, *p2 = buf; return p1 == p2 \u0026amp;\u0026amp; (p2 = (p1 = buf) + fread(buf, 1, 1 \u0026lt;\u0026lt; 21, stdin), p1 == p2) ? EOF : *p1++; } inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026amp;\u0026amp; c != -1; c = getchar()) { if (c == \u0026#39;-\u0026#39;) f = 1; } //if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c ^ \u0026#39;0\u0026#39;); } return f ? -x : x; } void getstr(string \u0026amp;s) { // 字符串快读 int c = getchar(); while (c \u0026lt; 33 \u0026amp;\u0026amp; c != -1) c = getchar(); //if (c == -1) exit(0); s.clear(); for(;c \u0026gt; 32; c = getchar()) s.push_back(c); } void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } void print(const string\u0026amp; s) { for (char c : s) putchar(c); } template \u0026lt;typename T\u0026gt; void print(T x, char c) { print(x); putchar(c); } 9.模数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 using ll = long long; ll powf(ll a, ll b, ll p, ll res = 1) { for (a %= p; b; b \u0026gt;\u0026gt;= 1, a = a * a % p) if (b \u0026amp; 1) res = res * a % p; return res; } constexpr int P = 998244353; int transf(int x) { if (x \u0026lt; 0) return x + P; if (x \u0026gt;= P) return x - P; return x; } struct mint { int x; mint (int x = 0) : x(transf(x)) {} mint operator-() const { return mint(P - x); } mint\u0026amp; operator+= (const mint\u0026amp; i) { x = transf(x + i.x); return *this; } mint\u0026amp; operator-= (const mint\u0026amp; i) { x = transf(x - i.x); return *this; } mint\u0026amp; operator*= (const mint\u0026amp; i) { x = 1ll * x * i.x % P; return *this; } mint\u0026amp; operator/= (const mint\u0026amp; i) { return *this *= i.inv(); } mint inv() const { return mint(powf(x, P - 2, P)); } friend mint operator+ (const mint\u0026amp; a, const mint\u0026amp; b) { mint res = a; return res += b; } friend mint operator- (const mint\u0026amp; a, const mint\u0026amp; b) { mint res = a; return res -= b; } friend mint operator* (const mint\u0026amp; a, const mint\u0026amp; b) { mint res = a; return res *= b; } friend mint operator/ (const mint\u0026amp; a, const mint\u0026amp; b) { mint res = a; return res /= b; } }; 10.快速排序 1 2 3 4 5 6 7 8 9 10 11 12 template\u0026lt;class T\u0026gt; void q_sort(T *a, int l, int r) { // 对a数组的双闭区间 [l, r] 进行快排 if (l \u0026gt;= r) return; int i = l, j = r; T tmp = a[(l + r) \u0026gt;\u0026gt; 1]; while (i \u0026lt;= j) { // 最后i 和 j的值只有两种情况，j = i - 1 或者 j + 1 = i - 1 while (a[i] \u0026lt; tmp) ++i; while (a[j] \u0026gt; tmp) --j; if (i \u0026lt;= j) swap(a[i++], a[j--]); } q_sort(a, l, j), q_sort(a, i, r); } 11.基数排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 const int N = 5e6 + 2, M = 1 \u0026lt;\u0026lt; 10; vector\u0026lt;int\u0026gt; b(N); int cnt[M]; int p[] = {0, 10, 20, 30}; // 对应基数1024的二进制位数 inline int get_part(int n, int i) { return n \u0026gt;\u0026gt; p[i] \u0026amp; (M - 1); } void radix_sort(vector\u0026lt;int\u0026gt;\u0026amp; a, int n) { for (int i = 0; i \u0026lt; 3; ++i) { // 根据a数组元素的大小调整基数数组的个数，最高取到p数组的最后一个 memset(cnt, 0, sizeof cnt); for (int j = 0; j \u0026lt; n; ++j) { cnt[get_part(a[j], i)]++; } for (int j = 1; j \u0026lt; M; ++j) { cnt[j] += cnt[j - 1]; } for (int j = n - 1; j \u0026gt;= 0; --j) { int k = get_part(a[j], i); b[cnt[k] - 1] = a[j]; cnt[k]--; } swap(a, b); // 用swap比memcpy快 } } ","date":"2021-07-27T16:13:55+08:00","permalink":"https://example.com/2021/%E5%9F%BA%E7%A1%80%E6%9D%BF%E5%AD%90/","title":"基础板子"},{"content":"常用模板（包括网络赛） 一、基础板子 1. 二分 整数二分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 1 while (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (check(mid)) l = mid + 1; else r = mid; } // 2 while (l \u0026lt; r) { int mid = (l + r + 1) \u0026gt;\u0026gt; 1; if (check(mid)) l = mid; else r = mid - 1; } // 常用 while (l \u0026lt;= r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (check(mid)) ans = mid, l = mid + 1; else r = mid - 1; } 浮点数二分 1 2 3 4 5 6 7 8 9 10 11 12 // 通用版 while (r - l \u0026gt; 1e-5) { double mid = (l + r) / 2; if (check(mid)) l = mid; else r = mid; } // 防卡精度 for (int i = 0; i \u0026lt; 100; ++i) { double mid = (l + r) / 2; if (check(mid)) l = mid; else r = mid; } 2. 离散化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template\u0026lt;class T\u0026gt; struct discrete { vector\u0026lt;T\u0026gt; v; int init() { // 离散化，返回离散化后的个数 sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); return v.size(); } int size() { return v.size(); } void add(const T x) { v.push_back(x); } int operator[] (const T x) {// 查找一个值离散化后的值 return lower_bound(v.begin(), v.end(), x) - v.begin() + 1; } T kth(int k) { return v[k - 1]; } // 查找排第k的是多少，查找范围[1, n] }; 3. 高精 压位版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long ll; /* 用前必读： 本高精采用可调压位式运算对于不同需求记得更改下面的压位代码 注意笔者只封装了 bign * int 没有封装 int * bign , 用时注意顺序 若出现 bign * x,中 x 不是常量变量或者不是变量（例如具体数字 3 4 5……） 记得把封装的与int相关的 运算符重载函数 的const和取地址符\u0026amp;去掉，防止报错 若是爆栈请尝试开全局变量或者把数组改小即 M 改小 本代码暂时只支持 高精 + 高精 高精1 - 高精2 （高精1 \u0026gt; 高精2） 高精 * 低精 高精 / 低精 高精 * 高精 高精 % 低精 高精 与 高精 的大小对比 高精 += 高精 高精1 -= 高精2 （高精1 \u0026gt; 高精2） 高精 *= 低精 高精 /= 低精 高精 *= 高精 高精 %= 低精 尚未完成的功能 高精 / 高精 高精 % 高精 高精1 - 高精2 （高精1 \u0026lt; 高精2） …… 其余请读者自己体会 */ const int w = 1e8, M = 1e4, wsize = 8;//压位8个0 const char pout[] = \u0026#34;%08lld\u0026#34;;//记得修改 struct bign{ ll num[M]; char str[M * wsize]; int len; void clear() { memset(num, 0, sizeof num); len = 0;} /* 初始化 */ bign() : len(0) { clear(); } bign(int n); bign(ll n); bign(char str[]); bign(string str); void change(); void operator= (const int x) { *this = bign(x); } void operator= (const ll x) { *this = bign(x); } void operator= (char x[]) { *this = bign(x); } void operator= (string x) { *this = bign(x); } ll \u0026amp;operator[] (int x) { return num[x]; } /* 输出 */ void print(); void print() const; /* 比较(未验证) */ bool operator\u0026lt; (const bign \u0026amp;b) const; bool operator\u0026gt; (const bign \u0026amp;b) const { return b \u0026lt; *this; } bool operator\u0026lt;= (const bign \u0026amp;b) const { return !(b \u0026lt; *this); } bool operator\u0026gt;= (const bign \u0026amp;b) const { return !(*this \u0026lt; b); } bool operator!= (const bign \u0026amp;b) const { return b \u0026lt; *this || *this \u0026lt; b; } bool operator== (const bign \u0026amp;b) const { return !(b \u0026lt; *this) \u0026amp;\u0026amp; !(*this \u0026lt; b); } /* 各种运算 */ bign operator+ (const bign \u0026amp;b) const; // 高精 + 高精 bign operator* (const int \u0026amp;b) const; // 高精 * 低精 bign operator* (const bign \u0026amp;b); // 高精 * 高精 bign operator- (const bign \u0026amp;b) const; // 高精 - 高精 bign operator/ (const int \u0026amp;b) const; // 高精 / 低精 bign operator% (const int \u0026amp;b); // 高精 % 低精 void operator+= (const bign \u0026amp;b); // 高精 += 高精 void operator*= (const int \u0026amp;b); // 高精 *= 低精 void operator*= (const bign \u0026amp;b); // 高精 *= 高精 void operator-= (const bign \u0026amp;b); // 高精 -= 高精 void operator/= (const int \u0026amp;b); // 高精 /= 低精 void operator%= (const int \u0026amp;b); // 高精 %= 低精 /* 输入输出重载 */ friend istream\u0026amp; operator\u0026gt;\u0026gt; (istream \u0026amp;in, bign \u0026amp;res) ; friend ostream\u0026amp; operator\u0026lt;\u0026lt; (ostream \u0026amp;out, const bign \u0026amp;res) ; }; bign::bign(int n) : len(0) { clear(); while (1) { num[++len] = n % w, n /= w; if (!n) break; } } bign::bign(ll n) : len(0) { clear(); while (1) { num[++len] = n % w, n /= w; if (!n) break; } } bign::bign(char str[]) : len(0) { clear(); int l = strlen(str) - 1; for (int i = l; i \u0026gt;= 0; i -= wsize) { ll tmp = 0, k = 1; for (int j = 0; j \u0026lt; wsize \u0026amp;\u0026amp; i - j \u0026gt;= 0; j++, k *= 10) { tmp += (str[i - j] - \u0026#39;0\u0026#39;) * k; } num[++len] = tmp; } } bign::bign(string str) : len(0) { clear(); int l = str.size() - 1; for (int i = l; i \u0026gt;= 0; i -= wsize) { ll tmp = 0, k = 1; for (int j = 0; j \u0026lt; wsize \u0026amp;\u0026amp; i - j \u0026gt;= 0; j++, k *= 10) { tmp += (str[i - j] - \u0026#39;0\u0026#39;) * k; } num[++len] = tmp; } } void bign::change() { int l = strlen(str) - 1; len = 0; for (int i = l; i \u0026gt;= 0; i -= wsize) { ll tmp = 0, k = 1; for (int j = 0; j \u0026lt; wsize \u0026amp;\u0026amp; i - j \u0026gt;= 0; j++, k *= 10) { tmp += (str[i - j] - \u0026#39;0\u0026#39;) * k; } num[++len] = tmp; } } /* 输出 */ void bign::print() { printf(\u0026#34;%lld\u0026#34;, num[len]); for (int i = len - 1; i \u0026gt; 0; i--) printf(pout, num[i]); puts(\u0026#34;\u0026#34;); } void bign::print() const { printf(\u0026#34;%lld\u0026#34;, num[len]); for (int i = len - 1; i \u0026gt; 0; i--) printf(pout, num[i]); // puts(\u0026#34;\u0026#34;); } /* 比较(未验证) */ bool bign::operator\u0026lt; (const bign \u0026amp;b) const { if (len != b.len) return len \u0026lt; b.len; for (int i = len; i \u0026gt; 0; i--) { if (num[i] != b.num[i]) return num[i] \u0026lt; b.num[i]; } return false; } /************************常用****************************/ /* 各种运算 */ bign bign::operator+ (const bign \u0026amp;b) const { bign res = *this; if (res.len \u0026lt; b.len) res.len = b.len; for (int i = 1; i \u0026lt;= res.len; i++) { res.num[i] += b.num[i]; res.num[i + 1] += res.num[i] / w; res.num[i] %= w; } while (res.num[res.len + 1]) res.len++; return res; } bign bign::operator* (const int \u0026amp;b) const { bign res; ll carry = 0; for (int i = 1; i \u0026lt;= len; i++) { ll tmp = num[i] * b + carry; res.num[++res.len] = tmp % w; carry = tmp / w; } while (carry) { res.num[++res.len] = carry % w; carry /= w; } return res; } bign bign::operator* (const bign \u0026amp;b) { bign res; for (int i = 1; i \u0026lt;= len; i++) { ll up = 0; for (int j = 1; j \u0026lt;= b.len; j++) { ll tmp = num[i] * b.num[j] + res.num[i + j - 1] + up; res.num[i + j - 1] = tmp % w; up = tmp / w; } if (up) res.num[i + b.len] = up; } res.len = len + b.len; while (res.len \u0026gt; 1 \u0026amp;\u0026amp; res.num[res.len] == 0) res.len--; return res; } /********************************************************/ bign bign::operator- (const bign \u0026amp;b) const { bign res = *this; for (int i = 1; i \u0026lt;= len; i++) { if (res.num[i] \u0026lt; b.num[i]) res.num[i] += w, res.num[i + 1]--; res.num[i] -= b.num[i]; } while (res.len \u0026gt; 1 \u0026amp;\u0026amp; res.num[res.len] == 0) res.len--; return res; } bign bign::operator/ (const int \u0026amp;b) const { bign res; res.len = len; ll r = 0;//余数 for (int i = len; i \u0026gt; 0; i--) { r = r * w + num[i]; if (r \u0026lt; b) res.num[i] = 0; else res.num[i] = r / b, r %= b; } while (res.len \u0026gt; 1 \u0026amp;\u0026amp; res.num[res.len] == 0) res.len--; return res; } bign bign::operator% (const int \u0026amp;b) { ll r = 0;//余数 for (int i = len; i \u0026gt; 0; i--) { r = r * w + num[i]; if (r \u0026gt;= b) r %= b; } return bign(r); } void bign::operator+= (const bign \u0026amp;b) { if (len \u0026lt; b.len) len = b.len; for (int i = 1; i \u0026lt;= len; i++) { num[i] += b.num[i]; num[i + 1] += num[i] / w; num[i] %= w; } while (num[len + 1]) len++; } void bign::operator*= (const int \u0026amp;b) { for (int i = 1; i \u0026lt;= len; i++) num[i] *= b; for (int i = 1; i \u0026lt;= len; i++) { num[i + 1] += num[i] / w; num[i] %= w; } while(num[len + 1]) { len++; num[len + 1] = num[len] / w; num[len] %= w; } } void bign::operator*= (const bign \u0026amp;b) { *this = *this * b; } void bign::operator-= (const bign \u0026amp;b) { for (int i = 1; i \u0026lt;= len; i++) { if (num[i] \u0026lt; b.num[i]) num[i] += w, num[i + 1]--; num[i] -= b.num[i]; } while (len \u0026gt; 1 \u0026amp;\u0026amp; num[len] == 0) len--; } void bign::operator/= (const int \u0026amp;b) { ll r = 0; for (int i = len; i \u0026gt; 0; i--) { r = r * w + num[i]; if (r \u0026lt; b) num[i] = 0; else num[i] = r / b, r %= b; } while (len \u0026gt; 1 \u0026amp;\u0026amp; num[len] == 0) len--; } void bign::operator%= (const int \u0026amp;b) { ll r = 0; for (int i = len; i \u0026gt; 0; i--) { r = r * w + num[i]; if (r \u0026gt;= b) r %= b; } *this = bign(r); } istream\u0026amp; operator\u0026gt;\u0026gt; (istream \u0026amp;in, bign \u0026amp;res) { in \u0026gt;\u0026gt; res.str; res.change(); return in; } ostream\u0026amp; operator\u0026lt;\u0026lt; (ostream \u0026amp;out, const bign \u0026amp;res) { res.print(); return out; } int main() { return 0; } 简化版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 #define bint vector\u0026lt;int\u0026gt; int cmp(bint\u0026amp; x, bint\u0026amp; y) { // 1:x\u0026gt;y, 0:x=y, -1:x\u0026lt;y if (x.size() != y.size()) { return x.size() \u0026gt; y.size() ? 1 : -1; } for (int i = x.size() - 1; i \u0026gt;= 0; --i) { if (x[i] != y[i]) { return x[i] \u0026gt; y[i] ? 1 : -1; } } return 0; } // 正整数加 bint add(bint\u0026amp; x, bint\u0026amp; y) { if (x.size() \u0026lt; y.size()) return add(y, x); bint res; int c = 0, n = x.size(), m = y.size(); for (int i = 0; i \u0026lt; n; ++i, c /= 10) { c += x[i]; if (i \u0026lt; m) c += y[i]; res.push_back(c % 10); } if (c) res.push_back(c); return res; } // 正整数 x \u0026gt;= y bint sub(bint\u0026amp; x, bint\u0026amp; y) { bint res; int n = x.size(), m = y.size(); for (int i = 0, t = 0; i \u0026lt; n; ++i, t = (t \u0026lt; 0)) { t = x[i] - t; if (i \u0026lt; m) t -= y[i]; res.push_back((t + 10) % 10); } while (res.size() \u0026gt; 1 \u0026amp;\u0026amp; res.back() == 0) res.pop_back(); return res; } bint mul(bint\u0026amp; x, int y) { bint res; int t = 0, n = x.size(); for (int i = 0; i \u0026lt; n || t; ++i, t /= 10) { if (i \u0026lt; n) t += x[i] * y; res.push_back(t % 10); } while (res.size() \u0026gt; 1 \u0026amp;\u0026amp; res.back() == 0) res.pop_back(); return res; } bint mul(bint\u0026amp; x, bint\u0026amp; y) { int n = x.size(), m = y.size(); bint res(n + m, 0); for (int i = 0; i \u0026lt; n; ++i) { int up = 0; for (int j = 0; j \u0026lt; m; ++j) { int tmp = x[i] * y[j] + res[i + j] + up; res[i + j] = tmp % 10; up = tmp / 10; } if (up) res[i + m] = up; } while (res.size() \u0026gt; 1 \u0026amp;\u0026amp; res.back() == 0) res.pop_back(); return res; } bint div(bint\u0026amp; x, int y, ll \u0026amp;r) { bint res; for (int i = x.size() - 1; i \u0026gt;= 0; --i) { r = r * 10 + x[i]; res.push_back(r / y); r %= y; } reverse(res.begin(), res.end()); while (res.size() \u0026gt; 1 \u0026amp;\u0026amp; res.back() == 0) res.pop_back(); return res; } void print(bint\u0026amp; x) { for (int i = x.size() - 1; i \u0026gt;= 0; --i) { cout \u0026lt;\u0026lt; x[i]; } } 4. 差分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const int M = 1e5 + 10; int dif[M], arr[M], res[M]; void change(int l, int r, int v) { // [l, r] + v dif[l] += v, dif[r + 1] -= v; } void init(int n) { dif[1] = arr[1]; for (int i = 2; i \u0026lt;= n; ++i) dif[i] = arr[i] - arr[i - 1]; } void get_res(int n) { res[1] = dif[1]; for (int i = 2; i \u0026lt;= n; ++i) { res[i] = dif[i] + res[i - 1]; } } 5.三分 1 2 3 4 5 6 7 8 9 10 11 double ts(int l, int r) { double ans1 = 0x3f3f3f3f, ans2 = 0x3f3f3f3f; while (l \u0026lt; r) { int lmid = l + (r - l) / 3; int rmid = r - (r - l) / 3; ans1 = f(lmid), ans2 = f(rmid); if (ans1 \u0026lt;= ans2) r = rmid - 1; // 凹函数的最小值， 凸函数\u0026lt;=反过来 else l = lmid + 1; } return min(ans1, ans2); //凸函数这里记得改成max } 6. 区间合并 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 vector\u0026lt;PII\u0026gt; merge(vector\u0026lt;PII\u0026gt; seg) { // 传入非空 vector\u0026lt;PII\u0026gt; ret; sort(seg.begin(), seg.end()); int l = -2e9, r = l; for (auto [x, y] : seg) { if (r \u0026lt; x) { if (l != -2e9) ret.push_back({l, r}); l = x, r = y; continue; } r = max(r, y); } ret.push_back({l, r}); return ret; } 7. cout控制宽度和精度 1 2 3 4 5 6 #include \u0026lt;iomanip\u0026gt; // setw()只对其后面紧跟的输出产生作用 cout \u0026lt;\u0026lt; setw(8) \u0026lt;\u0026lt; setfill(\u0026#39;0\u0026#39;) \u0026lt;\u0026lt; 123 \u0026lt;\u0026lt; endl; // 00000123 cout.precision(3); // 之后的输出都置保留3位有效数字 cout.setf(ios::fixed); // 固定小数点，即之后的都保留3位小数 cout.unsetf(ios::fixed); // 取消固定小数点 8. 快读快输 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 inline char getc() {// 重写getchar static char buf[1 \u0026lt;\u0026lt; 21], *p1 = buf, *p2 = buf; return p1 == p2 \u0026amp;\u0026amp; (p2 = (p1 = buf) + fread(buf, 1, 1 \u0026lt;\u0026lt; 21, stdin), p1 == p2) ? EOF : *p1++; } inline ll IO() { long long x = 0; int f = 0, c = getchar(); for (; !isdigit(c) \u0026amp;\u0026amp; c != -1; c = getchar()) { if (c == \u0026#39;-\u0026#39;) f = 1; } //if (c == -1) exit(0); for (; isdigit(c); c = getchar()) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c ^ \u0026#39;0\u0026#39;); } return f ? -x : x; } void getstr(string \u0026amp;s) { // 字符串快读 int c = getchar(); while (c \u0026lt; 33 \u0026amp;\u0026amp; c != -1) c = getchar(); //if (c == -1) exit(0); for(;c \u0026gt; 32; c = getchar()) s.push_back(c); } void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } void print(const string\u0026amp; s) { for (char c : s) putchar(c); } template \u0026lt;typename T\u0026gt; void print(T x, char c) { print(x); putchar(c); } 二、数论 1. gcd与lcm 1 2 3 4 5 typedef long long ll; //最大公因数，公约数 ll gcd(ll a, ll b, ll m = 1) { while(b) m = a % b, a = b, b = m; return a; } //最小公倍数 ll lcm(ll a, ll b) { return a / gcd(a, b) * b; } 2. ex_gcd 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* 通解为 x\u0026#39; = x + (b / gcd) * k y\u0026#39; = y - (a / gcd) * k */ typedef long long ll; // 扩展欧几里得算法核心函数 void exgcd(ll a, ll b, ll \u0026amp;g, ll \u0026amp;x, ll \u0026amp;y) { if (!b) { g = a, x = 1, y = 0; return; } exgcd(b, a % b, g, y, x); y -= x * (a / b); } /** * 此函数为 求解 ax + by = c * a b c为整数即可, y的解在函数外自求 * 返回 x的最小非负整数解 * 返回 -1 说明无解 */ ll minx(ll a, ll b, ll c) { ll x, y, g; exgcd(a, b, g, x, y); if (c % g != 0) return -1; ll t = abs(b / g); return (x * c / g % t + t) % t; // 返回最小非负整数解 } 3. 素数筛 埃式筛 1 2 3 4 5 6 7 8 9 10 11 12 13 const int M = 1e5 + 5; int pri[M], cnt = 0; bool isp[M]; // 复杂度O(nloglogn) // true 为非素数， false 为素数 void table() { isp[0] = isp[1] = true; for (int i = 2; i \u0026lt; M; i++) { if (isp[i]) continue; pri[cnt++] = i; for (int j = i + i; j \u0026lt; M; j += i) isp[j] = true; } } 线性筛 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 复杂度O(n) const int M = 1e5 + 10; int cnt = 0; bool isp[M]; // true 为非素数， false 为素数 vector\u0026lt;int\u0026gt; pri; void table(int n = 1e5) { isp[0] = isp[1] = 1; for (int i = 2; i \u0026lt;= n; ++i) { if (!isp[i]) pri.push_back(i); for (int x : pri) { if (x * i \u0026gt; n) break; isp[x * i] = 1; if (i % x == 0) break; } } } 4. 逆元 线性法 1 2 3 4 5 6 7 8 typedef long long ll; // 时间复杂度O(n) void fny(const int \u0026amp;n, ll *inv, const ll mod) { inv[0] = inv[1] = 1; for (ll i = 2; i \u0026lt;= n; i++) { inv[i] =((mod - mod / i) * inv[mod % i]) % mod; } } 扩欧法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 typedef long long ll; void exgcd(ll a, ll b, ll \u0026amp;g, ll \u0026amp;x, ll \u0026amp;y) { if (!b) { g = a, x = 1, y = 0; return; } exgcd(b, a % b, g, y, x); y -= x * (a / b); } // ax=1(mod m) ll inverse(ll a, ll m) {//扩展欧几里得法求逆元，返回-1代表没有逆元 ll g, x, y; exgcd(a, m, g, x, y); return g == 1 ? (x % m + m) % m : -1; } 费马小定理法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //a ^ (p - 1) = 1 (mod p), p为素数 //a ^ (p - 2) = a ^ (-1) (mod p) //a 的逆元为 a ^ (p - 2) typedef long long ll; ll pow_f(ll a, ll b, const ll mo) { ll ans = 1; a %= mo; while (b) { if (b \u0026amp; 1) ans = (ans * a) % mo; a = (a * a) % mo; b \u0026gt;\u0026gt;= 1; } return ans; } ll inverse(ll a, ll m) { return pow_f(a, m - 2, m); } 5. 快速幂 1 2 3 4 5 6 7 #define ll long long ll powf(ll a, ll b, const ll mod) {// 返回a^b % mod ll res = 1; for (a %= mod; b; b \u0026gt;\u0026gt;= 1, a = a * a % mod) if (b \u0026amp; 1) res = res * a % mod; return res; } 6. 矩阵快速幂 结构体版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 const ll MOD = 1e9 + 7; #define MO(x) ((x) % MOD) struct Mat { ll mat[10][10]; int n; // n * n 阶矩阵 Mat(int n = 2) : n(n) { memset(mat, 0, sizeof mat); }//记得修改 void to_one() { for (int i = 0; i \u0026lt; n; i++) mat[i][i] = 1; } Mat operator*(const Mat a) const { Mat res; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { ll sum = 0; for (int k = 0; k \u0026lt; n; k++) { sum += MO(this-\u0026gt;mat[i][k] * a.mat[k][j]); } res.mat[i][j] = MO(sum); } } return res; } ll *operator[](int x) { return mat[x]; } }; Mat pow_f(Mat a, ll b) { //a ^ b次幂 Mat ans; ans.to_one(); while (b) { if (b \u0026amp; 1) ans = ans * a; a = a * a; b \u0026gt;\u0026gt;= 1; } return ans; } vector 重载运算符版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #define ll long long #define vi vector\u0026lt;ll\u0026gt; #define Mat vector\u0026lt;vi\u0026gt; const int X = 6; const ll mod = 1e9 + 7; Mat operator* (Mat a, Mat b) { Mat res(X, vi(X, 0)); for (int i = 0; i \u0026lt; X; ++i) for (int j = 0; j \u0026lt; X; ++j) for (int k = 0; k \u0026lt; X; ++k) res[i][j] = (res[i][j] + a[i][k] * b[k][j] % mod) % mod; return res; } Mat operator^ (Mat a, long long b) { Mat res(X, vi(X, 0)); for (int i = 0; i \u0026lt; X; ++i) res[i][i] = 1; while (b) { if (b \u0026amp; 1) res = res * a; a = a * a, b \u0026gt;\u0026gt;= 1; } return res; } 7. 高斯消元 普通浮点数高斯消元，洛谷模板题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 // 洛谷模板题 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int N = 110; const double eps = 1e-6; // 用来控制进度 // 普通的高斯消元是将矩阵转化成上三角的形式，再回带求出答案 double ans[N]; // 用来记录答案 int gauss(int n, int m, vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; \u0026amp;a) { // n行m + 1列的增广矩阵 int r, c; // 当前行和当前列 for (r = c = 0; c \u0026lt; m \u0026amp;\u0026amp; r \u0026lt; n; ++ c) { int maxr = r; // 记录最大 for (int i = r + 1; i \u0026lt; n; ++i) if (abs(a[i][c]) \u0026gt; abs(a[maxr][c])) maxr = i; // 寻找从当前行开始向下走的当前列中的绝对值最大值 if (r ^ maxr) swap(a[r], a[maxr]); // 如果不是当前行，则交换两行 if (abs(a[r][c]) \u0026lt; eps) continue; // 如果当前行当前列的最大值为0则不作消元 for (int i = m; i \u0026gt;= c; --i) a[r][i] /= a[r][c]; // 将当前行的从当前列开始到最后一列 for (int i = r + 1; i \u0026lt; n; ++i) { if (abs(a[i][c]) \u0026lt; eps) continue; // 如果改行的当前列已经是0，则不作消元 for (int j = m; j \u0026gt;= c; --j) { // 逆向消元，可以少开一个变量 a[i][j] -= a[r][j] * a[i][c]; } } ++r; } if (r \u0026lt; n) { // 无穷解 或者 无解 for (int i = r; i \u0026lt; n; ++r) if (abs(a[i][n]) \u0026lt; eps) return 0; return -1; // 无穷解 } for (int i = n - 1; ~i; --i) { // 回带 for (int j = i + 1; j \u0026lt; n; ++j) { a[i][n] -= a[i][j] * ans[j]; } ans[i] = a[i][n]; } return 1; // 唯一解 } vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; a; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 0; i \u0026lt; n; ++i) { a.push_back({}); for (int j = 0; j \u0026lt;= n; ++j) { double x; scanf(\u0026#34;%lf\u0026#34;, \u0026amp;x); a[i].push_back(x); } } if (gauss(n, n, a) == 1) { for (int i = 0; i \u0026lt; n; ++i) printf(\u0026#34;%.2f\\n\u0026#34;, ans[i]); } else puts(\u0026#34;No Solution\u0026#34;); return 0; } 浮点数高斯约旦消元法， 洛谷模板题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // 洛谷模板题 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const double eps = 1e-6; double ans[110]; // 记录答案 int gauss_j(int n, int m, vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; \u0026amp;a) { // n行m + 1列增广矩阵 int r, c; // 当前行当前列 for (r = c = 0; c \u0026lt; m \u0026amp;\u0026amp; r \u0026lt; n; ++c) { // int maxr = r; // 记录最大值 for (int i = r + 1; i \u0026lt; n; ++i) if (abs(a[i][c]) \u0026gt; abs(a[maxr][c])) maxr = i; // 寻找从当前行开始向下走的当前列中的绝对值最大值 if (maxr ^ r) swap(a[r], a[maxr]); // 交换两行 if (abs(a[r][c]) \u0026lt; eps) continue; // 如果为当前行中的当前列的值为0 for (int i = 0; i \u0026lt; n; ++i) { // 约旦消元 if (abs(a[i][c]) \u0026lt; eps || i == r) continue; // 如果是当前行或者改行的当前列已经是0 for (int j = m; j \u0026gt;= c; --j) a[i][j] -= a[i][c] / a[r][c] * a[r][j]; } ++r; } if (r \u0026lt; n) return 0; // 无解或者无穷解 for (int i = 0; i \u0026lt; n; ++i) ans[i] = a[i][n] / a[i][i]; // 回带 return 1; } vector\u0026lt;vector\u0026lt;double\u0026gt;\u0026gt; a; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 0; i \u0026lt; n; ++i) { a.push_back({}); for (int j = 0; j \u0026lt;= n; ++j) { double x; scanf(\u0026#34;%lf\u0026#34;, \u0026amp;x); a[i].push_back(x); } } if (gauss_j(n, n, a) == 1) { for (int i = 0; i \u0026lt; n; ++i) printf(\u0026#34;%.2f\\n\u0026#34;, ans[i]); } else puts(\u0026#34;No Solution\u0026#34;); return 0; } 模意义下的高斯消元法，POJ - 2065 SETI 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 // POJ - 2065 SETI #include \u0026lt;cassert\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int gcd(int a, int b) { int m; while(b) m = a % b, a = b, b = m; return a; } int lcm(int a, int b) { return a / gcd(a, b) * b; } int p, ans[310]; // 记录答案 int powf(int a, int b, const int mod, int ans = 1) { a %= mod; while (b) { if (b \u0026amp; 1) ans = ans * a % mod; b \u0026gt;\u0026gt;= 1, a = a * a % mod; } return ans; } int inv(int a, int m) { return powf(a, m - 2, m); } //模意义下的高斯消元不需要用约旦的方式，因为整数不用考虑精度问题 // n 行 m + 1列的增广矩阵，从0开始 int gauss(int n, int m, vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; \u0026amp;a, const int \u0026amp;p) { // 传入模p int r, c; // 当前行和当前列 for (r = c = 0; c \u0026lt; m \u0026amp;\u0026amp; r \u0026lt; n; ++c) { int maxr = r; // 记录最大值 for (int i = r + 1; i \u0026lt; n; ++i) if (abs(a[i][c]) \u0026gt; abs(a[maxr][c])) maxr = i; // 寻找当前列中从当前行开始的绝对值的最大值 if (maxr ^ r) swap(a[r], a[maxr]); // 交换两行 if (!a[r][c]) continue; // 如果为0 for (int i = r + 1; i \u0026lt; n; ++i) { if (!a[i][c]) continue; // 如果当前列中 改行已经为0 int LCM = lcm(abs(a[i][c]), abs(a[r][c])); int x = LCM / abs(a[i][c]), y = LCM / abs(a[r][c]); // 使该行乘x，当前行乘y使得他们在当前列的数都变成同一个数 if (a[i][c] * a[r][c] \u0026lt; 0) y = -y; // 如果有一个是负数 for (int j = c; j \u0026lt;= m; ++j) a[i][j] = ((a[i][j] * x - a[r][j] * y) % p + p) % p; } ++r; } for (int i = r; i \u0026lt; n; ++i) if (a[i][c]) return 0; // 无解 if (r \u0026lt; m) return -1; // 无穷解 for (int i = m - 1; ~i; --i) { int tmp = a[i][m]; for (int j = i + 1; j \u0026lt; m; ++j) { if (!a[i][j]) continue; tmp -= ans[j] * a[i][j]; tmp = ((tmp % p) + p) % p; } ans[i] = tmp * inv(a[i][i], p) % p; // 求逆元可以换成别的方式求 } return 1; } vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; mat; char str[110]; int main() { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { mat.clear(); scanf(\u0026#34;%d %s\\n\u0026#34;, \u0026amp;p, str + 1); int n = strlen(str + 1); for (int i = 1; i \u0026lt;= n; ++i) { mat.push_back(vector\u0026lt;int\u0026gt;(n + 1, 0)); if (str[i] != \u0026#39;*\u0026#39;) mat[i - 1][n] = str[i] - \u0026#39;a\u0026#39; + 1; for (int j = 0; j \u0026lt; n; ++j) mat[i - 1][j] = powf(i, j, p); } int res = gauss(n, n, mat, p); for (int i = 0; i \u0026lt; n; ++i) printf(\u0026#34;%d \u0026#34;, ans[i]); puts(\u0026#34;\u0026#34;); } return 0; } 异或的高斯消元法（带解决自由变元的），POJ1681 Painter\u0026rsquo;s Problem 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 //POJ1681 Painter\u0026#39;s Problem #include \u0026lt;vector\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 305; int ans[N], freew[N]; // 记录答案和记录自由变元是哪些 int gauss(int n, int m, vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; \u0026amp;a) { // n行m + 1列的增广矩阵 int num = 0, r, c; // 自由变元的个数 当前行 当前列 for (int i = 0; i \u0026lt; n; ++i) ans[i] = freew[i] = 0; // 初始化答案和自由变元 for (r = c = 0; r \u0026lt; n \u0026amp;\u0026amp; c \u0026lt; m; ++c) { int maxr = r; // 记录最大值 for (int i = r + 1; i \u0026lt; n \u0026amp;\u0026amp; !a[maxr][c]; ++i) maxr = i; // 查找1 if (maxr ^ r) swap(a[r], a[maxr]); // 交换两行 if (!a[r][c]) {// 如果这个数是0， 则说明第c个变元是自由变元 freew[num++] = c; // 记录自由变元 continue; } for (int i = r + 1; i \u0026lt; n; ++i) { // 消元，消成一个上三角 if (!a[i][c]) continue; //如果该行的当前列是0则该行不作消元 for (int j = m; j \u0026gt;= c; --j) a[i][j] ^= a[r][j]; // 直接异或，和加法不同 } ++r; } for (int i = r; i \u0026lt; n; ++i) if (a[i][m]) return -1; // 无解 int cnt = 1 \u0026lt;\u0026lt; (n - r), ret = 1 \u0026lt;\u0026lt; 29; // 自由变元的取值方案数， 记录最小操作数 for (int i = 0; i \u0026lt; cnt; ++i) { // 状态压缩求解 int res = 0, indx = i; // 当前方案的最小操作数， 操作方案 for (int j = 0; j \u0026lt; num; ++j, indx \u0026gt;\u0026gt;= 1) { ans[freew[j]] = indx \u0026amp; 1; res += indx \u0026amp; 1; // 如果是1则说明这个地方需要操作，固操作数+1 } for (int j = r - 1; j \u0026gt;= 0; --j) { ans[j] = a[j][m]; // 记录答案 for (int k = j + 1; k \u0026lt; m; ++k) { if (a[j][k]) ans[j] ^= ans[k]; // 如果这个数的系数不为0 } res += ans[j]; // 增加操作数 } ret = min(res, ret); // 取最小值 } return ret; } vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; mat; int n; const int dx[] = {0, 1, 0, -1, 0}; const int dy[] = {0, 0, 1, 0, -1}; char g[30][30]; bool check(int r, int c) { return r \u0026gt;= 0 \u0026amp;\u0026amp; c \u0026gt;= 0 \u0026amp;\u0026amp; r \u0026lt; n \u0026amp;\u0026amp; c \u0026lt; n; } int main() {\tint _; scanf(\u0026#34;%d\u0026#34;, \u0026amp;_); for (int t = 1; t \u0026lt;= _; ++t) { mat.clear(); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); mat.resize(n * n, vector\u0026lt;int\u0026gt;(n * n + 1, 0)); for (int i = 0, r = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; n; ++j, ++r) { for (int k = 0; k \u0026lt; 5; ++k) { int nr = i + dx[k], nc = j + dy[k]; if (check(nr, nc)) mat[r][nr * n + nc] = 1; } } } for (int i = 0, r = 0; i \u0026lt; n; ++i) { scanf(\u0026#34;%s\u0026#34;, g[i]); for (int j = 0; j \u0026lt; n; ++j, ++r) { if (g[i][j] == \u0026#39;w\u0026#39;) mat[r][n * n] = 1; } } int res = gauss(n * n, n * n, mat); printf(\u0026#34;%d\\n\u0026#34;, res); } return 0; } 8. 卢卡斯定理 lucas 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const ll mod = 10007;// 注意lucas算法，mod必须为质数 ll fac[mod + 10], inv[mod + 10]; void fny(const int \u0026amp;n, ll *inv, const ll mod) { fac[0] = fac[1] = inv[0] = inv[1] = 1; for (ll i = 2; i \u0026lt;= n; i++) { inv[i] =((mod - mod / i) * inv[mod % i]) % mod; fac[i] = fac[i - 1] * i % mod; } } ll comb(ll n, ll m) { if (m \u0026gt; n) return 0; return fac[n] * inv[fac[n - m] * fac[m] % mod] % mod; } ll lucas(ll n, ll m) { // 本函数不考虑comb的时间复杂度的话就是O(logmod) if (m == 0) return 1; if (n \u0026lt; mod) return comb(n, m); return comb(n % mod, m % mod) * lucas(n / mod, m / mod) % mod; } exlucas 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 ll powf(ll a, ll b, const ll mod) {// 返回a^b % mod ll res = 1; for (a %= mod; b; b \u0026gt;\u0026gt;= 1, a = a * a % mod) if (b \u0026amp; 1) res = res * a % mod; return res; } void exgcd(ll a, ll b, ll \u0026amp;g, ll \u0026amp;x, ll \u0026amp;y) { if (!b) { g = a, x = 1, y = 0; return; } exgcd(b, a % b, g, y, x); y -= x * (a / b); } // ax=1(mod m) ll inverse(ll a, ll m) {//扩展欧几里得法求逆元，返回-1代表没有逆元 ll g, x, y; exgcd(a, m, g, x, y); return g == 1 ? (x % m + m) % m : -1; } ll crt(ll *a, ll *b, int n) {// x % b[i] = a[i], 返回最小的x， b[i]中互质， O(nlogn) ll mul = 1, ret = 0; for (int i = 0; i \u0026lt; n; ++i) mul *= b[i]; for (int i = 0; i \u0026lt; n; ++i) { ll minlcm = mul / b[i]; ll inv = inverse(minlcm, b[i]); // 求逆元 ret = (ret + minlcm * inv * a[i]) % mul; } return (ret + mul) % mul; } ll cal(ll n, ll p, ll pk) { // 计算n!中取出所有p因子后mod pk的结果 if (n == 0) return 1; ll res = 1; for (int i = 1; i \u0026lt; pk; ++i) { if (i % p) res = res * i % pk; } res = powf(res, n / pk, pk); int len = n % pk; for (int i = 1; i \u0026lt;= len; ++i) { if (i % p) res = res * i % pk; } return res * cal(n / p, p, pk) % pk; } ll comb(ll n, ll m, ll p, ll pk) {// 计算C(n, m) % pk的结果，其中p^k = pk if (n \u0026lt; m) return 0; ll up = cal(n, p, pk), down = cal(m, p, pk) * cal(n - m, p, pk) % pk, cnt = 0; for (ll i = n; i; i /= p) cnt += i / p; for (ll i = m; i; i /= p) cnt -= i / p; for (ll i = n - m; i; i /= p) cnt -= i / p; return up * inverse(down, pk) % pk * powf(p, cnt, pk) % pk; } //直接调用此函数即可,时间复杂度应该是O(p + logn*logp), 因此此时n和m可以很大 ll exlucas(ll n, ll m, ll p) { // 计算C(n, m) % p，其中p不为质数 ll b[50], a[50], len = 0, tmp = p; for (ll i = 2; i * i \u0026lt;= tmp; ++i) { if (tmp % i) continue; b[len] = 1; while (tmp % i == 0) b[len] *= i, tmp /= i; a[len] = comb(n, m, i, b[len]); len += 1; } if (tmp \u0026gt; 1) b[len] = tmp, a[len] = comb(n, m, tmp, tmp), len += 1; return crt(a, b, len); } 9. 线性基 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 struct LB { using ll = long long; ll d[65], cnt, num; // cnt 原序列的个数， num 基的个数 bool re; LB () : cnt(0), num(0), re(false) { memset(d, 0, sizeof d); } // 添加一个数x void add(ll x) { ++cnt; for (int i = 60; ~i \u0026amp;\u0026amp; x; --i) { if ((x \u0026gt;\u0026gt; i) \u0026amp; 1) { if (d[i]) x ^= d[i]; else d[i] = x, x = 0, ++num, re = 0; } } } // 询问是否能异或出x bool check(ll x) { for (int i = 60; ~i \u0026amp;\u0026amp; x; --i) { if ((x \u0026gt;\u0026gt; i) \u0026amp; 1) { if (d[i]) x ^= d[i]; else return true; } } return false; } ll get_max() { ll res = 0; for (int i = 60; ~i; --i) { if ((d[i] ^ res) \u0026gt; res) res ^= d[i]; } return res; } // 求的是线性基的异或最小值，不是原序列，否则要特判是否为0 ll get_min() { for (int i = 0; i \u0026lt;= 60; ++i) { if (d[i]) return d[i]; } } void rebuild() { for (int i = 0; i \u0026lt;= 60; ++i) { for (int j = 0; j \u0026lt; i; ++j) { if ((d[i] \u0026gt;\u0026gt; j) \u0026amp; 1) { d[i] ^= d[j]; } } } re = true; } ll k_th(ll k) { if (!re) rebuild(); if (k == 1 \u0026amp;\u0026amp; num \u0026lt; cnt) return 0; // 如果异或得到0 if (num \u0026lt; cnt) --k; ll res = 0; for (int i = 0; i \u0026lt;= 60; ++i) { if (d[i]) { if (k \u0026amp; 1) res ^= d[i]; k \u0026gt;\u0026gt;= 1; } } return res; } }; 10. 中国剩余定理 Crt 1 2 3 4 5 6 7 8 9 10 ll crt(ll *a, ll *b, int n) {// x % b[i] = a[i], 返回最小的x， b[i]中互质， O(nlogn) ll mul = 1, ret = 0; for (int i = 0; i \u0026lt; n; ++i) mul *= b[i]; for (int i = 0; i \u0026lt; n; ++i) { ll minlcm = mul / b[i]; ll inv = inverse(minlcm, b[i]); // 求逆元 ret = (ret + minlcm * inv * a[i]) % mul; } return (ret + mul) % mul; } ExCrt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 ll mul(ll a, ll b, ll p) { ll res = 0; for (a %= p; b; b \u0026gt;\u0026gt;= 1) { if (b \u0026amp; 1) res = (res + a) % p; a = (a + a) % p; } return res; } void exgcd(ll a, ll b, ll \u0026amp;g, ll \u0026amp;x, ll \u0026amp;y) { if (!b) { g = a, x = 1, y = 0; return; } exgcd(b, a % b, g, y, x); y -= x * (a / b); } ll excrt(ll *a, ll *b, int n) {// x % b[i] = a[i], 返回最小的x ll res = a[0], minlcm = b[0], x, y, g; for (int i = 1; i \u0026lt; n; ++i) { ll c = (a[i] - res % b[i] + b[i]) % b[i]; exgcd(minlcm, b[i], g, x, y); if (c % g != 0) return -1; // 无解 x = mul(x, c / g, b[i] / g);// 快速乘 res += x * minlcm; minlcm *= b[i] / g; res = (res % minlcm + minlcm) % minlcm; } return (res % minlcm + minlcm) % minlcm; } 11. 欧拉函数 线性版O(n) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void getphi() { phi[1] = 1; for (int i = 2; i \u0026lt; M; ++i) { if (!isp[i]) pri[cnt++] = i, phi[i] = i - 1; for (int j = 0; j \u0026lt; cnt \u0026amp;\u0026amp; i * pri[j] \u0026lt; M; ++j) { isp[i * pri[j]] = 1; if (i % pri[j] == 0) { phi[i * pri[j]] = pri[j] * phi[i]; break; } else { phi[i * pri[j]] = (pri[j] - 1) * phi[i]; } } } } 12. 求组合数 递推版，针对取余p为质数（如果有的话），且m较小的情况,O(m) 1 2 3 4 5 6 ll comb(ll n, ll m) { if (n \u0026lt; m) return 0; ll ret = 1; for (int i = 1; i \u0026lt;= m; ++i) ret = ret * (n - i + 1) / i; return ret; } 素因子版，针对取余p不为质数，其n较小的情况，O(nlogn) 1 2 3 4 5 6 7 8 9 10 11 12 13 // 计算分子分母的素数个数差来计算结果O(nlogn),需要用到质数表，和快速幂 ll comb(int n, int m, int p) {// 求C(n, m) % p的结果，其中n, m \u0026lt;= 1e6, p \u0026lt;= 1e9 if (n \u0026lt; m) return 0; ll res = 1; for (int i = 0; i \u0026lt; cnt \u0026amp;\u0026amp; pri[i] \u0026lt;= n; ++i) { int num = 0; for (int j = n; j; j /= pri[i]) num += j / pri[i]; for (int j = m; j; j /= pri[i]) num -= j / pri[i]; for (int j = n - m; j; j /= pri[i]) num -= j / pri[i]; res = res * powf(pri[i], num, p) % p; } return res; } 三、数据结构 1. 并查集 简便的路径压缩版 1 2 3 4 5 6 7 8 9 10 11 12 13 const int Max = 1e5 + 10; int fa[Max]; inline void init() { for (int i = 0; i \u0026lt; Max; i++) fa[i] = i; } int findfa(int x) { return x == fa[x] ? x : fa[x] = findfa(fa[x]); } void Un(int a, int b) { int fa1 = findfa(a); int fa2 = findfa(b); if (fa1 != fa2) fa[fa1] = fa2; } 网络赛版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class UF { public: int n; // 当前连通分量数目 int cnt; vector\u0026lt;int\u0026gt; size; vector\u0026lt;int\u0026gt; parent; UF(int _n): n(_n + 1), cnt(_n + 1), size(_n + 1, 1), parent(_n + 1) { int i = 0; for (auto \u0026amp;x : parent) x = i++; } int findset(int x) { return parent[x] == x ? x : parent[x] = findset(parent[x]); } bool unite(int x, int y) { x = findset(x); y = findset(y); if (x == y) { return false; } if (size[x] \u0026lt; size[y]) { swap(x, y); } parent[y] = x; size[x] += size[y]; --cnt; return true; } bool conn(int x, int y) { x = findset(x); y = findset(y); return x == y; } }; 2. 树状数组 单点修改与区间查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 修改复杂度与查询复杂度O(logn) #define lb(x) ((x) \u0026amp; (-x)) #define ll long long const int N = 1e6 + 5, M = 2e5 + 5; ll n, m, a[N], bit[N]; // 初始化 void build(int n) { for (int i = 1; i \u0026lt;= n; ++i) { bit[i] += a[i]; int j = lb(i) + i; if (j \u0026lt;= n) bit[j] += bit[i]; } } // 单点修改 void update(int index, ll val) { a[index] += val; while (index \u0026lt;= n) { bit[index] += val; index += lb(index); } } // 前缀查询 ll get(int index) { ll res = 0; while (index) { res += bit[index]; index -= lb(index); } return res; } // 区间和查询 ll get(int l, int r) { return get(r) - get(l - 1); } 区间修改，区间查询 设$d[i] = a[i] - a[i - 1]$ 则 $a[ x ] = \\sum_{i = 1}^{x}{d_i}$ 设 $sum[ x ] = \\sum_{i = 1}^{x}{a_i}$ 即 $sum[ x ] = d[1] + d[1] + d[2] + d[1] + d[2] + d[3] + …… + d[1] + ……+ d[n]$ 化简得 $sum[ x ] = \\sum_{i = 1}^{x}{d_i \\times (n - i + 1)}$ 得 $sum[ x ] = (n + 1) \\times \\sum_{i = 1}^{x}{d_i} - \\sum_{i = 1}^{x}{i \\times d_i}$ 固开两个树状数组，一个维护差分数组$d_i$，一个维护$i \\times d_i$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #define lb(x) ((x) \u0026amp; (-x)) #define int long long const int N = 5e3 + 5, M = 1e6 + 5; int n, m, d[M], id[M]; // 基础树状数组单点更新 void update(int i, int val, int *bit) { while (i \u0026lt;= n) { bit[i] += val; i += lb(i); } } // 单点修改 void update(int i, int val) { update(i, val, d), update(i, val * i, id); } // 区间修改 void update(int l, int r, int val) { update(l, val, d), update(r + 1, -val, d); update(l, l * val, id), update(r + 1, (-val) * (r + 1), id); } // 前缀查询 int get(int i, int *bit) { int res = 0; while (i) res += bit[i], i -= lb(i); return res; } // 区间和查询 int get(int l, int r) { int res = get(r, d) * (r + 1) - get(r, id); res -= get(l - 1, d) * l - get(l - 1, id); return res; } 网络赛类封装版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 template\u0026lt;class T\u0026gt; class fenwich{ #define lowbit(x) ((x) \u0026amp; (-x)) vector\u0026lt;T\u0026gt; v; int len; T get_pre(int i) { T res = 0; for(; i \u0026gt; 0; i -= lowbit(i)) res += v[i]; return res; } public: fenwich (int len) : v(len + 1, 0), len(len) {} void resize(int n, T x = 0) { v.resize(n + 1, x), len = n; } void modify(int i, T val) { // 单点修改 for (; i \u0026lt;= len; i += lowbit(i)) v[i] += val; } T operator() (int l, int r) { // 区间查询 if (l \u0026gt; r) return 0; return get_pre(r) - get_pre(l - 1); } #undef lowbit }; 3. 线段树 精简版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // 宏 #define ls ((node) \u0026lt;\u0026lt; 1) #define rs (((node) \u0026lt;\u0026lt; 1) | 1) // 变量 const int N = 2e5 + 5; ll seg[N \u0026lt;\u0026lt; 2], lazy[N \u0026lt;\u0026lt; 2], arr[N]; // 操作 ll op(ll a, ll b) { return a + b; } // 题意不同，函数内部不同 void push_down(int l, int r, int node) { if (!lazy[node]) return; // 这里如果0也有意义的话多开一个数组标记 int mid = (l + r) \u0026gt;\u0026gt; 1; lazy[ls] += lazy[node], lazy[rs] += lazy[node]; seg[ls] += (mid - l + 1) * lazy[node]; seg[rs] += (r - mid) * lazy[node]; lazy[node] = 0; } // 初始化 void build(int l, int r, int node) { if (l == r) { seg[node] = arr[l]; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, ls), build(mid + 1, r, rs); seg[node] = op(seg[ls], seg[rs]); } // 单点修改 void update(int indx, ll v, int l, int r, int node) { if (l == r) { // 题意不同，这里更新操作不同 seg[node] = v; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (indx \u0026lt;= mid) update(indx, v, l, mid, ls); else update(indx, v, mid + 1, r, rs); seg[node] = op(seg[ls], seg[rs]); } // 区间修改 void update(int ql, int qr, ll v, int l, int r, int node) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) { // 题意不同，这里更新操作不同 lazy[node] += v; seg[node] += (r - l + 1) * v; return; } push_down(l, r, node); int mid = (l + r) \u0026gt;\u0026gt; 1; if (ql \u0026lt;= mid) update(ql, qr, v, l, mid, ls); if (qr \u0026gt; mid) update(ql, qr, v, mid + 1, r, rs); seg[node] = op(seg[ls], seg[rs]); } // 区间查找 ll get(int ql, int qr, int l, int r, int node) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return seg[node]; push_down(l, r, node); // 保证单点的情况下这句话可以注释掉 int mid = (l + r) \u0026gt;\u0026gt; 1; ll ret = 0; // 题意不同，初始化不同 if (ql \u0026lt;= mid) ret = get(ql, qr, l, mid, ls); if (qr \u0026gt; mid) ret = op(get(ql, qr, mid + 1, r, rs), ret); return ret; } 结构体版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int M = 1e6; typedef long long ll; template\u0026lt;class T\u0026gt; struct Tree{ #define ls(node) (node \u0026lt;\u0026lt; 1) #define rs(node) ((node \u0026lt;\u0026lt; 1) | 1) Tree(int len = 10): len(len) {} T sum[M \u0026lt;\u0026lt; 2], lazy[M \u0026lt;\u0026lt; 2], arr[M]; int len; private: void pushup(const int node) {// 写题目要求维护的代码，如求和，最大最小…… sum[node] = max(sum[ls(node)], sum[rs(node)]); } void pushdown(int l, int r, const int node) {//同pushup int mid = (l + r) \u0026gt;\u0026gt; 1; lazy[ls(node)] += lazy[node], lazy[rs(node)] += lazy[node]; sum[ls(node)] += (mid - l + 1) * lazy[node]; sum[rs(node)] += (r - mid) * lazy[node]; lazy[node] = 0; } void build(int l, int r, int node) { if (l == r) { sum[node] = arr[l]; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, ls(node)), build(mid + 1, r, rs(node)); pushup(node); } void update(int ql, int qr, T v, int l, int r, int node) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) { sum[node] += (r - l + 1) * v;//更新操作根据题目要求更改 lazy[node] += v; return; } if (lazy[node]) pushdown(l, r, node); int mid = (l + r) \u0026gt;\u0026gt; 1; if (ql \u0026lt;= mid) update(ql, qr, v, l, mid, ls(node)); if (qr \u0026gt; mid) update(ql, qr, v, mid + 1, r, rs(node)); pushup(node); } T getAsk(int ql, int qr, int l, int r, int node) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return sum[node];//上同 if (lazy[node]) pushdown(l, r, node); T res = 0; int mid = (l + r) \u0026gt;\u0026gt; 1; if (ql \u0026lt;= mid) res = getAsk(ql, qr, l, mid, ls(node)); if (qr \u0026gt; mid) res = max(res, getAsk(ql, qr, mid + 1, r, rs(node))); return res; } public: //以下为可以，直接调用的函数 void build() { build(1, len, 1); } void update(int ql, int qr, T v) { update(ql, qr, v, 1, len, 1); } void update(int index, T v) { update(index, index, v, 1, len, 1); } T getAsk(int ql, int qr) { return getAsk(ql, qr, 1, len, 1); } void clear() { memset(arr, 0, sizeof(T) * (len + 10)); memset(sum, 0, sizeof(T) * (len \u0026lt;\u0026lt; 2)); memset(lazy, 0, sizeof(T) * (len \u0026lt;\u0026lt; 2)); } T\u0026amp; operator[] (int x) { return arr[x]; } }; int main(){ return 0; } 类版-网络赛 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; /** * 使用说明： * 本线段树板子可用于多数 网络赛 * 需要注意的是此板子在性能方面由于三层封装，固较简洁版的线段树性能慢，但灵活性高（适合网络赛抢时间） * 使用时只需要修改 \u0026#34;可修改区的上下界\u0026#34; 中间的代码部分 * lazy使用结构体封装是应付在某些题目在区间修改时有两种操作，下面给的例题有示例 * vals是最终题目需要维护的东西（sum, max, min……），针对不同的操作只需修改结构体内的加法（+）操作即可 * 同时若题目需要区间修改，则直接修改区间修改部分的代码即可，单点修改同理 * 注意：区间修改针对不同的操作，lazy中的加等于（+=）也要具体根据题意修改 * 例题1：洛谷 */ /****************************可修改区上界******************************/ template\u0026lt;class T\u0026gt; struct lazy{ T lazy1; lazy(T lazy1 = 0){ this-\u0026gt;lazy1 = lazy1; } void operator+= (const lazy\u0026lt;T\u0026gt; \u0026amp;b) { this-\u0026gt;lazy1 += b.lazy1;//常见操作 } inline void del() { this-\u0026gt;lazy1 = 0; // 常见操作 } }; template\u0026lt;class T\u0026gt; struct vals{ T sum; //初始化构造，用来方便做运算的初始化- vals(int x = 0) { sum = x;//常见初始化，方便后面做 + 的操作 } // 操作区 constexpr vals operator+ (const vals\u0026amp; b){ vals res; res.sum = this-\u0026gt;sum + b.sum;//常见操作 return res; } //建树初始化区 inline void init(const T \u0026amp;v) { // this-\u0026gt;sum = v; // 常见操作，即和本身一样 } // 区间更新区 inline void update(const int \u0026amp;l, const int \u0026amp;r, const lazy\u0026lt;T\u0026gt; \u0026amp;v) { // this-\u0026gt;sum += (r - l + 1) * v.lazy1;// 常见操作 // printf(\u0026#34;%d %d %d %d\\n\u0026#34;, l, r, v, (r - l + 1) * v); // 常见操作 } // 单点更新区 inline void update(const lazy\u0026lt;T\u0026gt; \u0026amp;v) { // this-\u0026gt;sum += v; // 常见操作 } //初始化，通常在多组输入题时才调用 inline void del() { this-\u0026gt;sum = 0; } }; /****************************可修改区下界******************************/ /********************************以下区域建议不动（除特殊题目）*************************************/ template\u0026lt;class T\u0026gt; class segtree{ private: const static int maxn = 1e5 + 10; const int start = 1; struct lazy_tabs{ lazy\u0026lt;T\u0026gt; v; bool flag; lazy_tabs (bool flag = false) : flag(flag) {} // 懒标记更新 void update(const lazy\u0026lt;T\u0026gt; \u0026amp;v) { this-\u0026gt;v += v, flag = true; } // 懒标记删除 void del() { this-\u0026gt;v.del(), flag = false; } }lazy_tab[maxn \u0026lt;\u0026lt; 2]; vals\u0026lt;T\u0026gt; val[maxn \u0026lt;\u0026lt; 2]; //计算左右孩子节点下标 inline static constexpr int ls(const int \u0026amp;indx) { return indx \u0026lt;\u0026lt; 1;} inline static constexpr int rs(const int \u0026amp;indx) { return indx \u0026lt;\u0026lt; 1 | 1;} // 上放 inline void push_up(const int \u0026amp;pos) { val[pos] = val[ls(pos)] + val[rs(pos)]; } // 下放 void push_down(const int \u0026amp;l, const int \u0026amp;r, const int \u0026amp;pos) { if (!lazy_tab[pos].flag) return; // 若没有标记则返回 const auto \u0026amp;v = lazy_tab[pos].v; lazy_tab[ls(pos)].update(v), lazy_tab[rs(pos)].update(v); const int mid = (l + r) \u0026gt;\u0026gt; 1; val[ls(pos)].update(l, mid, v), val[rs(pos)].update(mid + 1, r, v); // 更新儿子节点 lazy_tab[pos].del(); } // 建树 void build(const int \u0026amp;l, const int \u0026amp;r, const int \u0026amp;pos, const T *a) { if (l == r) { val[pos].init(a[l]); return; } const int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, ls(pos), a), build(mid + 1, r, rs(pos), a); push_up(pos); } // 单点修改 void update(const int \u0026amp;indx, const int \u0026amp;l, const int \u0026amp;r, const lazy\u0026lt;T\u0026gt; \u0026amp;v, const int \u0026amp;pos) { if (l == r) { val[pos].update(v); return; } const int mid = (l + r) \u0026gt;\u0026gt; 1; if (indx \u0026lt;= mid) update(indx, l, mid, ls(pos)); else update(indx, mid + 1, r, rs(pos)); push_up(pos); } //区间修改 void update(const int \u0026amp;ql, const int \u0026amp;qr, const lazy\u0026lt;T\u0026gt; \u0026amp;v, const int \u0026amp;l, const int \u0026amp;r, const int \u0026amp;pos) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) { // 如果在查询区间内 lazy_tab[pos].update(v); //懒更新 val[pos].update(l, r, v); // 区间值更新 return; } push_down(l, r, pos); const int mid = (l + r) \u0026gt;\u0026gt; 1; if (ql \u0026lt;= mid) update(ql, qr, v, l, mid, ls(pos)); if (qr \u0026gt; mid) update(ql, qr, v, mid + 1, r, rs(pos)); push_up(pos); } //区间查询 vals\u0026lt;T\u0026gt; get(const int \u0026amp;ql, const int \u0026amp;qr, const int \u0026amp;l, const int \u0026amp;r, const int \u0026amp;pos) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return val[pos]; push_down(l, r, pos); vals\u0026lt;T\u0026gt; res; const int mid = (l + r) \u0026gt;\u0026gt; 1; if (ql \u0026lt;= mid) res = res + get(ql, qr, l, mid, ls(pos)); if (qr \u0026gt; mid) res = res + get(ql, qr, mid + 1, r, rs(pos)); return res; } public: /***********************一下均可调用****************************************/ int n; segtree (int n = -1) : n(n) {} // 建树 void build(T *a) { build(start, n, start, a); } // 查询 vals\u0026lt;T\u0026gt; get(int ql, int qr) { return get(ql, qr, start, n, start); } //单点修改 void update(int indx, lazy\u0026lt;T\u0026gt; val) { update(indx, start, n, val, start); } //区间修改 void update(int ql, int qr, lazy\u0026lt;T\u0026gt; val) { update(ql, qr, val, start, n, start); } //清空- // 切记，先用再清空，因为通常是多组输入时太调用 void clear() { assert(n != -1); int len = n \u0026lt;\u0026lt; 2; assert(n \u0026lt; maxn); for (int i = 1; i \u0026lt;= len; ++i) { lazy_tab[i].del(); val[i].del(); } } }; int main() { #ifndef ONLINE_JUDGE freopen(\u0026#34;D:/MYCODE/vsCode-c/test.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;D:/MYCODE/vsCode-c/test.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif return 0; } 4. ST表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const int M = 1e5 + 5; int st[M][30], lg[M]; // st表预处理, 注意下标从1开始到n结束 void init(int *a, int n) { lg[0] = -1; for (int i = 1; i \u0026lt;= n; ++i) lg[i] = lg[i \u0026gt;\u0026gt; 1] + 1, st[i][0] = a[i]; for (int j = 1; j \u0026lt;= lg[n]; ++j) { int k = 1 \u0026lt;\u0026lt; (j - 1); for (int i = 1; i + k - 1 \u0026lt;= n; ++i) { st[i][j] = max(st[i][j - 1], st[i + k][j - 1]); } } } // 询问 // 尽可能让l + 2^(len) - 1接近r int get(int l, int r) { int x = lg[r - l + 1]; return max(st[l][x], st[r - (1 \u0026lt;\u0026lt; x) + 1][x]); } 5. 分块 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const int N = 1e5 + 5, M = 500; #define ll long long ll a[N]; int belong[N]; struct blocks { int l, r; ll lazy; blocks() : lazy(0){} }b[M]; // 以下函数是基本不变的 void build(int n) { int siz = sqrt(n), cnt = n / siz; if (n % siz) ++cnt; for (int i = 1; i \u0026lt;= cnt; ++i) { b[i].l = (i - 1) * siz + 1; b[i].r = i * siz; } b[cnt].r = n; for (int i = 1; i \u0026lt;= n; ++i) belong[i] = (i - 1) / siz + 1; } 6. 莫队 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int M = 1e5 + 10; int n, m, block, arr[M], pos[M], ans[M], res; struct MO{ int l, r, k; MO(int l = 0, int r = 0, int k = 0) : l(l), r(r), k(k) {} }q[M]; bool cmp(MO a, MO b) { if (pos[a.l] ^ pos[b.l]) {//不在同一个块 return pos[a.l] \u0026lt; pos[b.l]; } if (pos[a.l] \u0026amp; 1) return a.r \u0026lt; b.r; return b.r \u0026lt; a.r; } void add(int x) { } void del(int x) { } void solve() { int l = 1, r = 0; for (int i = 0; i \u0026lt; m; i++) { while (l \u0026gt; q[i].l) add(--l); while (r \u0026lt; q[i].r) add(++r); while (l \u0026lt; q[i].l) del(l++); while (r \u0026gt; q[i].r) del(r--); ans[q[i].k] = res;//res根据题目意思来 } } void init() { scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); block = sqrt(n); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, arr + i); pos[i] = i / block; } for (int i = 0; i \u0026lt; m; i++) { int l, r; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;l, \u0026amp;r); q[i] = MO(l, r, i); } sort(q, q + m, cmp); } int main() { init(); solve(); return 0; } 7. 平衡树 fhq treap 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 // 洛谷板子题 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;random\u0026gt; #include \u0026lt;cctype\u0026gt; inline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == \u0026#39;-\u0026#39;) f = true; c = getchar(); } while (isdigit(c)) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c - \u0026#39;0\u0026#39;); c = getchar(); } return f ? -x : x; } using namespace std; const int N = 4e5 + 10; mt19937 rnd(233); struct treap{ int val, l, r, size, key; }fhq[N]; int root, cnt; inline void update(int now) { fhq[now].size = fhq[fhq[now].l].size + fhq[fhq[now].r].size + 1; } int new_node(int val) { fhq[++cnt] = {.val = val, .l = 0, .r = 0, .size = 1, .key = rnd()}; return cnt; } void split(int now, int val, int \u0026amp;x, int \u0026amp;y) { if (!now) { x = y = 0; return; } if (fhq[now].val \u0026lt;= val) x = now, split(fhq[now].r, val, fhq[now].r, y); else y = now, split(fhq[now].l, val, x, fhq[now].l); update(now); } int merge(int x, int y) { if (!x || !y) return x | y; // 大根堆 if (fhq[x].key \u0026gt; fhq[y].key) { //右下角 fhq[x].r = merge(fhq[x].r, y), update(x); return x; } // 左下角 fhq[y].l = merge(x, fhq[y].l), update(y); return y; } // 插入 inline void insert(int val) { int x, y; split(root, val, x, y); root = merge(merge(x, new_node(val)), y); } // 按值删除 inline void del(int val) { int x, y, z; split(root, val, x, z); split(x, val - 1, x, y); y = merge(fhq[y].l, fhq[y].r); root = merge(merge(x, y), z); } // 按值获取排名 inline int getrank(int val) { int x, y, ans; split(root, val - 1, x, y); ans = fhq[x].size + 1; root = merge(x, y); return ans; } // 按排名获取值 inline int getval(int rank) { int now = root; while (now) { if (fhq[fhq[now].l].size + 1 == rank) break; else if (fhq[fhq[now].l].size \u0026gt;= rank) now = fhq[now].l; else rank -= fhq[fhq[now].l].size + 1, now = fhq[now].r; } return fhq[now].val; } // 求前驱，即严格比val小的最大值 inline int pre(int val) { int x, y; split(root, val - 1, x, y); int now = x; while (fhq[now].r) now = fhq[now].r; root = merge(x, y); return fhq[now].val; } // 求后继，即严格比val大的最小值 inline int nxt(int val) { int x, y; split(root, val, x, y); int now = y; while (fhq[now].l) now = fhq[now].l; root = merge(x, y); return fhq[now].val; } int main() { int t = IO(); while (t--) { int q = IO(), val = IO(); if (q == 1) insert(val); else if (q == 2) del(val); else if (q == 3) printf(\u0026#34;%d\\n\u0026#34;, getrank(val)); else if (q == 4) printf(\u0026#34;%d\\n\u0026#34;, getval(val)); else if (q == 5) printf(\u0026#34;%d\\n\u0026#34;, pre(val)); else printf(\u0026#34;%d\\n\u0026#34;, nxt(val)); } return 0; } spaly 替罪羊 8. 左偏树 9. 主席树 主席树（静态）洛谷模板题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cctype\u0026gt; inline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == \u0026#39;-\u0026#39;) f = true; c = getchar(); } while (isdigit(c)) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c - \u0026#39;0\u0026#39;); c = getchar(); } return f ? -x : x; } using namespace std; /*************************************离散化********************************************/ // vt存放可用于查询原本的数（用离散化值），打表后用于查询离散化表（用下标） vector\u0026lt;int\u0026gt; vt; inline int get_id(const int \u0026amp;x) { return lower_bound(vt.begin(), vt.end(), x) - vt.begin() + 1; } inline void erase_vt() { sort(vt.begin(), vt.end()); vt.erase(unique(vt.begin(), vt.end()), vt.end()); } // 打表, 注意，原数组下标要从1开始，返回离散化后的表大小 inline int id_table(int n, int *a, vector\u0026lt;int\u0026gt; \u0026amp;res) { res.emplace_back(0); for (int i = 1; i \u0026lt;= n; ++i) res.emplace_back(get_id(a[i])); return vt.size(); } /*************************************主席树********************************************/ const int N = 2e5 + 5; struct nodes{ int l, r, sum; nodes() : sum(0) {} }hjt[N \u0026lt;\u0026lt; 5]; int root[N], cnt; // 记录每个根结点的内存池编号， 内存池 int build(int l, int r) { int now = ++cnt; // 内存申请 if (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; hjt[now].l = build(l, mid); hjt[now].r = build(mid + 1, r); } return now; } // 插入新节点的操作 int update(int pre, int l, int r, int x) { int now = ++cnt; // 内存申请 hjt[now] = hjt[pre], ++hjt[now].sum; // 继承 if (l \u0026lt; r) { // 寻找拼接点 int mid = (l + r) \u0026gt;\u0026gt; 1; if (x \u0026lt;= mid) hjt[now].l = update(hjt[now].l, l, mid, x); // 如果x在左边，则让当前新节点的左孩子接继承后的左孩子 else hjt[now].r = update(hjt[now].r, mid + 1, r, x); // 否则同理 } return now; } // 返回第qr版本的主席树 - 第ql版本的主席树， 注意返回的是离散化后的值 int get(int ql, int qr, int l, int r, int k) { if (l == r) return l; int mid = (l + r) \u0026gt;\u0026gt; 1; int dif = hjt[hjt[qr].l].sum - hjt[hjt[ql].l].sum; if (k \u0026lt;= dif) return get(hjt[ql].l, hjt[qr].l, l, mid, k); // 左孩子上 return get(hjt[ql].r, hjt[qr].r, mid + 1, r, k - dif); // 右孩子上 } /*************************************主函数********************************************/ int a[N]; int main() { int n = IO(), m = IO(); for (int i = 1; i \u0026lt;= n; ++i) a[i] = IO(), vt.emplace_back(a[i]); erase_vt(); vector\u0026lt;int\u0026gt; id; int siz = id_table(n, a, id); root[0] = build(1, siz); for (int i = 1; i \u0026lt;= n; ++i) root[i] = update(root[i - 1], 1, siz, id[i]); while (m--) { int l = IO(), r = IO(), k = IO(); printf(\u0026#34;%d\\n\u0026#34;, vt[get(root[l - 1], root[r], 1, siz, k) - 1]); } return 0; } 10. LCA 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 // 洛谷板子题 // 注意，尽量让结点编号从1开始 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #define ll long long inline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == \u0026#39;-\u0026#39;) f = true; c = getchar(); } while (isdigit(c)) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c - \u0026#39;0\u0026#39;); c = getchar(); } return f ? -x : x; } using namespace std; const int maxn = 5e5 + 5, maxm = 5e5 + 5; const int INF = 0x3f3f3f3f; int head[maxn], cnt; struct edges { int to, next; void add(int t, int n) { to = t, next = n; } }edge[maxm \u0026lt;\u0026lt; 1]; //无向图则需要乘2 inline void add(int u, int v) { edge[++cnt].add(v, head[u]); head[u] = cnt; } int fa[maxn][35], dep[maxn], lg[maxn]; /* 另一种写法 void dfs(int u, int f) { deep[u] = deep[f] + 1; fa[u][0] = f; for (int i = 1; (1 \u0026lt;\u0026lt; i) \u0026lt;= deep[u]; ++i) fa[u][i] = fa[fa[u][i - 1]][i - 1]; for (int\u0026amp; v : mp[u]) { if (v ^ f) dfs(v, u); } } int lca(int a, int b) { if (deep[a] \u0026lt; deep[b]) swap(a, b); for (int i = 18; ~i; --i) if (deep[fa[a][i]] \u0026gt;= deep[b]) a = fa[a][i]; if (a == b) return a; for (int i = 20; ~i; --i) { if (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i]; } return fa[a][0]; } */ void dfs(int u, int f) { fa[u][0] = f; dep[u] = dep[f] + 1; for (int i = 1; i \u0026lt;= lg[dep[u]]; ++i) fa[u][i] = fa[fa[u][i - 1]][i - 1]; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v ^ f) dfs(v, u); } } void init(int root, int n) { // 通过检查代码，反向51行dep[root] = -1没意义，具体细节以后填这个坑 dep[root] = lg[0] = -1; memset(head, -1, sizeof head); cnt = 0; for (int i = 1; i \u0026lt;= n; ++i) lg[i] = lg[i \u0026gt;\u0026gt; 1] + 1; } int lca(int a, int b) { if (dep[a] \u0026lt; dep[b]) swap(a, b); while (dep[a] \u0026gt; dep[b]) a = fa[a][lg[dep[a] - dep[b]]]; if (a == b) return a; for (int i = lg[dep[a]]; ~i; --i) { if (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i]; } return fa[a][0]; } int main() { int n = IO(), m = IO(), root = IO(); init(root, n); for (int i = 1; i \u0026lt; n; ++i) { int u = IO(), v = IO(); add(u, v), add(v, u); } dfs(root, 0); while (m--) { int a = IO(), b = IO(); printf(\u0026#34;%d\\n\u0026#34;, lca(a, b)); } return 0; } 11. 树链剖分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 // 洛谷板子题 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;bitset\u0026gt; using namespace std; #define ll long long const int N = 1e5 + 5, M = 2e5 + 5; const int maxn = 1e5 + 5, maxm = 2e5 + 5; const int INF = 0x3f3f3f3f; int head[maxn], cnt; //初始化 void init() { memset(head, -1, sizeof head); cnt = -1; } struct edges { int to, next; void add(int t, int n) { to = t, next = n; } }edge[maxm \u0026lt;\u0026lt; 1]; //无向图则需要乘2 inline void add(int u, int v) { edge[++cnt].add(v, head[u]); head[u] = cnt; } /*******************************树链剖分**********************************/ int fa[N], dep[N], siz[N], son[N]; void dfs1(int u, int f) { fa[u] = f, siz[u] = 1; dep[u] = dep[f] + 1; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == f) continue; dfs1(v, u); siz[u] += siz[v]; if (siz[v] \u0026gt; siz[son[u]]) son[u] = v; // 找重儿子 } } int v[N]; // 点上的权值 int tim, dfn[N], top[N], w[N]; // w的下标是时间戳，对应的是相应时间戳上的点的点权 void dfs2(int u, int t) { dfn[u] = ++tim, top[u] = t; w[tim] = v[u]; if (!son[u]) return; dfs2(son[u], t); for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa[u] || v == son[u]) continue; dfs2(v, v); } } /*******************************线段树******************************/ inline int ls(const int\u0026amp; x) { return x \u0026lt;\u0026lt; 1;} inline int rs(const int\u0026amp; x) { return x \u0026lt;\u0026lt; 1 | 1;} ll seg[N \u0026lt;\u0026lt; 2], lazy[N \u0026lt;\u0026lt; 2], p; int n, m; inline ll op(const ll\u0026amp; a, const ll\u0026amp; b) { // seg[x] = max(seg[ls(x)], seg[rs(x)]); return (a + b) % p; } inline void push_down(const int\u0026amp; l, const int\u0026amp; r, const int\u0026amp; node) { if (!lazy[node]) return; lazy[ls(node)] += lazy[node], lazy[rs(node)] += lazy[node]; lazy[ls(node)] %= p, lazy[rs(node)] %= p; int mid = (l + r) \u0026gt;\u0026gt; 1; seg[ls(node)] = (lazy[node] * (mid - l + 1) + seg[ls(node)]) % p; seg[rs(node)] = (lazy[node] * (r - mid) + seg[rs(node)]) % p; lazy[node] = 0; } void build(int l, int r, int node = 1) { if (l == r) { seg[node] = w[l]; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, ls(node)), build(mid + 1, r, rs(node)); seg[node] = op(seg[ls(node)], seg[rs(node)]); } void update(int ql, int qr, ll x, int l = 1, int r = n, int node = 1) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) { lazy[node] = (lazy[node] + x) % p; seg[node] = (seg[node] + (r - l + 1) * x) % p; return; } push_down(l, r, node); int mid = (l + r) \u0026gt;\u0026gt; 1; if (ql \u0026lt;= mid) update(ql, qr, x, l, mid, ls(node)); if (qr \u0026gt; mid) update(ql, qr, x, mid + 1, r, rs(node)); seg[node] = op(seg[ls(node)], seg[rs(node)]); } int get(int ql, int qr, int l = 1, int r = n, int node = 1) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return seg[node]; push_down(l, r, node); int mid = (l + r) \u0026gt;\u0026gt; 1, res = 0; if (ql \u0026lt;= mid) res = get(ql, qr, l, mid, ls(node)); if (qr \u0026gt; mid) res = op(res, get(ql, qr, mid + 1, r, rs(node))); return res; } /********************************树上操作**********************************/ void update_chain(int x, int y, ll z) {// 将树从 x 到 y 结点最短路径上所有节点的值都加上 z。 while (top[x] != top[y]) { if (dep[top[x]] \u0026lt; dep[top[y]]) swap(x, y); update(dfn[top[x]], dfn[x], z); x = fa[top[x]]; } if (dep[x] \u0026gt; dep[y]) swap(x, y); update(dfn[x], dfn[y], z); } ll get_chain(int x, int y) {//求树从 x 到 y 结点最短路径上所有节点的值之和。 int res = 0; while (top[x] != top[y]) { if (dep[top[x]] \u0026lt; dep[top[y]]) swap(x, y); res = op(res, get(dfn[top[x]], dfn[x])); x = fa[top[x]]; } if (dep[x] \u0026gt; dep[y]) swap(x, y); return op(res, get(dfn[x], dfn[y])); } void update_son(int x, ll z) {// 将以 x 为根节点的子树内所有节点值都加上 z update(dfn[x], dfn[x] + siz[x] - 1, z); } ll get_son(int x) {// 求以 x 为根节点的子树内所有节点值之和 return get(dfn[x], dfn[x] + siz[x] - 1); } /********************************主函数************************************/ int main() { std::ios::sync_with_stdio(false); cout.tie(0), cin.tie(0); init(); int root; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; root \u0026gt;\u0026gt; p; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; v[i]; for (int i = 1; i \u0026lt; n; ++i) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; add(u, v), add(v, u); } dfs1(root, root), dfs2(root, root); build(1, n); while (m--) { int q, x, y, z; cin \u0026gt;\u0026gt; q \u0026gt;\u0026gt; x; if (q == 1) { cin \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z; update_chain(x, y, z % p); } else if (q == 2) { cin \u0026gt;\u0026gt; y; cout \u0026lt;\u0026lt; get_chain(x, y) \u0026lt;\u0026lt; endl; } else if (q == 3) { cin \u0026gt;\u0026gt; z; update_son(x, z); } else { cout \u0026lt;\u0026lt; get_son(x) \u0026lt;\u0026lt; endl; } } return 0; } 四、图论 前置存图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const int N = 1e5 + 10, M = 2e5 + 10; const int INF = 0x3f3f3f3f; int head[N], cnt; //初始化 void init(int n) { fill_n(head, n + 5, -1); cnt = -1; } struct edges { int to, next; int w; void add(int t, int n, int w) { to = t, next = n, this-\u0026gt;w = w; } }edge[N \u0026lt;\u0026lt; 1]; //无向图则需要乘2 inline void add(int u, int v, int w) { edge[++cnt].add(v, head[u], w); head[u] = cnt; } 1. 最短路 dijkstra 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 //顶点数和边数 const int maxn = 1e5 + 10, maxm = 2e5 + 10; const int INF = 0x3f3f3f3f; int head[maxn], cnt, dis[maxn]; bool vis[maxn]; //初始化 void init(int n) { // n个点 fill_n(head, n + 1, -1); cnt = 0; } struct edges { int to, next; int w; edges(int to = 0, int next = -1, int w = 0) : to(to), next(next), w(w) {} }edge[maxm \u0026lt;\u0026lt; 1]; //无向图则需要乘2 inline void add_edges(int u, int v, int w) { edge[++cnt] = edges(v, head[u], w); head[u] = cnt; } struct qnode{ int v; int w; qnode(int v = 0, int w = 0) : v(v), w(w) {} bool operator\u0026lt; (const qnode \u0026amp;t) const { return w \u0026gt; t.w; } }; void dij(int n, int s) {//n 为顶点数， m 为边数 for (int i = 0; i \u0026lt;= n; ++i) dis[i] = INF, vis[i] = 0; dis[s] = 0; priority_queue\u0026lt;qnode\u0026gt; heap; heap.push(qnode(s, dis[s])); while (heap.size()) { int u = heap.top().v; heap.pop(); if (vis[u]) continue; vis[u] = true; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; int w = edge[i].w; if (!vis[v] \u0026amp;\u0026amp; dis[u] + w \u0026lt; dis[v]) { //松弛 dis[v] = dis[u] + w; heap.push(qnode(v, dis[v])); } } } } bellman-ford 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 const int maxn = 1e5 + 10, maxm = 2e5 + 10, inf = 0x3f3f3f3f; int dis[maxn]; struct edges { int u, v, w; edges(int u = 0, int v = 0, int w = 0) : u(u), v(v), w(w) {} } edge[maxm]; bool bf(int n, int m, int s) { // n个点， m个边， s为起点 fill_n(dis, n + 1, inf); dis[s] = 0; for (int k = 1; k \u0026lt; n; k++) { int ok = 1; for (int i = 1; i \u0026lt;= m; i++) { if (dis[edge[i].v] \u0026gt; dis[edge[i].u] + edge[i].w) { //松弛 dis[edge[i].v] = dis[edge[i].u] + edge[i].w; ok = 0; } } if (ok) break; // 小优化，无松弛操作 } for (int i = 1; i \u0026lt;= m; i++) { if (dis[edge[i].v] \u0026gt; dis[edge[i].u] + edge[i].w) { return false; // 有负环 } } return true;// 无负环 } spfa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 const int maxn = 1e5 + 10, maxm = 2e5 + 10, inf = 0x3f3f3f3f; int dis[maxn], num[maxn], head[maxn], cnt; //num 数组是判断是否有负环 bool inq[maxn]; void init(int n) { // n个点 fill_n(head, n + 5, -1); cnt = 0; } struct edges { int to, w, next; edges(int to = 0, int w = 0, int next = -1) : to(to), w(w), next(next) {} } edge[maxm]; inline void add_edges(int u, int v, int w) { edge[++cnt] = edges(v, w, head[u]); head[u] = cnt; } bool spfa(int n, int s) {// n个点， s为起点 for (int i = 0; i \u0026lt;= n; ++i) { dis[i] = inf, num[i] = inq[i] = 0; } queue\u0026lt;int\u0026gt; q; q.push(s); inq[s] = num[s] = 1, dis[s] = 0; while (q.size()) { int u = q.front(); q.pop(); inq[u] = false; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to, w = edge[i].w; if (dis[v] \u0026gt; dis[u] + w) { dis[v] = dis[u] + w; if (!inq[v]) { q.push(v); inq[v] = true, num[v]++; if (num[v] \u0026gt;= n) return false; //如果从1号点到x的最短路中包含至少n个点（不包括自己），则存在环 } } } } return true; } floyd 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const int M = 2e2; int n, m; //顶点数和边数 int dis[M][M]; void floyd() { for (int k = 0; k \u0026lt; n; k++) { for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { if (dis[i][j] \u0026gt; dis[i][k] + dis[k][j]) { dis[i][j] = dis[i][k] + dis[k][j]; } } } } } void init() { memset(dis, 0x3f, sizeof dis); for (int i = 0; i \u0026lt; M; ++i) dis[i][i] = 0; } 2. 生成树 kruskal 适合稀疏图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #define ll long long using namespace std; #include \u0026lt;cctype\u0026gt; inline long long IO() {} //省略快读 const int M = 2e5 + 10, N = 5e5 + 5; int fa[M]; struct edges { int u, v; ll w; } e[N]; bool cmp(edges\u0026amp; i, edges\u0026amp; j) { return i.w \u0026lt; j.w; } int findset(int x) { return x == fa[x] ? x : fa[x] = findset(fa[x]); } bool un(int a, int b) { int fa1 = findset(a), fa2 = findset(b); if (fa1 == fa2) return false; fa[fa1] = fa2; return true; } ll kruskal(int n, int m) { sort(e, e + m, cmp); for (int i = 0; i \u0026lt;= n; ++i) fa[i] = i; int cnt = 0; ll ans = 0; for (int i = 0; i \u0026lt; m; ++i) { if (un(e[i].u, e[i].v)) { ans += e[i].w; if (++cnt == n - 1) break; } } return n - 1 == cnt ? ans : -1; } int main() { int n = IO(), m = IO(); for (int i = 0; i \u0026lt; m; ++i) e[i].u = IO(), e[i].v = IO(), e[i].w = IO(); printf(\u0026#34;%lld\\n\u0026#34;, kruskal(n, m)); return 0; } 3. tarjan 4. 网络流 Edmonds-Karp算法，速度较慢 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #define ll long long #include \u0026lt;cctype\u0026gt; inline long long IO() // 快读略 const int N = 205, M = 1e4 + 5; struct edges{ int to, next; ll cap, flow;// flow为记录当前路径流的流量，cap为容量 void add(int a, int b, ll c) { to = a, next = b; cap = c, flow = 0; } }; struct EK{ edges e[M]; const ll inf = 1e18; int head[N], cnt, n = 0, vis[N], pre[N];// vis记录是否在队内, pre记录前驱内存池编号 ll minc[N]; // 记录增广路的最小流 void init(int n) { this-\u0026gt;n = n, cnt = -1; fill_n(head, n + 1, -1); } void add(int u, int v, ll cap, int f = 1) { e[++cnt].add(v, head[u], cap); head[u] = cnt; if (f) add(v, u, 0, 0); } int bfs(int s, int t) { queue\u0026lt;int\u0026gt; q; for (int i = 0; i \u0026lt;= n; ++i) vis[i] = 0, pre[i] = -1; q.push(s), vis[s] = 1, minc[s] = inf;// 初始化minc为无穷大 while (q.size()) { int u = q.front(); q.pop(); for (int i = head[u]; ~i; i = e[i].next) { int v = e[i].to; if (vis[v] || e[i].cap == e[i].flow) continue; vis[v] = 1, pre[v] = i; minc[v] = min(minc[u], e[i].cap - e[i].flow);// 更新最小流 if (v == t) return 1;//找到了终点（汇点） q.push(v); } } return 0; } ll ek(int s, int t) { ll ans = 0, \u0026amp;dif = minc[t]; while (bfs(s, t)) { ans += dif; for (int i = pre[t]; ~i; i = pre[e[i ^ 1].to]) { e[i].flow += dif; // 正向边flow+ e[i ^ 1].flow -= dif; // 反向边flow- } } return ans; } void clearflow() { // 清空流 for (int i = 0; i \u0026lt;= cnt; ++i) e[i].flow = 0; } }ek; int main() { int n = IO(), m = IO(), s = IO(), t = IO(); ek.init(n); for (int i = 0; i \u0026lt; m; ++i) { int u = IO(), v = IO(), cap = IO(); ek.add(u, v, cap); } printf(\u0026#34;%lld\u0026#34;, ek.ek(s, t)); return 0; } dinic, 当前弧优化+多路增广优化+炸点优化(模板题),复杂度$O(n^2m)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 inline long long IO() // 快读略 const int N = 205, M = 1e4 + 5; struct edges{ int to, next; ll cap, flow;// flow为记录当前路径流的流量，cap为容量 void add(int a, int b, ll c) { to = a, next = b; cap = c, flow = 0; } }; struct Dinic { edges e[M]; const ll inf = 1e18; int head[N], cnt, n = 0, deep[N], cur[N]; void init(int n) { this-\u0026gt;n = n, cnt = -1; fill_n(head, n + 1, -1); } void add(int u, int v, ll cap, int f = 1) { e[++cnt].add(v, head[u], cap); head[u] = cnt; if (f) add(v, u, 0, 0); } // bfs求增广路，一次求出多条增广路 int bfs(int s, int t) { queue\u0026lt;int\u0026gt; q; fill_n(deep, n + 1, 0); deep[s] = 1, q.push(s); while (q.size()) { int u = q.front(); q.pop(); for (int i = head[u]; ~i; i = e[i].next) { int v = e[i].to; if (deep[v] || e[i].cap == e[i].flow) continue; deep[v] = deep[u] + 1; q.push(v); } } return deep[t] != 0; } ll dfs(int u, int t, ll flow) { if (u == t) return flow; ll nowflow = 0; for (int i = cur[u]; ~i; i = e[i].next) { cur[u] = i;// 当前弧优化 int v = e[i].to; if (deep[v] != deep[u] + 1 || e[i].cap == e[i].flow) continue; if (ll low = dfs(v, t, min(flow - nowflow, e[i].cap - e[i].flow))) { e[i].flow += low, e[i ^ 1].flow -= low; nowflow += low;// 多路增广优化 if (nowflow == flow) break; } } if (!nowflow) deep[u] = -2;// 炸点优化 return nowflow; } ll dinic(int s, int t) { ll ans = 0; while (bfs(s, t)) { for (int i = 0; i \u0026lt;= n; ++i) cur[i] = head[i];// 预处理，方便当前弧优化 ans += dfs(s, t, inf);// 进过多路增广优化可不用循环 } return ans; } void clearflow() { // 清空流 for (int i = 0; i \u0026lt;= cnt; ++i) e[i].flow = 0; } }dinic; int main() { int n = IO(), m = IO(), s = IO(), t = IO(); dinic.init(n); for (int i = 0; i \u0026lt; m; ++i) { int u = IO(), v = IO(); ll c = IO(); dinic.add(u, v, c); } printf(\u0026#34;%lld\u0026#34;, dinic.dinic(s, t)); return 0; } 最小费用最大流，将ek算法中的bfs换成spfa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 inline long long IO() // 快读代码略 const int N = 410, M = 2e5 + 5; struct edges { int to, next; ll cap, cost, flow; void add(int a, int b, ll c, ll d) { to = a, next = b; cap = c, cost = d, flow = 0; } }; struct MCMF{ const ll inf = 1e15; int head[N], pre[N], cnt, n, inq[N]; ll maxflow, mincost, dist[N]; edges e[M]; void add(int u, int v, ll cap, ll cost, int f = 1) { e[++cnt].add(v, head[u], cap, cost); head[u] = cnt; if (f) add(v, u, 0, -cost, 0);// 建立反向弧，费用相反 } int spfa(int s, int t) {// 利用spaf找最小费用的路，即最短路 for (int i = 0; i \u0026lt;= n; ++i) inq[i] = 0, dist[i] = inf, pre[i] = -1; queue\u0026lt;int\u0026gt; q; inq[s] = 1, q.push(s), dist[s] = 0; while (q.size()) { int u = q.front(); q.pop(); inq[u] = 0; for (int i = head[u]; ~i; i = e[i].next) { int v = e[i].to; ll \u0026amp;cost = e[i].cost; if (dist[v] \u0026gt; dist[u] + cost \u0026amp;\u0026amp; e[i].cap \u0026gt; e[i].flow) { dist[v] = dist[u] + cost; pre[v] = i;//记录当前点的前驱的内存池编号 if (inq[v]) continue; inq[v] = 1 , q.push(v); } } } return pre[t] != -1;// 如果说t没有前驱则说明找不到增广路了 } void mcmf(int s, int t) { maxflow = mincost = 0; while (spfa(s, t)) { ll low = inf; for (int i = pre[t]; ~i; i = pre[e[i ^ 1].to]) { low = min(low, e[i].cap - e[i].flow);//寻找最小流 } for (int i = pre[t]; ~i; i = pre[e[i ^ 1].to]) { e[i].flow += low; e[i ^ 1].flow -= low; mincost += low * e[i].cost; } maxflow += low; } } void init(int n) { cnt = -1, this-\u0026gt;n = n; fill_n(head, n + 1, -1); } void clearflow() { for (int i = 0; i \u0026lt;= cnt; ++i) e[i].flow = 0; } }mcmf; int main() { int n = IO(), m = IO(); mcmf.init(n); for (int i = 0; i \u0026lt; m; ++i) { int u = IO(), v = IO(); ll cap = IO(), cost = IO(); mcmf.add(u, v, cap, cost); } mcmf.mcmf(1, n); printf(\u0026#34;%lld %lld\u0026#34;, mcmf.maxflow, mcmf.mincost); return 0; } 5. 二分图 匈牙利算法，时间复杂度$O(ev)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int match[M]; bool vis[M]; bool dfs(int u) { for (int \u0026amp;v : gp[u]) { if (vis[v]) continue; vis[v] = true; if (!match[v] || dfs(match[v])) { match[u] = v, match[v] = u; return true; } } return false; } // 主函数里 fill_n(match, n + 1, 0); // n是点的个数 for (int i = 1; i \u0026lt;= n; ++i) { if (match[i]) continue; fill_n(vis, n + 1, false); dfs(i); } 五、字符串 1. KMP 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 const int M = 1e6 + 5; //普通版本 void getnext(char *x, int len, int *nxt) { int i = 0, j; j = nxt[0] = -1; while (i \u0026lt; len) { while(j != -1 \u0026amp;\u0026amp; x[i] != x[j]) j = nxt[j]; nxt[++i] = ++j; } } //略微优化版本 void getNext(char *x, int len, int *nxt) { int i = 0, j; j = nxt[0] = -1; while (i \u0026lt; len) { while (j != -1 \u0026amp;\u0026amp; x[i] != x[j]) j = nxt[j]; if (x[++i] == x[++j]) nxt[i] = nxt[j]; else nxt[i] = j; } } // y是主串 int nxt[M]; int kmpCount(char *y, int n, char *x, int m) { int i = 0, j = 0, ans = 0; getnext(x, m, nxt); while (i \u0026lt; n) { while (j != -1 \u0026amp;\u0026amp; y[i] != x[j]) j = nxt[j]; ++i, ++j; if (j \u0026gt;= m) ++ans, j = nxt[j]; } return ans; } 2. 字符串Hash 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 unsigned int DJBHash(const char *str) { unsigned int hash = 5381; while (*str) hash += (hash \u0026lt;\u0026lt; 5) + (*str++); return (hash \u0026amp; 0x7fffffff); //7个f } unsigned int BKDRHash(const char *str) { unsigned int seed = 131; // 31 131 1313 13131 131313... unsigned int hash = 0; while (*str) hash = hash * seed + (*str++); return (hash \u0026amp; 0x7fffffff); } #define ull unsigned long long ull strhash(const char *s) { ull seed = 1313, res = 0; // 31 131 1313 13131 while (*s) res = res * seed + (*s++); return res; } 3. 马拉车 4. exkmp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 void pre_exkmp(char x[], int m, int next[]) { next[0] = m; int j = 0; while (j + 1 \u0026lt; m \u0026amp;\u0026amp; x[j] == x[j + 1]) j++; next[1] = j; int k = 1; for (int i = 2; i \u0026lt; m; i++) { int p = next[k] + k - 1; int L = next[i - k]; if (i + L \u0026lt; p + 1) next[i] = L; else { j = max(0, p - i + 1); while (i + j \u0026lt; m \u0026amp;\u0026amp; x[i + j] == x[j]) j++; next[i] = j; k = i; } } } void exkmp(char x[], int m, char y[], int n, int next[], int extend[]) { pre_exkmp(x, m, next); int j = 0; while (j \u0026lt; n \u0026amp;\u0026amp; j \u0026lt; m \u0026amp;\u0026amp; x[j] == y[j]) j++; extend[0] = j; int k = 0; for (int i = 1; i \u0026lt; n; i++) { int p = extend[k] + k - 1; int L = next[i - k]; if (i + L \u0026lt; p + 1) extend[i] = L; else { j = max(0, p - i + 1); while (i + j \u0026lt; n \u0026amp;\u0026amp; j \u0026lt; m \u0026amp;\u0026amp; y[i + j] == x[j]) j++; extend[i] = j; k = i; } } } 六、 计算几何 二维几何（未完善） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;vector\u0026gt; /** * 本板子属于半成品，有些功能并没有验证 * 函数说明： * 关于点的函数 * 点的Point(double, double) 构造函数 * + 向量加法 * - 向量减法 * == 判断两个点是否相等 * *(Point) 向量点乘 * *(double) 向量伸长(没有除法，要用除法直接乘倒数) * ^ 向量叉乘 * \u0026lt; 点对点的比较 * double len() 向量的长度，也可以用来求两个点的距离 * double len2() const; 向量长度的平方 * double dist(Point); 判断p点到这个点的距离 * double angle(Point, Point); // 传入两个点a b， 返回 角apb 的弧度 * Point rotate(double angle) 向量逆时针旋转angle弧度 * Point rotate(Point, double) 点让点p逆时针旋转angle弧度 * void print() 将点输出 * int init() 输入点的坐标 返回值和scanf相同 * 其他非结构体函数 * angle(Point\u0026amp;, Point\u0026amp;) 计算两个向量的夹角 * * 关于线的函数 * Line(Point, Point) 构造函数 * Line(Point, double) 根据一个点和一个倾斜角 0 \u0026lt;= angle \u0026lt; PI确定直线 （未验证） * double len() 返回线段的长度 * Point vec(); 获取该线的向量 * double point(double t) 返回距离点p向前t倍向量的点 * double angle() 返回直线的倾斜角 范围[0, PI) (未验证) * int PointAndLine(Point); // 点和直线的关系，1 点在线左边，2 右边， 3 线上面 * double disPointToLine(const Point\u0026amp;) 点到这条直线的距离 * double disPointToSeg(const Point\u0026amp;) 点到这条线段的距离（未验证） * Point getPro(const Point\u0026amp;) 点在这条线上的投影 （未验证） * Point getSym(const Point\u0026amp;) 点关于这条线的对称点 （未验证） * bool isOnLine(const Point\u0026amp;) 验证该点是否在这条直线上（未验证） * bool isOnSeg(const Point\u0026amp;) 验证该点是否在这条线段上（未验证） * Point cross(Line\u0026amp;) 直线和这条直线的交点，前提是相交 * void print() 输出这条线段 * * 其他非结构体 * int LineAndLine(Line\u0026amp;, Line\u0026amp;) 直线和直线的关系 0平行 1重合 2相交 （未验证） * Point getLineInter(const Line\u0026amp;, const Line\u0026amp;) 求两直线的交点,必须相交才能调用 （此函数有问题） * int SegAndSeg(const Line\u0026amp; l1, const Line\u0026amp; l2) 两个线段的关系 0不相交 1非规范相交(其中一个线段的端点和另一个线段相交) 2规范相交 （未验证） * int LineAndSeg(const Line\u0026amp; line, const Line\u0026amp; seg) 直线和线段的关系，0不相交 1非规范相交 2规范相交 （未验证） * * 关于圆的函数 * Circle(Point, double) 构造函数 * Circle(Point, Point, Point) 过三点的圆 * double area() const; 返回圆的面积 * double circum() const 返回圆的周长 * int PointAndCircle(Point\u0026amp;) 点和圆的关系 返回 0圆外 1圆上 2圆内 * int LineAndCircle(Point\u0026amp;) 点和圆的关系 返回 0不相交 1相交 2相交两个点（未验证） * int CircleAndCircle(Circle\u0026amp;) 圆和圆的关系 返回 0内含 1内切 2相交两点 3外切 4外离 （未验证） * * 关于三角形的函数 * Triangle(Point, Point, Point) 构造函数 * double area() const 返回三角形函数 * Circle outerCircle() 获取三角形的外接圆 * * 关于多边形的函数 * Polygon(vector\u0026lt;Point\u0026gt;\u0026amp;) 构造函数 * double circum(); 求凸包的周长 * void graham(Polygon\u0026amp;) 求凸包 传入值为需要求出的凸包的点集 * int PointAndPolgon(Point\u0026amp;) 判断点与多边形的关系，0外 1内 2边上 3点上 （未实现） * double minRectCover() 点集的最小矩形覆盖，自己必须是（逆时针）凸包才能调用 （未实现） * Circle minCircleCover() 点集的最小圆覆盖 */ using namespace std; const double eps = 1e-8, PI = acos(-1.0); int dcmp(double x) { if (fabs(x) \u0026lt; eps) return 0; return x \u0026gt; 0 ? 1 : -1; } /******************************点*******************************/ /* 除了结构体内部函数还有 angle(Point\u0026amp; a, Point\u0026amp; b) // 两个向量的夹角 */ struct Point { double x, y; Point(double x = 0, double y = 0) : x(x), y(y) {} Point operator + (const Point\u0026amp;) const; Point operator - (const Point\u0026amp;) const; double operator * (const Point\u0026amp;) const; // 点乘 double operator ^ (const Point\u0026amp;) const; // 叉乘 bool operator == (const Point\u0026amp;) const; bool operator \u0026lt; (const Point\u0026amp;) const; // 排序需要 Point operator * (double); //向量伸长b倍 double len() const; // 向量的长度 double len2() const; // 向量长度的平方 double dist(Point); // 判断p点到这个点的距离 double angle(Point, Point); // 传入两个点a b， 返回 角apb 的弧度 Point rotate(double); // 向量逆时针旋转a弧度后 Point rotate(Point\u0026amp;, double); // 点绕p点顺时针旋转a弧度后 void print() { printf(\u0026#34;%.2f %.2f\u0026#34;, x, y); } int init() { return scanf(\u0026#34;%lf%lf\u0026#34;, \u0026amp;x, \u0026amp;y); } }; Point Point::operator + (const Point\u0026amp; b) const { return Point(x + b.x, y + b.y); } Point Point::operator - (const Point\u0026amp; b) const { return Point(x - b.x, y - b.y); } // 点乘 double Point::operator * (const Point\u0026amp; b) const { return x * b.x + y * b.y; } // 叉乘 double Point::operator ^ (const Point\u0026amp; b) const { return x * b.y - y * b.x; } bool Point::operator == (const Point\u0026amp; b) const { return !dcmp(x - b.x) \u0026amp;\u0026amp; !dcmp(y - b.y); } bool Point::operator \u0026lt; (const Point\u0026amp; b) const { return (!dcmp(x - b.x)) ? dcmp(y - b.y) \u0026lt; 0 : x \u0026lt; b.x; } // 向量的长度 double Point::len() const { return hypot(x, y); } // 向量长度平方 double Point::len2() const { return x * x + y * y; } // 判断p点到这个点的距离 double Point::dist(Point p) { return hypot(x - p.x, y - p.y); } // 向量伸长b倍 Point Point::operator * (double b) { return Point(x * b, y * b); } // 返回 角apb 的弧度 double Point::angle(Point a, Point b) { Point p = *this; return fabs(atan2(fabs((a - p) ^ (b - p)), (a - p) * (b - p))); } // 向量逆时针旋转a弧度后 // cosx -sinx // sinx cosx Point Point::rotate(double a) { return Point(x * cos(a) - y * sin(a), x * sin(a) + y * cos(a)); } // 点绕p点顺时针旋转a弧度后 Point Point::rotate(Point \u0026amp;p, double a) { Point vec = (*this) - p; return vec.rotate(a) + p; } // 两个向量的夹角 double angle(Point\u0026amp; a, Point\u0026amp; b) { return acos(a * b / a.len() / b.len()); } /******************************线*******************************/ /* 除了结构体内部函数还有 int LineAndLine(Line\u0026amp; l1, Line\u0026amp;) 直线和直线的关系 0平行 1重合 2相交 Point getLineInter(const Line\u0026amp; l1, const Line\u0026amp; l2) 求两直线的交点,必须相交才能调用 int SegAndSeg(const Line\u0026amp; l1, const Line\u0026amp; l2) 两个线段的关系 0不相交 1非规范相交(其中一个线段的端点和另一个线段相交) 2规范相交 int LineAndSeg(const Line\u0026amp; line, const Line\u0026amp; seg) 直线和线段的关系，0不相交 1非规范相交 2规范相交 */ struct Line { Point s, e; Line() {} Line(Point s, Point e) : s(s), e(e) {} Line(Point, double); // 根据一个点和一个倾斜角0\u0026lt;= angle \u0026lt; PI确定直线 double len(); // 线段的长度 Point vec() const; // 获取该线的向量 Point point(double); // P = s + vt double angle(); // 直线的倾斜角[0, PI) int PointAndLine(Point); // 点和直线的关系，1 点在线左边，2 右边， 3 线上面 double disPointToLine(const Point\u0026amp;); // 点到这条直线的距离 double disPointToSeg(const Point\u0026amp;); // 点到这条线段的距离 Point getPro(const Point\u0026amp;); // 点到这条线的投影 Point getSym(const Point\u0026amp;); // 点关于这条线的对称点 bool isOnLine(const Point\u0026amp;); // 点是否在这条直线上 bool isOnSeg(const Point\u0026amp;); // 点是否在这条线段上 Point cross(Line\u0026amp;); // 直线和这条直线的交点，前提是相交才能调用 void print(); // 输出线段 }; Line::Line(Point p, double angle) : s(p) { if (!dcmp(angle - PI / 2)) e = s + Point(0, 1); else e = s + Point(1, tan(angle)); } double Line::len() { return s.dist(e); } Point Line::vec() const { return e - s; } Point Line::point(const double t){ return (s + (vec() * t)); } double Line::angle() { double ret = atan2(e.y - s.y, e.x - s.x); if (dcmp(ret) \u0026lt; 0) ret += PI; if (!dcmp(ret - PI)) ret -= PI; return ret; } int Line::PointAndLine(Point p) { int c = dcmp((p - s) ^ vec()); if (c \u0026lt; 0) return 1; return c ? 2 : 3; } void Line::print() { printf(\u0026#34;(%f,%f) -\u0026gt; (%f,%f)\u0026#34;, s.x, s.y, e.x, e.y); } double Line::disPointToLine(const Point\u0026amp; p) { return fabs((p - s) ^ vec()) / len(); } double Line::disPointToSeg(const Point\u0026amp; p) { if (s == e) return (s - p).len(); Point v1 = p - s, v2 = p - e, v = vec(); if (dcmp(v1 * v) \u0026lt; 0) return v1.len(); if (dcmp(v2 * v) \u0026gt; 0) return v2.len(); return disPointToLine(p); } Point Line::getPro(const Point\u0026amp; p) { Point v = vec(); return s + v * (v * (p - s) / v.len2()); } Point Line::getSym(const Point\u0026amp; p) { Point q = getPro(p); return Point(2 * q.x - p.x, 2 * q.y - p.y); } bool Line::isOnLine(const Point\u0026amp; p) { return !dcmp((p - s) ^ (p - e)); } bool Line::isOnSeg(const Point\u0026amp; p) { return isOnLine(p) \u0026amp;\u0026amp; (dcmp((p - s) * (p - e)) \u0026lt;= 0); } Point Line::cross(Line\u0026amp; l) { Point l_vec = l.vec(); double a1 = l_vec ^ (s - l.s); double a2 = l_vec ^ (e - l.s); return Point((s.x * a2 - e.x * a1) / (a2 - a1), (s.y *a2 - e.y * a1) / (a2 - a1)); } // 直线和直线的关系 0平行 1重合 2相交 int LineAndLine(Line\u0026amp; l1, Line\u0026amp; l2) { if (!dcmp(l1.vec() ^ l2.vec())) return l2.isOnLine(l1.s); return 2; } // 求两个直线的交点，必须相交才能调用 Point getLineInter(Line\u0026amp; l1, Line\u0026amp; l2) { Point v = l1.s - l2.s, l1_vec = l1.vec(), l2_vec = l2.vec(); double t = (l2_vec ^ v) / (l1_vec ^ l2_vec); return l1.point(t); } // 判断两个线段的关系 int SegAndSeg(const Line\u0026amp; l1, const Line\u0026amp; l2) { Point l1_vec = l1.vec(), l2_vec = l2.vec(); int d1 = dcmp(l1_vec ^ (l2.s - l1.s)); int d2 = dcmp(l1_vec ^ (l2.e - l1.s)); int d3 = dcmp(l2_vec ^ (l1.s - l2.s)); int d4 = dcmp(l2_vec ^ (l1.e - l2.s)); if((d1 ^ d2) == -2 \u0026amp;\u0026amp; (d3 ^ d4) == -2) return 2; return (!d1 \u0026amp;\u0026amp; dcmp((l2.s - l1.s) * (l2.s - l1.e)) \u0026lt;= 0) || (!d2 \u0026amp;\u0026amp; dcmp((l2.e - l1.s) * (l2.e - l1.e)) \u0026lt;= 0) || (!d3 \u0026amp;\u0026amp; dcmp((l1.s - l2.s) * (l1.s - l2.e)) \u0026lt;= 0) || (!d4 \u0026amp;\u0026amp; dcmp((l1.e - l2.s) * (l1.e - l2.e)) \u0026lt;= 0); } // 直线和线段的关系，0不相交 1非规范相交 2规范相交 int LineAndSeg(const Line\u0026amp; line, const Line\u0026amp; seg) { Point line_vec = line.vec(); int d1 = dcmp(line_vec ^ (seg.s - line.s)); int d2 = dcmp(line_vec ^ (seg.e - line.s)); if ((d1 ^ d2) == -2) return 2; return d1 == 0 || d2 == 0; } /******************************圆*******************************/ struct Circle { Point p; double r; Circle() {} Circle(Point p, double r) : p(p), r(r) {} Circle(Point, Point , Point); // 过三点一个圆 double area() const; // 面积 double circum() const; // 周长 int PointAndCircle(Point\u0026amp;); // 点和圆的关系 0圆外 1圆上 2圆内 int LineAndCircle(Line\u0026amp;); // 直线和圆的关系 0不相交 1相切 2相交两点 int CircleAndCircle(Circle\u0026amp;); // 圆和圆的关系 0内含 1内切 2相交两点 3外切 4外离 }; double Circle::area() const { return PI * r * r; } double Circle::circum() const { return 2 * PI *r; } Circle::Circle(Point a, Point b, Point c) { Point v1 = b - a, v2 = c - b; Line l1((a + b) * 0.5, ((a + b) * 0.5) + Point(-v1.y, v1.x)); Line l2((b + c) * 0.5, ((b + c) * 0.5) + Point(-v2.y, v2.x)); p = getLineInter(l1, l2); r = (p - a).len(); } int Circle::PointAndCircle(Point\u0026amp; a) { int d = dcmp((a - p).len() - r); if (d \u0026gt; 0) return 0; if (d \u0026lt; 0) return 2; return 1; } int Circle::LineAndCircle(Line\u0026amp; l) { int d = dcmp(l.disPointToLine(p) - r); if (d \u0026gt; 0) return 0; if (d \u0026lt; 0) return 2; return 1; } int Circle::CircleAndCircle(Circle\u0026amp; c) { double dist = (c.p - p).len(); if (dcmp(dist - r - c.r) \u0026gt; 0) return 4; if (!dcmp(dist - r - c.r)) return 3; double l = fabs(r - c.r); if (dcmp(dist - r - c.r) \u0026lt; 0 \u0026amp;\u0026amp; dcmp(dist - l) \u0026gt; 0) return 2; return dcmp(dist - l) == 0; } /****************************三角形******************************/ struct Triangle{ Point p[3]; Triangle() {} Triangle(Point A, Point B, Point C); double area() const ; // 三角形面积 Circle outerCircle(); // 外接圆 }; Triangle::Triangle(Point A, Point B, Point C) { p[0] = A, p[1] = B, p[2] = C; } double Triangle::area() const { double ret = 0; for (int i = 0; i \u0026lt; 3; ++i) { ret += p[i] ^ p[(i + 1) % 3]; } return fabs(ret) / 2; } // r = a * b * c / 4S // 两条边的中垂线的交点，也可用kuangbin的方法，但此方法不需要再次调用Line的函数 Circle Triangle::outerCircle() { double A1 = 2.0 * (p[1].x - p[0].x), B1 = 2.0 * (p[1].y - p[0].y); double A2 = 2.0 * (p[2].x - p[1].x), B2 = 2.0 * (p[2].y - p[1].y); double C1 = 0, C2 = 0; for (int i = 0, j = 1, k = -1; i \u0026lt; 2; ++i, ++j, k = 1) { C1 += (p[i].x * p[i].x + p[i].y * p[i].y) * k; C2 += (p[j].x * p[j].x + p[j].y * p[j].y) * k; } double x = ((C1 * B2) - C2 * B1) / ((A1 * B2) - A2 * B1); double y = ((A1 * C2) - A2 * C1) / ((A1 * B2) - A2 * B1); return Circle(Point(x, y), (Point(x, y) - p[0]).len()); } /****************************多边形/点集******************************/ struct Polygon { vector\u0026lt;Point\u0026gt; p; // vector\u0026lt;Line\u0026gt; l; Polygon(){} Polygon(vector\u0026lt;Point\u0026gt;\u0026amp; p) : p(p) {}; double circum(); // 求凸包的周长 void graham(Polygon\u0026amp;); // 凸包 int PointAndPolygon(Point\u0026amp;); // 判断点与多边形的关系，0外 1内 2边上 3点上 double minRectCover(); // 最小矩形覆盖，自己必须是（逆时针）凸包才能调用 Circle minCircleCover(); // 点集的最小圆覆盖 }; double Polygon::circum() { int n = p.size(); if (n \u0026lt; 2) return 0.0; if (n == 2) return (p[0] - p[1]).len(); double ret = 0; for (int i = 0; i \u0026lt; n; ++i) { ret += (p[(i + 1) % n] - p[i]).len(); } return ret; } void Polygon::graham(Polygon\u0026amp; res) { int indx = 0, n = p.size(); for (int i = 1; i \u0026lt; n; ++i) if (p[i] \u0026lt; p[indx]) indx = i; swap(p[0], p[indx]); sort(p.begin() + 1, p.end(), [\u0026amp;](Point\u0026amp; i, Point\u0026amp; j) { int d = dcmp(atan2(i.y - p[0].y, i.x - p[0].x) - atan2(j.y - p[0].y, j.x - p[0].x)); if (d) return d \u0026lt; 0; return i.x \u0026lt; j.x; }); res.p.emplace_back(p[0]); if (n == 1) return; res.p.emplace_back(p[1]); if (n == 2) { if (p[0] == p[1]) res.p.pop_back(); return; } int x = res.p.size(); for (int i = 2; i \u0026lt; n; ++i, ++x) { while (x \u0026gt;= 2 \u0026amp;\u0026amp; dcmp((res.p[x - 2] - res.p[x - 1]) ^ (res.p[x - 2] - p[i])) \u0026lt;= 0) { --x; res.p.pop_back(); } res.p.emplace_back(p[i]); } if (res.p.size() == 2 \u0026amp;\u0026amp; (res.p[0] == res.p[1])) res.p.pop_back(); } Circle Polygon::minCircleCover() { random_shuffle(p.begin(), p.end()); Circle res(p[0], 0); int n = p.size(); for (int i = 1; i \u0026lt; n; ++i) { if (res.PointAndCircle(p[i])) continue; // 在圆内 res = Circle(p[i], 0); for (int j = 0; j \u0026lt; i; ++j) { if (res.PointAndCircle(p[j])) continue; // 在圆内 res = Circle((p[i] + p[j]) * 0.5, (p[i] - p[j]).len() * 0.5); for (int k = 0; k \u0026lt; j; ++k) { if (res.PointAndCircle(p[k])) continue; // 在圆内 res = Circle(p[i], p[j], p[k]); } } } return res; } vector\u0026lt;Point\u0026gt; vt; int main() { int t; while(scanf(\u0026#34;%d\u0026#34;, \u0026amp;t), t) { Point p; for (int i = 0; i \u0026lt; t; ++i) { p.init(); vt.emplace_back(p); } Polygon pol(vt), ans; pol.graham(ans); printf(\u0026#34;%.2f\\n\u0026#34;, ans.circum()); vt.clear(); } return 0; } 七、动态规划 1. 树形dp 树的最大独立集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 /* Loj 10160 每个点都有一个快乐值，子结点和父节点不能同时被选，问你最大的快乐值 dp[i][0]表示第i号结点不选时最大的快乐值 dp[i][1]表示第i号结点选时的最大的快乐值 */ #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int M = 6e3 + 5; inline long long IO() {} // 快读略 struct es{ int to, nxt; }e[M \u0026lt;\u0026lt; 1]; int head[M], cnt; inline void init() { memset(head, -1, sizeof head); cnt = 0; } inline void add(int u, int v) { e[++cnt] = {.to = v, .nxt = head[u]}; head[u] = cnt; } int n, h[M], vis[M], dp[M][2]; void dfs(int u) { dp[u][1] = h[u]; for (int i = head[u]; ~i; i = e[i].nxt) { int v = e[i].to; dfs(v); dp[u][0] += max(dp[v][0], dp[v][1]); dp[u][1] += dp[v][0]; } } int main() { int n = read(); for (int i = 1; i \u0026lt;= n; ++i) h[i] = read(); int u = read(), v = read(); init(); while (u | v) { add(v, u); vis[u] = true; u = read(), v = read(); } int root = 0; for (int i = 1; i \u0026lt;= n; ++i) { if (!vis[i]) root = i; } dfs(root); printf(\u0026#34;%d\\n\u0026#34;, max(dp[root][0], dp[root][1])); return 0; } 树的最小支配集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 /* Loj 10157 每个点都有点权，一个点可以看守连着他的边上的点，选一些点出来，使他们能够看守整颗树上所有的点 问你最小选出来的权值 dp[0][i]表示i点被选上，则其 += min({dp[0][son], dp[2][son], dp[1][son]}) dp[1][i]表示i点没被选上，但是其父亲被选上了，则其 += min(dp[0][son], dp[2][son]) dp[2][i]表示i点没被选上，但是去其中某几个儿子被选上了，注意这个比较难转移，转移方式如下 先求出所有儿子min(dp[0][son], dp[2][son])的总和，然后在递归完后选出最小是那个儿子的dp[0][son] 即dp[2][u] = min(dp[2][u], sum - min(dp[2][v], dp[0][v]) + dp[0][v]);这行 */ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; #define ll long long #include \u0026lt;cctype\u0026gt; inline long long IO() {} // 快读略 const int maxn = 1e5, maxm = 1e5; const int INF = 0x3f3f3f3f; int head[maxn], cnt, dis[maxn]; //初始化 void init() { memset(head, -1, sizeof head); // memset(vis, false, sizeof vis); cnt = 0; } struct edges { int to, next; int w; edges(int to = 0, int next = -1, int w = 0) : to(to), next(next), w(w) {} }edge[maxm \u0026lt;\u0026lt; 1]; //无向图则需要乘2 inline void add(int u, int v, int w = 0) { if (cnt == 0) init(); edge[++cnt] = edges(v, head[u], w); head[u] = cnt; } const int M = 1e4, inf = 0x3f3f3f3f; int n, m, dp[3][M], vis[M], c[M]; void dfs(int u, int fa) { dp[0][u] = c[u], dp[2][u] = inf; int sum = 0; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa) continue; dfs (v, u); dp[0][u] += min({dp[0][v], dp[2][v], dp[1][v]}); if (fa != -1) dp[1][u] += min(dp[2][v], dp[0][v]); sum += min(dp[2][v], dp[0][v]); } for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa) continue; dp[2][u] = min(dp[2][u], sum - min(dp[2][v], dp[0][v]) + dp[0][v]); } } int main() { n = IO(); init(); for (int i = 0; i \u0026lt; n; ++i) { int u = IO(), w = IO(), k = IO(); c[u] = w; while (k--) { int v = IO(); add(u, v), add(v, u); } } dfs(1, -1); printf(\u0026#34;%d\u0026#34;, min(dp[0][1], dp[2][1])); return 0; } 树的最小点覆盖 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 /* Loj10156 每个点都能看到他所连着的边，问你选出最少的点使树上所有的边都能被看到 dp[0][i]表示不选i点的最小选择数 则其 += dp[1][son] dp[1][i]表示选i点的最小选择数，则其 += min(dp[0][son], dp[1][son]) */ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; #define ll long long #include \u0026lt;cctype\u0026gt; inline long long IO() {} // 快读略 const int maxn = 1e5, maxm = 1e5; const int INF = 0x3f3f3f3f; int head[maxn], cnt, dis[maxn]; //初始化 void init() { memset(head, -1, sizeof head); // memset(vis, false, sizeof vis); cnt = 0; } struct edges { int to, next; int w; edges(int to = 0, int next = -1, int w = 0) : to(to), next(next), w(w) {} }edge[maxm \u0026lt;\u0026lt; 1]; //无向图则需要乘2 inline void add(int u, int v, int w = 0) { if (cnt == 0) init(); edge[++cnt] = edges(v, head[u], w); head[u] = cnt; } const int M = 1e4; int n, m, dp[2][M], vis[M]; void dfs(int u, int fa) { dp[1][u] = 1; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa) continue; dfs(v, u); dp[1][u] += min(dp[0][v], dp[1][v]); dp[0][u] += dp[1][v]; } } int main() { n = IO(); for (int i = 0; i \u0026lt; n; ++i) { int u = IO(), k = IO(); while (k--) { int v = IO(); add(u, v), add(v, u); } } dfs(0, -1); // printf(\u0026#34;%d\\n\u0026#34;, ans); printf(\u0026#34;%d\u0026#34;, min(dp[0][0], dp[1][0])); return 0; } 树的直径 两次搜索法 该方法只适用于边权为正整数情况 第一次搜索从任意一点出发找到最远点s 第二次搜索从s点出发找到最远点，并记录到达此点的距离，就是直径 一次DP法 一次DP法又分两种，两者各有好处 一种是下面例题中的方式，核心就是记录从一个点出发的最远点和次远点 另一种是上述的优化 1 2 3 4 5 6 7 8 9 10 11 dp[N]; // 记录到达结点的最远点 ans; //记录直径 void dfs(int u, int fa) { for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == u) continue; dfs(v); ans = max(ans, dp[u] + dp[v] + edge[i].w); dp[u] = max(dp[u], dp[v] + edge[i].w); } } 例题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 /* Loj 10159 树的直径：树上最长路径 本题需要求出所有直径（直径可能不唯一）上的所有点 解决方法：每次递归算出结点到其儿子中的最长路径和次长路径，然后相加 维护好全局变量ans，最终答案就是ans */ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; #define ll long long #include \u0026lt;cctype\u0026gt; inline long long IO() {} // 快读略 const int maxn = 2e5 + 5, maxm = 2e5 + 5; const int INF = 0x3f3f3f3f; int head[maxn], cnt, dis[maxn]; //初始化 void init() { memset(head, -1, sizeof head); // memset(vis, false, sizeof vis); cnt = 0; } struct edges { int to, next; int w; edges(int to = 0, int next = -1, int w = 0) : to(to), next(next), w(w) {} }edge[maxm \u0026lt;\u0026lt; 1]; //无向图则需要乘2 inline void add(int u, int v, int w = 0) { if (cnt == 0) init(); edge[++cnt] = edges(v, head[u], w); head[u] = cnt; } const int M = 2e5, inf = 0x3f3f3f3f; int dp[M], t[M], ans = 0, d1[M], d2[M]; vector\u0026lt;int\u0026gt; res; int dfs(int u, int fa) { d1[u] = 0, d2[u] = 0; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa) continue; int len = dfs(v, u) + 1; if (len \u0026gt;= d1[u]) { d2[u] = d1[u], d1[u] = len; } else if (len \u0026gt; d2[u]) { d2[u] = len; } } ans = max(ans, d1[u] + d2[u]); return d1[u]; } void dfs(int u, int fa, int d) { for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa) continue; if (d1[v] == d) dfs(v, u, d - 1), res.push_back(v); } } void solve(int u, int fa) { if (d1[u] + d2[u] == ans) { res.push_back(u); if (d1[u] != d2[u]) dfs(u, fa, d2[u] - 1); dfs(u, fa, d1[u] - 1); } for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa) continue; solve(v, u); } } int main() { int n = IO(); init(); for (int i = 1; i \u0026lt; n; ++i) { int u = IO(), v = IO(); add(u, v), add(v, u); } dfs(0, -1); solve(0, -1); sort(res.begin(), res.end()); auto x = unique(res.begin(), res.end()); auto i = res.begin(); while (i != x) { printf(\u0026#34;%d\\n\u0026#34;, *i); i++; } return 0; } 树的重心 树的重心的一些重要性质： 一棵树最少有一个重心，最多有两个重心，若有两个重心，则他们相邻（即连有直接边） 树上所有点到某个点的距离和里，到重心的距离和最小；若有两个重心，则其距离和相同 若以重心为根，则所有子树的大小都不超过整棵树的一半 在一棵树上添加或删除一个叶子节点，其重心最多平移一条边的距离 两棵树通过连一条边组合成新树，则新树重心在原来两棵树的重心的连线上 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 /* Poj 1655 树的重心：重心是指树中的一个结点，如果将这个结点删除后剩余的各个连通块中结点数的最大值最小，则称为树的重心 本题需要求出重心，如果有多个输出最小编号的结点，并输出重心被删除后连通块结点数的最大值 */ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cctype\u0026gt; inline long long IO() {} // 快读略 using namespace std; const int maxn = 1e5 + 5, maxm = 2e5 + 5, inf = 0x3f3f3f3f; int head[maxn], cnt; //初始化 void init() { memset(head, -1, sizeof head); cnt = 0; } struct edges { int to, next; }edge[maxm \u0026lt;\u0026lt; 1]; //无向图则需要乘2 inline void add(int u, int v) { edge[++cnt].to = v, edge[cnt].next = head[u]; head[u] = cnt; } int ans, siz; int dfs(int u, int fa, const int \u0026amp;n) { int tot = 1, num = 0; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa) continue; int tmp = dfs(v, u, n); tot += tmp, num = max(num, tmp); } int res = max(n - tot, num); if (siz \u0026gt;= res) { if (siz == res) ans = min(u, ans); else ans = u, siz = res; } return tot; } void solve() { int n = IO(); init(), siz = inf; for (int i = 1; i \u0026lt; n; ++i) { int u = IO(), v = IO(); add(u, v), add(v, u); } dfs(1, -1, n); printf(\u0026#34;%d %d\\n\u0026#34;, ans, siz); } int main() { int t = IO(); while (t--) solve(); return 0; } 树的中心 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 /* 例题：无 树的中心：找出一个点，使该点到其他点的最远距离最小，则这个点就是树的中心 解题思路： 从u点到其他点的最远距离分为两类 1.从u点向下走的最远距离，用d1[u]表示 2.从u点向上走的最远距离，用up[u]表示 则从u点到其他点的最远距离就是 max(d1[u], up[u]); 则中心到其他点的最远距离就是ans = min{dp[i]} 其中d1[u]可用求树的直径的方法求出 记得同时维护d2[u]即次长距离，和维护最长的路是哪个儿子 关于up的计算方式要用父亲节点来更新儿子节点，与求d1是相反的 如果u的儿子结点son在最长的路径上则 up[son] = w[son] + max(up[u], d2[u]) 否则 up[son] = w[son] + max(up[u], d1[u]) 输入 5 2 1 1 3 2 1 4 3 1 5 1 1 输出中心到其他节点的最长长度 2 */ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int maxn = 1e5, maxm = 2e5, inf = 0x3f3f3f3f; int head[maxn], cnt; //初始化 void init() { memset(head, -1, sizeof head); cnt = 0; } struct edges { int to, next; int w; }edge[maxm \u0026lt;\u0026lt; 1]; //无向图则需要乘2 inline void add(int u, int v, int w) { edge[++cnt].to = v, edge[cnt].next = head[u]; edge[cnt].w = w, head[u] = cnt; } int d1[maxn], d2[maxn], maxv[maxn], up[maxn]; int dfs1(int u, int fa) { d1[u] = d2[u] = 0; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa) continue; int d = dfs1(v, u) + edge[i].w; if (d \u0026gt;= d1[u]) { d2[u] = d1[u], d1[u] = d; maxv[u] = v; } else if (d \u0026gt; d2[u]) { d2[u] = d; } } return d1[u]; } void dfs2(int u, int fa) { for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa) continue; if (maxv[u] == v) { up[v] = max(up[u], d2[u]) + edge[i].w; } else { up[v] = max(up[u], d1[u]) + edge[i].w; } dfs2(v, u); } } int main() { int n; init(); scanf(\u0026#34;%d\\n\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt; n; ++i) { int u, v, w; scanf(\u0026#34;%d %d %d\\n\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;w); add(u, v, w), add(v, u, w); } dfs1(1, -1); dfs2(1, -1); int res = 0x3f3f3f3f; for (int i = 1; i \u0026lt;= n; ++i) { res = min(res, max(up[i], d1[i])); } printf(\u0026#34;%d\u0026#34;, res); return 0; } 依赖背包问题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 /* Loj 10154选课 学生不可能学完大学开设的所有课程，因此必须在入学时选定自己要学的课程。 每个学生可选课程的总数是给定的。请找出一种选课方案使得你能得到的学分最多， 并满足先修课优先的原则。假定课程间不存在时间上的冲突。 输入的第一行包括两个正整数 ，分别表示待选课程数和可选课程数。 接下来 行每行描述一门课，课号依次为 。每行两个数，依次表示这门课先修课课号（若不存在，则该项值为 ）和该门课的学分。 输出一行，表示实际所选课程学分之和。 dp[i][j]代表第i门课程选j个课的最大学分和 题中的课程号是从1开始的，并不是一颗树，而是森林，我们假设有一个课程0，连接所有森林的根结点 */ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #define pb push_back using namespace std; #define ll long long #include \u0026lt;cctype\u0026gt; inline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == \u0026#39;-\u0026#39;) f = true; c = getchar(); } while (isdigit(c)) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c - \u0026#39;0\u0026#39;); c = getchar(); } return f ? -x : x; } const int maxn = 1e4, maxm = 1e4; const int INF = 0x3f3f3f3f; const int M = 310; int n, m, dp[M][M], tmp[M], w[M]; vector\u0026lt;int\u0026gt; mp[M]; int dfs(int u) { dp[u][1] = w[u];//初始化 int num = 1; for (int v : mp[u]) { int siz = dfs(v); for (int i = 1; i \u0026lt;= num; ++i) tmp[i] = dp[u][i]; for (int i = 1; i \u0026lt;= num; ++i) { for (int j = 0; j \u0026lt;= siz; ++j) { dp[u][i + j] = max(dp[u][i + j], tmp[i] + dp[v][j]); } } num += siz; } return num; //返回包括自己加上子树有多少个节点 } int main() { n = IO(), m = IO(); for (int i = 1; i \u0026lt;= n; ++i) { int u = IO(); mp[u].pb(i), w[i] = IO(); } dfs(0); printf(\u0026#34;%d\u0026#34;, dp[0][m + 1]); // 假设0号结点必选 return 0; } 基环树dp 换根 最长上升子序列 朴素动态规划 1 2 3 4 5 6 7 8 9 10 dp[N], ans = 1; for (int i = 1; i \u0026lt;= n; ++i) { dp[i] = 1; for (int j = 1; j \u0026lt; i; ++j) { if (a[j] \u0026lt; a[i]) { // 严格上升用 \u0026lt; , 否则用 \u0026lt;= dp[i] = max(dp[i], dp[j] + 1); } } ans = max(ans, dp[i]); } 贪心 1 // 坑（未补） 树状数组（或线段树）优化动态规划（直接优化） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 inline long long IO() {} using namespace std; const int N = 1e5 + 5, M = 1e6 + 5, inf = 1e9; int a[M]; unordered_map\u0026lt;int, int\u0026gt; mp; void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } #define lb(x) (x \u0026amp; (-x)) int bit[M], n; int get(int i) { int res = 0; while (i) { res = max(res, bit[i]), i -= lb(i); } return res; } void update(int i, int v, int\u0026amp; len) { while(i \u0026lt;= len) { bit[i] = max(bit[i], v), i += lb(i); } } void problem() { int n = IO(); vector\u0026lt;int\u0026gt; arr; for (int i = 0; i \u0026lt; n; ++i) a[i] = IO(), arr.push_back(a[i]); sort(arr.begin(), arr.end()); arr.erase(unique(arr.begin(), arr.end()), arr.end()); int cnt = 0, res = 0, len = arr.size(); for (int x : arr) mp[x] = ++cnt; for (int i = 0; i \u0026lt; n; ++i) { int ans = get(mp[a[i]] - 1) + 1; res = max(ans, res); update(mp[a[i]], ans, len); } print(res); } int main() { int n = 1; while (n--) { problem(); } return 0; } 树状数组（或线段树）优化（将值排序，求下标的最长上升子序列） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #define ll long long #define all(x) x.begin(), x.end() inline long long IO() {} using namespace std; const int N = 1e5 + 5, M = 1e6 + 5, inf = 1e9; int num[N], sum[410]; ll a[210]; void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } struct pii{ int x, indx; }p[N]; #define lb(x) (x \u0026amp; (-x)) int bit[N], n; int get(int i) { int res = 0; while (i) { res = max(res, bit[i]), i -= lb(i); } return res; } void update(int i, int v) { while(i \u0026lt;= n) { bit[i] = max(bit[i], v), i += lb(i); } } void problem() { n = IO(); for (int i = 0; i \u0026lt; n; ++i) p[i].x = IO(), p[i].indx = i + 1; sort(p, p + n, [] (pii \u0026amp;i, pii \u0026amp;j) { if (i.x == j.x) return i.indx \u0026gt; j.indx; return i.x \u0026lt; j.x; }); int res = 0; for (int i = 0; i \u0026lt; n; ++i) { int ans = get(p[i].indx - 1) + 1; res = max(ans, res); update(p[i].indx, ans); } print(res); } int main() { int n = 1; while (n--) { problem(); } return 0; } ","date":"2021-07-22T12:22:01+08:00","permalink":"https://example.com/2021/%E6%88%91%E7%9A%84%E6%A8%A1%E6%9D%BF%E6%95%B4%E5%90%88%E7%89%88/","title":"我的模板（整合版）"},{"content":"数学小总结 质数 算术基本定理：$N = {P_1}^{k_1} \\times{P_2}^{k_2} \\times {P_3}^{k_3} \\cdots \\times {P_n}^{k_n} \\ \\ , \\ \\ P_1 \u0026lt; P_2 \u0026lt; P_3 \u0026lt; \\cdots \u0026lt; P_n$ 一个数N约数个数：$(k_1 + 1) \\times (k_2 + 1) \\times (k_3 + 1) \\times \\cdots \\times (k_n + 1)$，k是算术基本定理中的k 一个数N的所有正因数的和：$({P_1} ^ {0} + {P_1} ^ {1} + {P_1} ^ {2} \\cdots + {P_1} ^ {k_1})\\times ({P_2} ^ {0} + {P_2} ^ {1} + {P_2} ^ {2} \\cdots + {P_2} ^ {k_2}) \\times \\cdots \\times ({P_n} ^ {0} + {P_n} ^ {1} + {P_n} ^ {2} \\cdots + {P_n} ^ {k_n})$ 费马小定理：$a^{p - 1} \\equiv 1 \\pmod p$，p是素数 $1$至$10^9$范围内，两两质数之间的差最多292（记住300就好） 中位数 对于一个数列，$\\sum \\lvert x_i - y \\rvert$在y取数列的中位数时最小\ngcd $gcd(a, b) = gcd(b, a \\bmod b)$ $gcd(a, b) = gcd(a, b - a)$ 由算术基本定理： 假设$N = {P_1}^{a_1} \\times{P_2}^{a_2} \\times {P_3}^{a_3} \\cdots \\times {P_n}^{a_n}$ 而$M = {P_1}^{b_1} \\times{P_2}^{b_2} \\times {P_3}^{b_3} \\cdots \\times {P_n}^{b_n}$ 则$gcd(N, M) = P_1^{min(a_1, b_1)}\\times P_2^{min(a_2, b_2)}\\times P_3^{min(a_3, b_3)}\\times \\dots \\times P_n^{min(a_n, b_n)}$ $lcm(N, M) = P_1^{max(a_1, b_1)}\\times P_2^{max(a_2, b_2)}\\times P_3^{max(a_3, b_3)}\\times \\dots \\times P_n^{max(a_n, b_n)}$ 斐波那契数列$f(1) = 1, f(2) = 1, f(3) = 2\\dots$，则$gcd(f(a), f(b)) = f(gcd(a, b))$ 由第2条性质可推广：$gcd(a_1, a_2, a_3, \\dots a_n) = gcd(a_1, a_2 - a_1, a_3 - a_2\\dots a_n - a_{n- 1})$ $gcd$具区间单调性：对于区间$l_3 \\le l_2 \\le l_1 \\le r_1 \\le r_2 \\le r_3$ $gcd(l_3, r_3)\\le gcd(l_2, r_2) \\le gcd(l_1, r_1)$ $gcd$具有区间反向包含性质：对于$gcd(l_1, r_1)$，$gcd(l_2, r_2)$，$l_1\\le l_2 \\le r_2 \\le r_1$则$gcd(l_1, r_1)$一定是$gcd(l_2, r_2)$的因子。 卡特兰 公式一：$f(n) = \\sum_{i = 0}^{n - 1}{f(i) \\times f(n - i - 1)}$ 公式二：$f(n) = \\frac{f(n - 1) \\times (4n - 2)}{n + 1}$ 公式三：$f(n) = \\frac{C_{2n}^{n}}{n + 1}$ 公式四：$f(n) = C_{2n}^{n} - C_{2n}^{n - 1}$ 变形：给你$n$个1和$m$个0组合$n \\ge m$，求一个组合满足前k个中1的个数不少于0的个数的方案数：$C_{n + m}^{n} - C_{n + m}^{n - 1}$ 组合数 通项公式：$C_{n}^{m} = \\frac{n!}{m!(n - m)!} = \\frac{n\\times(n - 1)\\times \\dots \\times (n - m + 1)}{m!}$ 递推公式：$C_{n}^{m} = C_{n - 1}^{m - 1} + C_{n - 1}^{m} = \\frac{n - m + 1}{m}\\times C_{n}^{m - 1}$ 有重复元素的全排列：有k个元素，取其中第i个元素有$n_i$个，全排列的个数：$\\frac{n!}{n_1!n_2!n_3!\\dots n_k!}$，其中$n = \\sum{n_i}$ 可重复选择的组合：有n个不同元素，每个元素可以选多次，一共选k个元素，方案数：$C_{k + n - 1}^{n - 1}$ 性质1：$C_{n + m + 1}^{m} = \\sum_{i = 0}^{m}{C_{n + i}^{i}}$ 性质2：$C_{n}^{m}\\times C_{m}^{i} = C_{n}^{i}\\times C_{n - i}^{m - i}$ 性质3：$\\sum_{i = 0}^{n}{C_{n}^{i}} = 2 ^ n$ 性质4：$\\sum_{i = 0}^{n}{C_{n}^{i}\\times x^i} = (x + 1)^n$ 性质5：$C_{n}^{0} - C_{n}^{1} + C_{n}^{2} - \\dots \\pm C_{n}^{n} = 0$ 性质6：$C_{n}^{0} + C_{n}^{2} + C_{n}^{4}+\\dots = C_{n}^{1}+C_{n}^{3}+C_{n}^{5}+\\dots = 2^{n - 1}$ 性质7：$C_{n + m}^{i} = C_{n}^{0} \\times C_{m}^{i} + C_{n}^{1} \\times C_{m}^{i - 1} \\times \\dots \\times C_{n}^{i}\\times C_{m}^{0}$ 性质8：$m \\times C_{n}^{m} = n \\times C_{n - 1}^{m - 1}$ 性质9：$\\sum_{i = 1}^{n}{C_{n}^{i}\\times i}= n \\times 2^{n - 1}$ 性质10：$\\sum_{i = 1}^{n}{C_{n}^{i}} \\times i^2 = n \\times (n + 1) \\times 2^{n - 2}$ 性质11：$\\sum_{i = 0}^{n}{(C_{n}^{i})^2} = C_{2n}^{n}$ 斯特林数 第一类斯特林数\n记作 ${n \\brack m}$，写作 $s(n, m)$\n将n个不同的数，分成m组（每组都不能为空），每组都是一个环（圆排列），求不同方案数\n递推式 $$ {n \\brack m} = {n - 1\\brack m - 1} + (n - 1) \\times {n - 1 \\brack m} $$\n通项公式：无 性质1 ：$s(0, 0) = 1$ 性质2 ：$s(n, 0) = 0$ 性质3 ：$s(n, n) = 1$ 性质4 ：$s(n, 1) = (n - 1)!$ 性质5 ：$s(n, n - 1) = C_n^2$ 性质6 ：$s(n, 2) = (n - 1)! \\times \\sum_{i=1}^{n-1}1/i$ 性质7 ：$\\sum_{i=0}^n s(n, i) = n!$ 性质8 ：$s(n,n-2) = 2 C_n^3 + 3 C_n^4$ 性质9 ：$s(n, m) = \\sum_{i = 1}^n C_{n-1}^{i - 1}(i - 1)!s(n - i, m - 1)$ 第二类斯特林数\n记作${n \\brace m}$，写作 $S(n, m)$\n将n个不同的数，分成m组（每组都不能为空），求不同方案数\n递推式 $$ {n \\brace m} = {n - 1 \\brace m - 1} + m \\times {n - 1\\brace m} $$\n通项公式： $$ {n \\brace m} = \\frac{1}{m!}\\sum_{i=0}^m (-1)^i C_m^i (m - i)^n $$\n卷积形式公式：(利用该公式，可以使用FFT求出所有${n \\brace 0},{n \\brace 1}\u0026hellip;{n \\brace n}$),令$f_i=(-1)^i/i!$，$g_i=i^n/i!$，$S(n,i) = f * g$ $$ {n \\brace m} = \\sum_{i=0}^m\\frac{(-1)^i(m-i)^n}{i!(m-i)!} $$\n性质1 ：$S(0, 0) = 1$ 性质2 ：$S(n, 0) = 0$ 性质3 ：$S(n, 1) = 1$ 性质4 ：$S(n, n) = 1$ 性质5 ：$S(n, 2) = 2^{n - 1} - 1$ 性质6 ：$S(n, n - 1) = C_n^2$ 性质7 ：$S(n,n-2)=C_n^3 + 3 C_n^4$ 性质8 ：$S(n,3) = \\frac{1}{2} (3^{n-1} + 1) - 2^{n - 1}$ 性质9 ：$S(n,n-3) = C_n^4 + 10 C_n^5 + 15 C_n^6$ 性质10 ：$S(n, m) = \\sum_{i = 1}^nS(n - i, k - 1) C_{n - 1}^{i - 1}$ 性质11 ：$x^n = \\sum_{i = 0}^xS(n, i) \\times C_x^i \\times i!$ 两类斯特林的关系\n$$ \\sum_{i=0}^n {n \\brack i} {i \\brace m} = \\sum_{i=0}^n {n \\brace i} {i \\brack m} $$\n欧拉函数 性质1：若p为质数则$\\phi(p) = p - 1$ 性质2：若p为质数则$\\phi(p^a) = (p - 1) \\times p^{a - 1}$ 性质3：当$n$，$m$互质时，则有$\\phi(nm) = \\phi(n) \\times \\phi(m)$ 性质4：若$a$，$m$互质时，则有$a^{\\phi(m)} \\equiv 1 \\pmod m$ 性质5：若$p$为质数，且$i \\bmod p = 0$，则$\\phi(i \\times p) = p \\times \\phi(i)$ 性质6：若$p$为质数，且$i \\bmod p \\ne 0$，则$\\phi(i \\times p) = \\phi(i) \\times (p - 1)$ 性质7：若$n$为奇数，则$\\phi(2n) = \\phi(n)$ 性质8：若$n$、$p$互质，则$p-n$也与$p$互质，因此小于$p$且与$p$互质的数之和为$\\phi(n) \\times n / 2$ 性质9：若$n \u0026gt; 1$，则小于$n$且与其互质的所有正整数之和为$\\phi(n) \\times n / 2$ 欧拉降幂公式 一般将第一行的情况会当做第三行处理 $$ a^b \\equiv \\begin{cases} a^{b \\bmod \\phi (p)} \u0026amp; gcd(a, p) = 1 \\newline a^{b} \u0026amp; gcd(a, p) \\ne 1 , b\u0026lt; \\phi (p) \\newline a^{b \\bmod \\phi (p) + \\phi (p)} \u0026amp; gcd(a, p) \\ne 1 , b \\geqslant \\phi (p) \\end{cases} \\pmod p $$\n求和公式的变换 无关系数提前：$\\sum_{i=0}^{n} p \\ f(i) = p\\sum_{i=0}^{n} f(i)$ 左右置换：$\\sum_{i=0}^n \\sum_{j=0}^m f(i) \\ast g(j) = \\sum_{j=0}^m \\sum_{i=0}^n f(i) \\ast g(j)$ 矩阵的下三角：$\\sum_{i=0}^n \\sum_{j=0}^{i} f(i) \\ast g(j) = \\sum_{j=0}^n \\sum_{i=j}^n f(i) \\ast g(j)$ 因数和倍数枚举的变换：$\\sum_{i = 1}^n \\sum_{d\\vert i} f(i) \\ast g(d) \\ast h(\\frac{i}{d})= \\sum_{d=1}^n \\sum_{i=1}^{\\lfloor \\frac{n}{d} \\rfloor} f(i \\times d) \\ast g(d) \\ast h(i)$ 莫比乌斯反演公式 莫比乌斯函数，p为质数，q为整数 $$ \\mu (n) = \\begin{cases} (-1)^k \u0026amp; n = p_1\\ p_2\\ p_3 \\ldots p_k \\newline 0 \u0026amp; n = p^2 q \\end{cases} $$\n性质1：$\\sum_{d \\vert n} \\mu(d) = [n == 1]$ 性质2：$\\sum_{d \\vert n} \\frac{\\mu(d)}{d} = \\frac{\\phi(n)}{n}$ 莫比乌斯反演公式\n一般形式（因子关系） $$ \\begin{aligned} f(n) \u0026amp;= \\sum_{d \\vert n} \\ g(d) \\newline g(n) \u0026amp;= \\sum_{d \\vert n} \\mu(d) \\ f(\\frac{n}{d}) \\end{aligned} $$\n其他形式（倍数关系） $$ \\begin{aligned} f(n) \u0026amp;= \\sum_{n \\vert d} \\ g(d) \\newline g(n) \u0026amp;= \\sum_{n \\vert d} \\mu(\\frac{d}{n}) \\ f(d) \\end{aligned} $$\n二项式反演公式 通常用来解决容斥问题 函数$f$一般和函数$g$互为补集 一般形式 $$ \\begin{aligned} f(n) \u0026amp;= \\sum_{i=0}^{n} \\ (-1)^i \\ C_n^i \\ g(i) \\newline g(n) \u0026amp;= \\sum_{i=0}^{n} \\ (-1)^i \\ C_n^i \\ f(i) \\end{aligned} $$\n常见形式 $$ \\begin{aligned} f(n) \u0026amp;= \\sum_{i=0}^{n} \\ C_n^i \\ g(i) \\newline g(n) \u0026amp;= \\sum_{i=0}^{n} \\ (-1)^{n-i} \\ C_n^i \\ f(i) \\end{aligned} $$\n其他形式 $$ \\begin{aligned} f(n) \u0026amp;= \\sum_{i=n}^{m} \\ C_i^{n} \\ g(i) \\newline g(n) \u0026amp;= \\sum_{i=n}^{m} \\ (-1)^{i-n} \\ C_i^n \\ f(i) \\end{aligned} $$\n斯特林反演公式 一般形式 $$ \\begin{aligned} f(n) \u0026amp;= \\sum_{i = 0}^{n} \\ {n \\brace i} \\ g(i) \\newline g(n) \u0026amp;= \\sum_{i = 0}^{n} \\ (-1)^{n - i} \\ {n \\brack i} \\ f(i) \\end{aligned} $$\n阶 性质1：$a, a^2, \\dots,a^{\\delta_m(a)}$模m两两不同余 性质2：若 $a^n \\equiv 1 \\pmod m$，则$\\delta_m(a) \\vert n$ 性质3：对于正整数$m$，整数$a, b$，若有$gcd(a, m) = gcd(b, m) = 1$,则 $\\delta_m(ab) = \\delta_m(a)\\delta_m(b)$ 的充要条件是 $gcd(\\delta_m(a), \\delta(b)) = 1$ 性质4：对于非负整数k，正整数m，整数a，若有$gcd(a, m) = 1$, 则$\\delta_m(a^k) = \\frac{\\delta_m(a)}{gcd(\\delta_m(a), k)}$ 原根 定义：对于正整数$m$，存在整数$a$且$gcd(a, m) = 1$，且$\\delta_m(a) = \\phi(m)$，则说a为m的原根\n原根判定定理：设$m\\ge 3$ , $gcd(a, m) = 1$，则$a$是模$m$的原根的充要条件是，对于$\\phi(m)$的每一个质因子$p$，都有$a^{\\frac{\\phi(m)}{p}} \\not \\equiv 1 \\pmod m$，这从原根的定义和上述阶的性质2来想就很好理解\n若$m$有原根，则其原根的个数为$\\phi(\\phi(m))$\n原根存在定理：对于一个数$m$有原根，当且仅当 $m = 2, 4, p^{x},2p^x$，其中$p$为奇素数，x为正整数\n若$m$有原根$g$则其他原根可以写$g^x \\pmod m$，其中x是不大于$\\phi(m)$的数且与$\\phi(m)$互质的数（可以用原根判定定理来理解）\n多项式乘法/卷积 常见乘法，直接套FFT/NTT就好了 $$ h(i) = \\sum_{j = 0}^{i} f(i) \\times g(i - j) $$ 需要对其中一个多项式进行翻转后再套FFT/NTT（n一般为f函数的最高项式x的幂） $$ \\begin{aligned} h(i) \u0026amp;= \\sum_{j = i}^n f(j) \\times g(j - i) \\newline \u0026amp;= \\sum_{j = 0}^{n - i} f(i + j) \\times g(j) \\newline \u0026amp;\\text{令} \\ rev(i) = f(n - i) \\newline H(i) \u0026amp;= \\sum_{j = 0}^{i} rev(i - j) \\times g(j) \\newline h(i) \u0026amp;= H(n - i) \\end{aligned} $$ 分治 + FFT（注意不是分治FFT） $$ \\prod_{i = 0} \\sum (a_i + b_i \\times x) $$ 卷积满足交换律、结合律、加法分配律 $$ \\begin{aligned} f * g \u0026amp;= g * f \\newline (f * g) * h \u0026amp;= f * (g * h) \\newline f * (g + h) \u0026amp; = f * g + f * h \\end{aligned} $$\n分治FFT $$ f(i) = \\sum_{j = 0}^{j - 1} f(j) \\times g(i - j) $$\nNTT一些模数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //（g 是mod(r*2^k+1)的原根） // 素数 r k g 469762049 7 26 3 998244353 119 23 3 1004535809 479 21 3 75161927681 35 31 3 206158430209 3 36 22 2061584302081 15 37 7 39582418599937 9 42 5 263882790666241 15 44 7 1231453023109121 35 45 3 31525197391593473 7 52 3 180143985094819841 5 55 6 1945555039024054273 27 56 5 4179340454199820289 29 57 3 拉格朗日插值公式 $$ f(x) = \\sum_{i = 1}^n y_i \\prod_{j \\ne i} \\frac{x - x_j}{x_i - x_j} $$\n一些求方案数的问题 将n个相同的小球放入m个相同的盒子，盒子不能为空：设方案数为$f_1(n, m)$ 理解1：$f_1(n, m) = f_1(n - 1, m - 1) + f_1(n - m, m)$, 有一个位置只有一个球的方案 + 先所有位置都预先放一个球的方案(所有位置都大于1)，边界条件$f_1(n, m) = 0, n \u0026lt; m \\text{或} n \u0026lt; 0$, $f_1(n, m) = 1, n = m \\text{或} m = 1$ 理解2：本质就是背包问题，用m个正整数组成的和为n的方案数，$f_1(n, m) = dp(n, m) = \\sum_{i=1}^ndp(n - i, m - 1), i \u0026gt; 0$ 将n个相同的小球放入m个不同的盒子，盒子不能为空：设方案数为$f_2(n, m)$ 理解1：隔板法得出方案数为 $f_2(n, m) = C_{n-1}^{m-1}$ 理解2：也可以当做分组背包问题做（每组物品容量为正整数） 将n个不同的小球放入m个相同的盒子，盒子不能为空：设方案数为$f_3(n, m)$ 理解1：其实就是第二类斯特林数的问题：$f_3(n, m) = {n \\brace m}$ 理解2：讨论第一个球是否单独在一个盒子里面，单独放则为$f_3(n-1, m-1)$，否则为$f_3(n - 1, m) \\times m$ 理解3：容斥原理（第二类斯特林数的通项公式），站在球的视角枚举空盒子的个数，即对于每个球就有$m - k$种放法，由于盒子相同，所以要除以$m!$ 将n个不同的小球放入m个不同的盒子，盒子不能为空：设方案数为$f_4(n, m)$ 理解1：其实不难发现就是在问题3的基础上多了个全排列，固$f_4(n, m) = f_3(n, m) \\times m!$ 将n个相同的小球放入m个相同的盒子，盒子可以为空：设方案数为$f_5(n, m)$ 理解1：$f_5(n, m) = f_5(n, m - 1) + f_5(n - m, m)$, 有一个位置为空的方案 + 先所有位置都预先放一个球的方案（没有位置为空），边界条件$f_5(n, m) = 0, n \u0026lt; 0$, $f_5(n, m) = 1, n == 1 \\text{或} m == 1$ 理解2：本质就是背包问题，用m个非负整数组成的和为n的方案数，$f_5(n, m) = dp(n, m) = \\sum_{i=1}^ndp(n - i, m - 1), i \u0026gt;= 0$ 理解3：不难发现和问题1相关，固枚举空位置的个数即可$f_5(n, m) = \\sum_{i = 1}^mf_1(n, i)$ 将n个相同的小球放入m个不同的盒子，盒子可以为空：设方案数为$f_6(n, m)$ 理解1：隔板法推到得出方案数为 $f_6(n, m) = C_{n + m - 1}^{m-1}$ 理解2：也可以当做分组背包问题做（每组物品容量为非负整数） 将n个不同的小球放入m个相同的盒子，盒子可以为空：设方案数为$f_7(n, m)$ 理解1：可以发现和问题3相关，枚举为空的个数即可：$f_7(n, m) = \\sum_{i=1}^{m}f_3(n, i)$ 将n个不同的小球放入m个不同的盒子，盒子可以为空：设方案数为$f_8(n, m)$ 理解1：其实不难发现就是在问题7的基础上求和时多了个排列，固$f_8(n, m) = \\sum_{i=1}^{m} A_m^i \\times f_3(n, i)$ 概率 假设有一个整数随机变量X，则有$p(X = k) = p(X \\ge k) - p(X \u0026gt; k)$ 概率加法：$P(A \\cup B) = P(A) + P(B) - P(AB)$ 独立条件：$P(AB) = P(A)P(B)$ 条件概率：$P(A|B) = \\frac{P(AB)}{P(B)}$ 贝叶斯公式：$P(A | B) = \\frac{P(A)P(B|A)}{P(B)}$ 期望 期望的线性：$E(aX + bY) = aE(X) + bE(Y)$ 同理，如果$X_1 + X_2 = X$，则$E(X) = E(X_1) + E(X_2)$ 假如X是一个随机正整数变量，则$E(X) = \\sum_{i = 1}^{\\infty}{P(X \\ge i)}$ ","date":"2021-07-21T12:22:01+08:00","permalink":"https://example.com/2021/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%BB%93%E8%AE%BA/","title":"一些有用的数学公式与结论"},{"content":"树形背包思考方式 树形背包常用思考模型 模型一 首先对于每个节点我们在dfs中dp转移时可以想象成一个分组背包，每次新遍历一个子树就可以想象成一个分组背包的下一组，转移时利用之前的背包状态进行转移，如果觉得这个模型比较难理解可以看下面的模型二。 模型二 首先对于每次新遍历一个结点我们都可以想象成是在给这个结点拼接一颗子树如下图 模型图 解释：圆点为树的结点，三角形为一颗子树，线段为边，箭头是拼接方向。蓝色为之前计算好的状态的树，红色为即将拼接上去的一颗子树（这颗子树在dfs时计算好了所有状态） 模型一与模型二的联系 回到模型二，我们可以把蓝色部分想象成是分组背包中的前k - 1个背包状态，红色被第k组背包，子树中的每个方案都是分组背包中的一个物品，可以结合题目进行理解 需要注意的点：当我们在转移时一定要保证状态合法，例如转移时利用到的状态必须是这个树真的有这么多个结点 【例题1】P3177 树上染色 思路 一道树形dp题，想了好久，最终看了题解发现是突破口不对 突破口：首先思考怎么求一条边被算过的次数，用组合数学方法思考可以想到就是这条边两个方向（定义一个左边，一个右边）的黑点个数的乘积 + 白点个数的乘积 假设左边黑点的个数是x，且其左边节点个数是size， 树的总结点个数为n，则这条边计算次数有下面的公式 $$ tot = x \\times (k - x) + (size - x) \\times (n - size - k + x) $$\n有了这个突破口就可以思考怎么dp了 首先要明白每条边必定会对最终的答案做出贡献，固我们可以这样来定义状态：$dp[u][i]$表示节点u的子树选i个黑点的最大贡献，由树形背包模型(对应博客点这里)可以得到方程，不难得出状态方程这样写 $$ dp[u][i] = max{ dp[son][j] + dp[u][i - j] + tot \\times w } $$ 值得注意的点：$i - j$可能并没有这个状态，即可能这颗树在当前转移之前并没有$i - j$个节点，有一种解决方式就是将dp值初始化为-1，若在转移时dp值变了就证明他是合法的，否则并不合法 但是这种转移经过讨论好像他的复杂度接近$O(n^3)$ 还有一种的转移方式就是 $$ dp[u][i + j] = max{ dp[son][i] + dp[u][j] + tot \\times w} $$ 这样转移的话洛谷是可以拿到100分的，这样就能保证转移时每个子树都只在他们的lca上计算一次，代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int dfs(int u, int fa) { int cnt = 1; // dp[u][1] = dp[u][0] = 0; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v ^ fa) { ll \u0026amp;w = edge[i].w; int son = dfs(v, u); for (int k = min(m, cnt); ~k; --k) { // 还是要反过来遍历 for (int j = min(son, m); ~j; --j) { if (j + k \u0026gt; m) continue; ll tot = j * (m - j) + (son - j) * (n - son - m + j); dp[u][j + k] = max(dp[u][j + k], dp[u][k] + dp[v][j] + tot * w); } } cnt += son; } } return cnt; } 注意到我第8行和之前的代码对应的循环都是反过来遍历的，原因也解释过了，这个是01背包中我们空间优化时利用到的转移方式用来防止转移覆盖的问题，当然还有一种不用担心转移覆盖的方式，贴上学长巨巨的代码，简单易懂 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long #define pii pair\u0026lt;int,int\u0026gt; #define pb push_back #define mp make_pair const int maxn = 2000 + 5; const int mod = 1e9 + 7; ll dp[maxn][maxn]; ll sz[maxn] , n; vector\u0026lt;pii\u0026gt; e[maxn]; ll tmp[maxn] , up; void dfs (int u , int fa) { sz[u] = 1; for (auto g : e[u]){ int v = g.first; ll w = g.second; if (v == fa) continue; dfs(v , u); for (int i = 0 ; i \u0026lt;= sz[u] + sz[v]; i++) tmp[i] = dp[u][i]; for (int i = 0 ; i \u0026lt;= min(sz[u] , up) ; i++){ for (int j = 0 ; j \u0026lt;= min(sz[v] , up) ; j++){ if (i + j \u0026gt; up) continue; ll val = 1ll * j * (up - j) /*黑点*/ + 1ll * (sz[v] - j) * (n - sz[v] - (up - j)); val *= w; tmp[i + j] = max (tmp[i + j] , dp[u][i] + dp[v][j] + val); } } for (int i = 0 ; i \u0026lt;= sz[u] + sz[v] ; i++) dp[u][i] = tmp[i]; sz[u] += sz[v]; } return ; } int main() { ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; up; for (int i = 1 ; i \u0026lt; n ; i++){ int x , y , z; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z; e[x].pb (mp(y , z)); e[y].pb (mp(x , z)); } dfs (1 , 0); cout \u0026lt;\u0026lt; dp[1][up] \u0026lt;\u0026lt; endl; return 0; } 总结：这题是一个基础的树上背包问题，但是找到突破口很重要，不然可能怎么树上dp都不知道，解决方式：多刷题 【例题2】P1272 重建道路 思路 根据树上背包模型可以想到状态定义：$dp[u][i]$表示以u结点为根结点的子树生成只有i个结点的最少去掉的边数，转移方程如下： $$ dp[u][i + j] = min{ dp[u][i] + dp[son][j]} $$\n这里有一个技巧，为了防止转移时覆盖，固用一个tmp函数存起计算的状态 其余需要注意的细节看代码注释 ac代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cctype\u0026gt; inline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == \u0026#39;-\u0026#39;) f = true; c = getchar(); } while (isdigit(c)) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c - \u0026#39;0\u0026#39;); c = getchar(); } return f ? -x : x; } #define ll long long using namespace std; const int M = 2e3 + 5; const int maxn = 2e3 + 5, maxm = 2e3 + 5; const int INF = 0x3f3f3f3f; int head[maxn], cnt; //初始化 void init() { memset(head, -1, sizeof head); cnt = -1; } struct edges { int to, next; }edge[maxm \u0026lt;\u0026lt; 1]; //无向图则需要乘2 inline void add(int u, int v) { edge[++cnt] = {.to = v, .next = head[u]}; head[u] = cnt; } int dp[M][M], siz[M], tmp[M]; int n, m; void dfs(int u, int fa) { // 初始化，根据树形背包模型，一开始的只保留一个结点去掉的边数为0， 保留0个的去掉的边数是1，即拼接上去的那条边 siz[u] = 1, dp[u][1] = 0, dp[u][0] = 1; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (v == fa) continue; dfs(v, u); for (int j = 1; j \u0026lt;= siz[u] + siz[v]; ++j) tmp[j] = INF; // 用一个tmp存计算的状态，防止转移覆盖原来需要用到的dp值 for (int j = 1; j \u0026lt;= siz[u]; ++j) { // 当前树保证必须选一个 for (int k = 0; k \u0026lt;= siz[v]; ++k) { // 子树从0开始 tmp[j + k] = min(tmp[j + k], dp[u][j] + dp[v][k]); } } siz[u] += siz[v]; for (int j = 1; j \u0026lt;= siz[u]; ++j) dp[u][j] = tmp[j]; } } int main() { n = IO(), m = IO(); init(); for (int i = 1; i \u0026lt; n; ++i) { int u = IO(), v = IO(); add(u, v), add(v, u); } memset(dp, 0x3f, sizeof dp); // 所有都初始化为最大值 dfs(1, -1); int ans = dp[1][m]; for (int i = 2; i \u0026lt;= n; ++i) if(siz[i] \u0026gt;= m) ans = min(ans, dp[i][m] + 1); // 最终的答案不一定是在1号结点上去边， +1是因为要加上去除连接父亲结点的边 printf(\u0026#34;%d\u0026#34;, ans); return 0; } 总结：树上背包dp的时候无论是初始化还是转移的时候都需要树上背包模型为基础来考虑 【例题3】P1273 有线电视网 思路\n这题想了好久，唯一想到比较有用的就是假设$dp[u][j]$表示以u为根结点的子树花费j元最多可以提供多少用户，然后就没有然后了，都不知道怎么转移，看了学长巨巨的思路后发现新大陆，原来还可以利用换意的方式进行dp，即转台这样定义：$dp[u][i]$表示以u为根结点的子树提供j个用户最多能赚多少钱，这样转移又方便，最后的答案就是$dp[1][i]$中大于等于0的最大i\n转移方程： $$ dp[u][i + j] = max{ dp[u][i] + dp[son][j] - w} $$\n其余细节看代码注释\nac代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cctype\u0026gt; inline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == \u0026#39;-\u0026#39;) f = true; c = getchar(); } while (isdigit(c)) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c - \u0026#39;0\u0026#39;); c = getchar(); } return f ? -x : x; } #define ll long long using namespace std; const int M = 3e3 + 5; const int maxn = 3e3 + 5, maxm = 3e3 + 5; const ll inf = 0xffffffff; int head[maxn], cnt; //初始化 inline void init() { memset(head, -1, sizeof head); cnt = -1; } struct edges { int to, next; ll w; }edge[maxm \u0026lt;\u0026lt; 1]; //无向图则需要乘2 inline void add(int u, int v, ll w) { edge[++cnt] = {.to = v, .next = head[u], .w = w}; head[u] = cnt; } ll mon[M], sum, dp[M][M], son[M], tmp[M]; int n, m; void dfs(int u) { if (u \u0026gt; n - m) son[u] = 1, dp[u][1] = mon[u]; // 如果是叶子节点则赚的钱就是他自己， 且叶子个数为1 dp[u][0] = 0; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; dfs(v); for (int j = 1; j \u0026lt;= son[u] + son[v]; ++j) tmp[j] = -inf; // 防止转移时覆盖，初始化tmp为负无穷，当然用01背包的方式逆向循环也可以 for (int j = 0; j \u0026lt;= son[u]; ++j) { for (int k = 0; k \u0026lt;= son[v]; ++k) { ll w = (k == 0 ? 0 : edge[i].w); // 如果子树一个叶子都不选当然不用减去子树的拼接边（回忆述树上背包模型） tmp[j + k] = max(tmp[j + k], dp[u][j] + dp[v][k] - w); } } son[u] += son[v]; for (int j = 1; j \u0026lt;= son[u]; ++j) dp[u][j] = tmp[j]; } } int main() { n = IO(), m = IO(); init(); for (int i = 1; i \u0026lt;= n - m; ++i) { int k = IO(); while (k--) { int a = IO(), c = IO(); add(i, a, c); } } memset(dp, 0xfe, sizeof dp); // 初始化为最小值 for (int i = n - m + 1; i \u0026lt;= n; ++i) mon[i] = IO(); dfs(1); int ans = 0; for (int i = 1; i \u0026lt;= m; ++i) { // printf(\u0026#34;%lld\\n\u0026#34;, dp[1][i]); if (dp[1][i] \u0026gt;= 0) ans = max(ans, i); // 寻找最大值i } printf(\u0026#34;%d\u0026#34;, ans); return 0; } 总结：这题需要状态定义有点新奇，当定义状态时发现没办法转移或者是没办法存下这个状态就考虑换意一下 ","date":"2021-07-20T12:22:01+08:00","permalink":"https://example.com/2021/%E6%A0%91%E5%BD%A2%E8%83%8C%E5%8C%85%E6%80%9D%E8%80%83%E6%96%B9%E5%BC%8F/","title":"树形背包思考方式"},{"content":"一、前言 本博客对ACM的常用的函数和c++STL做一个简单的总结 显然善用这些函数，可以对代码做大幅度地简化 本文主要对每个头文件/函数分常用和不常用做总结 注意：本博客只是针对编程竞赛中比较常用的用法，只是浅谈（因为用来打比赛够了），想要深入同学可以移步直接看c++官方提供的详细用法 用法：自己根据目录导航到自己想看的地方 二、一些非STL的常用函数 1. cstdio头文件 1.1 scanf函数（常用） 一个输入函数\n基本形式为(以输入整数int型为例)，一般传入两个参数，第一个是格式化字符串，第二个是变量引用\n1 2 3 int a, b, c; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a);//输入一个 scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c);//输入多个 其中需要注意的是，逗号后面的必须传入的是需要输入的变量的地址，固一般在变量名前加一个\u0026amp;（取地址符）\n由于需要传入的是地址，固我们在输入数组时也可以这样做\n1 2 3 int arr[10010]; for (int i = 0; i \u0026lt; 10000; ++i) scanf(\u0026#34;%d\u0026#34;, \u0026amp;arr[i]);//常规输入 for (int i = 0; i \u0026lt; 10000; ++i) scanf(\u0026#34;%d\u0026#34;, arr + i);//和上面的是同理的 当然，还有一个特别需要注意的就是输入字符串 1 2 3 char str[110]; scanf(\u0026#34;%s\u0026#34;, str);//下标从0开始的字符串 scanf(\u0026#34;%s\u0026#34;, \u0026amp;str[1]);//下标从1开始的字符串 一些小技巧\n刷题的时候可能有些新手对下面类似这种输入很头痛\n3\na 7\nb 8\nk 100\n常规的做法就是开一个char数组，将字符当初字符串输入\n1 2 3 4 5 6 char q[2]; int t, n; scanf(\u0026#34;%d\u0026#34;, t); while (t--) { scanf(\u0026#34;%s%d\u0026#34;, q, \u0026amp;n); } 这种做法，在某些情况下可能还需要一个getchar()函数进行辅助（例如吃掉换行符），但下面这种做法，可以发挥出强大的scanf的优势。做法就是，他怎么样，在输入是就当成自己输出时会怎么样 1 2 3 4 5 6 char q; int t, n; scanf(\u0026#34;%d\\n\u0026#34;, \u0026amp;t);//加个换行符 while (t--) { scanf(\u0026#34;%c %d\\n\u0026#34;, \u0026amp;q, \u0026amp;n); // 加个空格和回车符 } scanf的强大还远远不止这些，例如下面这个时间输入，做题时用到的只有数字，但题目偏偏有其他字符\n12:30:22\n和上面的同理，我们可以这样输入\n1 2 int h, m, s; scanf(\u0026#34;%d:%d:%d\u0026#34;, \u0026amp;h, \u0026amp;m, \u0026amp;s); scanf函数返回的是输入变量的个数，若是无输入，则返回-1，固我们在遇到不定组输入时，scanf可以这样 1 2 3 4 int n; while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;n) != -1) { //循环体 } 其余细节见printf函数内容 1.2 printf函数（常用） 与scanf相对，printf是c的一个输出函数 基本形式为(以整数int型为例)，第一个参数是格式化字符串，第二个是需要输出的变量 1 printf(\u0026#34;%d\u0026#34;, n);//注意，没有取地址符号 关于printf的一般形式起始和scanf差不多，下面具体要扩展的是不同类型的格式化字符串（引号里的东东）和常见的输出格式\n关于不同类型的格式化字符串（常用）\n类型 int float double char char * long long 字符 %d %f %lf %c %s %lld 关于不同类型的格式化字符串（不常用） 类型 unsigned int unsigned long long long double size_t 无符型8进制 无符型16进制 字符 %u %llu %Lf %zu %o %x或%X 一些需要注意的\n关于long long 好像对与不同的编译器使用的是不同的，但本人用%lld很少出问题 double 如果使用printf函数输出%lf和%f都是可以的，但是scanf必须严格区分 注意long double 的%Lf是大写的 对于不用的编译器size_t对应不同的类型 如果要输出%则打%%就行了 其实以上问题用c++中的cout和cin都可以解决 关于转义字符只需要知道换行符 \\n 便可以了，需要注意的是如果要输入反斜杠或者引号只需要在符号前多加一个反斜杠便可，例如 \\\\\n常用的输出格式\n输出精度，自动四舍五入（常用） 1 2 3 double x = 3.141592653; printf(\u0026#34;%.3f\\n\u0026#34;, x); //输出3.142 printf(\u0026#34;%.5f\\n\u0026#34;, x); //输出3.14159 输出格式每个整数占w格，右对齐，多得补0或者空格（默认是空格）（不常用） 1 2 3 int x = 123; printf(\u0026#34;%5d\\n\u0026#34;, x); //输出 123，默认补空格 printf(\u0026#34;%05d\\n\u0026#34;, x); //输出00123, 补0 1.3 sscanf函数（不常用） sscanf函数虽然不怎么常用，但其功能也是十分黑科技，此函数在刷UVA的题时用得比较多，但依然这个函数不重要，知道以下用法便好\n首先要知道的是，此函数的功能时将字符串中的数字读入至自己声明变量中去，使用方式和scanf十分类似，第一个参数是需要读的字符串，第二个参数是格式化字符串，第三个参数是需要写的变量引用\n1 2 3 4 char str[] = \u0026#34;x:200 y:100\u0026#34;; int x, y; sscanf(str, \u0026#34;x:%d y:%d\u0026#34;, \u0026amp;x, \u0026amp;y); printf(\u0026#34;%d %d\\n\u0026#34;, x, y); // 输出200 100 1.4 sprintf函数（不常用） 和sscanf同理，用法和printf十分相似，第一个参数是需要写入的字符串，第二个是参数是格式化字符串，第三个参数是需要读的变量，看下面的例子 1 2 3 4 double PI = 3.1415926; char str[100]; sprintf(str, \u0026#34;PI = %.3f\u0026#34;, PI); printf(\u0026#34;%s\u0026#34;, str); // 输出 PI = 3.142 1.5 gets函数（部分不常用） 此函数由于其安全性低被淘汰了（读取一行字符串，不管自己申请的char字符串空间长度够不够都会一直读，直至遇到\\n换行符，还有就是其读取至换行符\\n停止，但好像Linux和Windows的换行符是不一样的），但是这些工程上的东西关我们打比赛的什么事呢？\n之所以说部分不常用是因为有些oj不给使用该函数了（例如洛谷），但还是有很多oj网站支持的，此函数读取字符串不仅速度快，而且能读一行，还是挺有用的\n使用形式，传入需要读入的字符串头指针\n1 2 3 4 char str[100]; gets(str); //读入字符串下标从0开始 gets(\u0026amp;str[1]); //下标从1开始 gets(str + 1); //下标从1开始 还有一件事，此函数若读取成功则返回读入的字符串，否则返回NULL（不定组输入有用） 1.6 fgets函数（不常用） 据说此函数比较适合替代gets函数（个人觉得如果可以用gets用也是可以的），可能由于此函数需要的参数比较多，所以许多人不怎么喜欢在做题时使用他\n常见形式，第一个参数是需要读入的字符串，第二个参数是需要读入的字符串的长度，第三个参数若没有特殊（读入文件）一般写stdin\n1 2 char str[110]; fgets(str, 110, stdin); 此函数的返回值和gets一样 2. cstring头文件 这个头文件中其实主要知道常用的函数便可以了，其余的想什么处理字符串拼接之类的，说实话如果不卡常，使用stl中的string巨香 2.1 memset函数（常用） memset通常用来初始化数组，需要注意的是他是按字节赋值的（下面会解释），时间复杂度为$O(n)$\n常见形式，第一个参数是需要初始化的数组首地址，第二个参数是初始化字节值，第三个参数是需要初始化的字节大小\n1 memset(arr, val, sizeof arr); 对于上面的代码，若arr的类型为int，则它将会对arr进行字节赋值，就拿此arr来说，每一个arr元素都是一个int类型的变量，即每个元素占4个字节，memset后其每个元素就会变成val val val val的二进制形式，换句话说，若val = 1，则每个元素的二进制形式就会被初始化成 00000001 00000001 00000001 00000001 ，其最终结果就是16843009而不是1\n固推荐刚入手的同学可以只将val设置成0(0), -1(-1)对常见的int、long long赋值，其中括号内表示memset后每个元素的值，对于bool类型，val可以设置成0(false),非0即其他数(true)\n对于memset的其他进阶操作\n首先要知道0x3f = 63，0x7f = 127，0x表示16进制\nint类型（long long类型同理）\n1 2 memset(arr, 0x3f, sizeof arr);//每个元素赋值成0x3f3f3f3f，即1061109567，通常看成int的无穷大 memset(arr, 0x7f, sizeof arr);//每个元素赋值成0x7f7f7f7f，即2139062143，通常也看成int的无穷大，但没有上一条常用，原因在于2139062143过大，再做加法时容易爆int double类型（float类型同理） 1 2 3 memset(arr, 0, sizeof arr);//每个元素都为0 memset(arr, 0x3f, sizeof arr); //每个元素都为0.0047,由于没有用处，固没用 memset(arr, 0x7f, sizeof arr); //浮点数的正无穷大，这个有用 那么怎么对一维数组指定个数进行memset呢，如下 1 memset(arr, val, sizeof(type) * num);//type为数组的类型，num为初始化的个数 2.2 strlen函数（常用） 此函数是计算char型字符串的长度，其原理是从指定的头开始遍历char字符串，知道碰到\u0026rsquo;\\0\u0026rsquo;字符停止，固其时间复杂度为$O(n)$，所以要把他放到for循环体的判断函数内，不然你怎么tle的都不知道\n常见形式(第三行)，传入char*字符串的头指针\n1 2 3 char str[100]; scanf(\u0026#34;%s\u0026#34;, str); int len = strlen(str); // 传入需要知道长度的字符串的头指针 2.3 memcpy（不常用） 此函数用于复制数组a给数组b，即b = a\n常见形式，第一个参数是目标数组，第二个参数是被复制的数组，第三个参数形式和memset相同，即从数组a中拷贝（sizeof a)个字节到数组b\n1 2 3 int a[100], b[100]; // 相当于b = a memcpy(b, a, sizeof a); 2.4 strcmp（不常用） 此函数用于对比两个字符串的字典序大小，具体看代码\n常见形式，传入两个需要比较的字符串头指针\n1 2 3 4 5 char a[10] = \u0026#34;abc\u0026#34;, b[10] = \u0026#34;abd\u0026#34;; int k = strcmp(a, b); // 传入需要比较的两个字符串的头指针 // 若 a \u0026gt; b，则 k \u0026gt; 0 // 若a == b，则 k = 0 // 若 a \u0026lt; b，则 k \u0026lt; 0 2.5 strcpy（不常用） 此函数用于拷贝字符串的，功能和memcpy差不多\n常见形式，第一个参数是被写入的字符串头指针，第二个参数是读的字符串头指针\n1 2 3 char a[10] = \u0026#34;aaaaaa\u0026#34;; char b[10] = \u0026#34;bbbbbb\u0026#34;; strcpy(b, a); // 传入两个需要操作的字符串头指针，相当于b = a 2.6 strcat（不常用） 此函数用于拼接两个字符串\n常见形式，第一个参数是需要写入的字符串头指针，第二个是读的字符串头指针\n1 2 3 4 5 6 char a[10] = \u0026#34;aaa\u0026#34;; char b[10] = \u0026#34;bbb\u0026#34;; strcat(b, a); //传入需要操作的两个字符串的头指针， 相当于b += a puts(b); //输出 bbbaaa strcat(b, \u0026amp;a[2]); //相当于b += \u0026amp;a[2] puts(b); //输出 bbbaaaa 2.7 strchr（不常用） 此函数用于查找字符串中某字符第一次出现的位置，返回查找到的字符串指针，若找不到返回NULL\n常见形式，第一个参数是字符串头指针，第二个参数是需要查找的字符\n1 2 3 char a[10] = \u0026#34;abcdegf\u0026#34;; char *b = strchr(a, \u0026#39;c\u0026#39;); // 第一个传入的参数是需要查找的字符串指针（开始指针便可以的） puts(b); //输出 cdegf 3. cmath头文件 3.1 sqrt（常用） 计算正实数的算术平方根\ndouble sqrt(double x)\n传参浮点数，返回值也是浮点数\n常见形式\n1 2 3 double x = 2;// double y = sqrt(x); cout \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; // 输出1.41421 3.2 pow（常用） double pow(double a, double b)\n返回$a^b$的浮点数\n常见形式\n1 2 3 double a = 2, b = 0.5; double res = pow(a, b); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl;// 输出1.41421 3.3 acos（不常用） double acos(double a)\n返回$arccos(a)$的浮点数值\n当然类似的函数还有asin, atan, sin, cos, tan……\n常见用法，获取$π$\n1 2 const double PI = acos(-1); cout \u0026lt;\u0026lt; PI \u0026lt;\u0026lt; endl; // 输出3.14159 3.4 ceil、floor、round（常用） double ceil(double x) 返回x的向上取整的值\ndouble floor(double x) 返回x的向下取整的值\ndouble round(double x) 返回x四舍五入的值\n例如\n1 2 3 4 double x = 1.65; cout \u0026lt;\u0026lt; ceil(x) \u0026lt;\u0026lt; endl; // 2 cout \u0026lt;\u0026lt; floor(x) \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; round(x) \u0026lt;\u0026lt; endl; // 2 3.5 log、log2、log10（不常用） double log(double x) 返回$log_e{x}$的值\ndouble log2(double x) 返回$log_2{x}$的值\ndouble log10(double x) 返回$log_{10}{x}$的值\n例如\n1 2 3 cout \u0026lt;\u0026lt; log(10) \u0026lt;\u0026lt; endl; // 输出2.30259 cout \u0026lt;\u0026lt; log2(4) \u0026lt;\u0026lt; endl; // 输出2 cout \u0026lt;\u0026lt; log10(1000) \u0026lt;\u0026lt; endl;//输出3 4. 其它 4.1 abs（常用）与fabs（不常用） 由于本人不知道这两个函数到底是来自哪个头文件只能放到其他类型了\n两个函数都是对一个数取绝对值\n经过自己的测试，两个函数的区别不大，貌似两个都支持整数和浮点数，但听说后者（fabs）是专门对付double的\n传入需要取绝对值的参数\n下面用abs做为例子，fabs同理\n1 2 int x = -5; cout \u0026lt; abs(x) \u0026lt;\u0026lt; endl; //输出5 4.2 isdigit（不常用） 头文件#include \u0026lt;cctype\u0026gt;\nint isdigit(int x)\n检查传入的ASCII码对应的字符是否是十进制数字字符\n传入一个ASCII\n常见形式\n1 2 3 4 5 6 7 char a = \u0026#39;9\u0026#39;, b = \u0026#39;a\u0026#39;; if (isdigit(a)) cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt; endl; // 输出YES if (isdigit(c)) cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt; endl; //输出NO 与之类似的还有isalnum、islower、isupper，分别检查是否是字母数字、是否是小写字母、是否是大写字母 4.3 atoi（不常用） 传入char*字符串，将其转换成int类型，注意他的机制是从做到右扫描，直到字符串结尾或者遇到非数字字符 头文件#include \u0026lt;cstdlib\u0026gt; 与其类似的还有atol, atoll, atof等,返回值分别为long， long long, float 1 2 char s[] = \u0026#34;123\u0026#34;; printf(\u0026#34;%d\\n\u0026#34;, atoi(s)); // 123 4.4 tolower、toupper（不常用） 头文件 #include\u0026lt;cctype\u0026gt;\nint tolower(int c)\nint toupper(int c)\n两者都是将字母字符转化为大小写，前者是小写，后者是大写，注意：tolower当遇到小写字母时，则不变，toupper遇到大写不变\n常见形式，以tolower为例\n1 2 3 4 5 char a[7] = \u0026#34;AbcDEF\u0026#34;; for (int i = 0; i \u0026lt; 6; ++i) { a[i] = tolower(a[i]); } cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 输出 abcdef 4.5 assert(不太常用) 头文件 #include \u0026lt;cassert\u0026gt;\n一个断言语句，貌似不是函数，而是一个宏，用来调试的利器\n传入一个判断语句，若正确，程序照常运行，若错误程序停止运行\n一般在找bug或者提交时，可以在某些地方加上此函数，这样若是在函数此行报错，则说明我们判断的是错误的\n常见形式\n1 2 3 4 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); assert(n \u0026gt;= 0); // 若上一行正确则将会继续运行，否则程序停止 三、STL 1. 一些需要提前知道的知识 1.1 迭代器 迭代器是用来访问STL中的容器的工具，初学者把它理解成指针也可以 迭代器一般是c++11前用得比较多，但c++11更新了auto的用法后，迭代器逐渐没用了起来 这里提前利用后面要说到的set容器来演示迭代器的基础使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; a = {4, 2, 3, 1, 5}; for (set\u0026lt;int\u0026gt;::iterator it = a.begin(); it != a.end(); ++it) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } return 0; } /* 输出： 1 2 3 4 5 */ 1.2 auto 神器 利用它可以大大简化你遍历STL容器的代码量 他的机制是由编译器自行判断用户定义的变量类型，由于过于香，本文后续访问、遍历、赋值会大量使用到auto，而且不难理解 基础用法，可以将上述迭代器的代码改进一下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; a = {4, 2, 3, 1, 5}; for (auto it = a.begin(); it != a.end(); ++it) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } return 0; } /* 输出： 1 2 3 4 5 */ 当然对于c++11，对于容器的遍历还提供了一种更加简便的方式（前提是该容器封装了begin和end） 还是上面的set 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; a = {4, 2, 3, 1, 5}; for (auto x : a) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } } /* 输出： 1 2 3 4 5 */ 如果是c++17的话，就可以使用结构化绑定的功能 对于结构化绑定的赋值顺序，一般是结构体中变量的声明顺序 1 2 3 4 5 6 7 8 9 10 11 12 struct my_struct { // 自己定义一个结构体，当然class也行 int my_int; string my_string; double my_double; }; int main() { my_struct x; x.my_int = 8, x.my_string = \u0026#34;A\u0026#34;, x.my_double = 0.9; auto [a, b, c] = x; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; // 输出：8 A 0.9 return 0; } 这有什么用呢，这可有大用处，对于在pair和tuple或者map的使用场景中大有用处 就拿大家最为熟悉的pair做演示 1 2 3 4 5 6 7 8 int main() { pair\u0026lt;string, long long\u0026gt; p = make_pair(\u0026#34;haha\u0026#34;, 10); auto\u0026amp; [x, y] = p; // 可以加取地址符号对内部进行修改 cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; // 输出：haha 10 x = \u0026#34;okok\u0026#34;, y = 99; cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; // 输出：okok 99 return 0; } 1.3 Lambda函数 前言：Lambda即匿名函数，对于匿名函数可能玩python比较熟悉，当然c++也有自己的一套Lambda玩法\n一般形式：\n1 [] () -\u0026gt; return_type {} 常见用处：最常见是用在sort的函数内（sort用法详见下文algorithm），对sort进行制定如何排序 1 2 3 4 int arr[5] = {3, 4, 2, 1, 7}; sort(arr, arr + 5, [] (int a, int b) { return a \u0026gt; b; //从大到小排序 }); 下面介绍lambda的基础（其实会上面的就够了）\n直接看先代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int a = 0, b = 1, c = 2, d = 3, e = 4; auto func = [\u0026amp;, a, c](int x, int \u0026amp;y)-\u0026gt;int { b = 5, x = 6, y = 7; return a + b + c + x + y; }; puts(\u0026#34;函数运行前：\u0026#34;); printf(\u0026#34;a = %d\\nb = %d\\nc = %d\\nd = %d\\ne = %d\\n\u0026#34;, a, b, c, d, e); printf(\u0026#34;func(d, e) = %d\\n\u0026#34;, func(d, e)); puts(\u0026#34;运行后：\u0026#34;); printf(\u0026#34;a = %d\\nb = %d\\nc = %d\\nd = %d\\ne = %d\\n\u0026#34;, a, b, c, d, e); return 0; } /* 输出： 函数运行前： a = 0 b = 1 c = 2 d = 3 e = 4 func(d, e) = 20 运行后： a = 0 b = 5 c = 2 d = 3 e = 7 */ 下面解释每个符号的含义\n[] 是捕捉列表，用于捕捉父级的变量 [var]表示值传递方式捕捉变量var； [=]表示值传递方式捕捉所有父作用域的变量（包括this） [\u0026amp;var]表示引用传递捕捉变量var [\u0026amp;]表示引用传递方式捕捉所有父作用域的变量（包括this） [this]表示值传递方式捕捉当前的this指针 [=,\u0026amp;a,\u0026amp;b]表示以引用传递的方式捕捉变量a和b，以值传递方式捕捉其它所有变量 [\u0026amp;,a,this]表示以值传递的方式捕捉变量a和this，引用传递方式捕捉其它所有变量 () 是传参列表，传入的参数规则和普通函数一样，值得注意的是如果什么都不传则可以省略这个传参列表 -\u0026gt;return-type 是函数的返回类型，如果无返回或让编译器自己判断则可以省略 {} 是函数体，没什么好说的 演示一个lambda常用的写递归的方式，将lambda本身当成值传参\n1 2 3 4 auto dfs = [\u0026amp;](auto\u0026amp;\u0026amp; self, int x) -\u0026gt; int{ // 一定要写返回值 return x \u0026gt; 0 ? x + self(self, x - 1) : 0; }; printf(\u0026#34;%d\\n\u0026#34;, dfs(dfs, 10));// 输出:55 2. vector 最常用的STl容器之一，对于新手你可以把他理解成一个数组，他能使用下标访问，能在尾部$O(1)$时间插入元素，固他是动态开辟空间的 头文件为#include \u0026lt;vector\u0026gt; 2.1 基础声明方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main() { // 直接声明元素类型为int的vector vector\u0026lt;int\u0026gt; v1; // 利用构造函数声明一个长度为5的vector， vector\u0026lt;int\u0026gt; v2(5); // 利用构造函数声明一个长度为5，所有值为1的vector vector\u0026lt;int\u0026gt; v3(5, 1); // 另一种声明方式 vector\u0026lt;int\u0026gt; v4 = {4, 5, 6, 7}; // 也可以这样 int b[4] = {1, 2, 3, 4}; vector\u0026lt;int\u0026gt; v5(b + 1, b + 4); // v5元素为 2， 3， 4 return 0; } 2.2 访问方式/遍历方式 最常用的访问方式就是下标访问 1 2 3 4 5 int main() { vector\u0026lt;int\u0026gt; v = {4, 5, 6, 7}; cout \u0026lt;\u0026lt; v[2] \u0026lt;\u0026lt; endl; // 输出6 return 0; } 遍历方式一般可以直接for 1 2 3 4 5 6 7 8 int main() { vector\u0026lt;int\u0026gt; v = {4, 5, 6, 7}; for(int i = 0; i \u0026lt; 4; ++i) { cout \u0026lt;\u0026lt; v[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } // 输出为 4 5 6 7 return 0; } 当然也可以使用迭代器，这里推荐使用c++11提供的遍历方式，缺点就是没办法只得当前元素是第几个元素，但是方便 1 2 3 4 5 6 7 8 int main() { vector\u0026lt;int\u0026gt; v = {4, 5, 6, 7}; for (int x : v) { // 这里将 int 换成 auto是一样的，只是auto可以自动识别变量类型罢了 cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } // 输出为 4 5 6 7 return 0; } 2.3 push_back和pop_back函数（常用） 分别用于在vector的尾部插入元素和删除与元素的函数，基本用法如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main() { vector\u0026lt;int\u0026gt; v = {4, 5, 6, 7}; v.push_back(3); // 往尾部插入3 v.push_back(2); // 往尾部插入2 for (int x : v) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; // 输出：4 5 6 7 3 2 cout \u0026lt;\u0026lt; endl; v.pop_back(); // 删除最后一个元素 for (int x : v) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; // 输出 4 5 6 7 3 return 0; } 2.4 size函数（常用） 返回当前vector的大小（长度） O(1) 1 2 3 4 5 6 7 8 9 10 11 int main() { vector\u0026lt;int\u0026gt; v = {4, 5, 6, 7}; cout \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; // 输出4 v.push_back(3); cout \u0026lt;\u0026lt; v.size(); // 输出5 return 0; } 2.5 clear函数（常用） 将vector清空，时间为$O(1)$ 1 2 3 4 5 6 7 8 9 10 11 int main() { vector\u0026lt;int\u0026gt; v = {4, 5, 6, 7}; cout \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; // 输出4 v.clear(); // 清空 cout \u0026lt;\u0026lt; v.size(); // 输出0 return 0; } 2.6 empty函数（不常用） 写法为v.empty()，若该vector为空则返回true，否则返回false 2.7 front和back函数（不常用） 分别返回vector头部和尾部元素的值 很多人不知道的是，其实他返回的是引用类型，这就意味着我们是可以通过该函数修改值的 1 2 3 4 5 6 7 8 vector\u0026lt;int\u0026gt; v = {4, 5, 6, 7}; cout \u0026lt;\u0026lt; v.front() \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; v.back() \u0026lt;\u0026lt; endl; // 输出为4 7 v.front() = 1; // 将头部的元素修改为1 v.back() = 2; // 将尾部的元素修改为2 cout \u0026lt;\u0026lt; v.front() \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; v.back() \u0026lt;\u0026lt; endl; // 输出为1 2 2.8 erase函数（不常用） 删除vector内部的元素\n传入需要删除的起始指针和结束指针的下一个位置\n最坏时间复杂度$O(n)$，因为他的原理就是删除后将后面的元素往前移动\n1 2 3 4 5 vector\u0026lt;int\u0026gt; v = {0, 1, 2, 3, 4, 5, 6}; v.erase(v.begin() + 1, v.begin() + 4); // 删除[1, 4)范围的下标，主要左闭右开即[1, 3] for (int x : v) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; // 输出为：0 4 5 6 2.9 insert函数（不常用） 插入元素，传参方式一般有三种 时间复杂度和erase同理，$O(n)$ 1 2 3 4 5 6 7 8 9 10 11 vector\u0026lt;int\u0026gt; v = {0, 1, 2, 3, 4}; int b[4] = {9, 8, 7, 6}; v.insert(v.begin() + 1, 5); // 往第2个元素后面后插入一个5 // 此时v为 {0, 5, 1, 2, 3, 4} v.insert(v.begin() + 2, 2, 6); // 往第3个元素后面插入两个6 // 此时v为{0, 5, 6, 6, 1, 2, 3, 4} v.insert(v.begin() + 3, b + 1, b + 3); // 往第4个元素后面插入数组b中下标从1~2的数 // 此时v为 {0, 5, 6, 6, 8, 7, 1, 2, 3, 4} 2.10 resize函数（不太常用） 传入两个参数，第一个传入的是重新设置的长度len，第二个传入的参数是vector变长后分配的值value 重新设置vector的长度为len 当原本长度大于等于len时，直接删除掉多余的部分，其余保持不变，尽管传入了value值 当原本长度小于len时，以传入的value作为多的部分为填充，其余原本的值保持不变 详见代码 1 2 3 4 5 vector\u0026lt;int\u0026gt; v = {1, 2, 3, 4, 5, 6, 7, 8}; v.resize(5, 1); // 此时 v = {1, 2, 3, 4, 5} v.resize(10, 2); //此时 v = {1, 2, 3, 4, 5, 2, 2, 2, 2, 2} 2.11 swap函数（不常用） 交换两个vector 印象中是直接交换两个指针，固时间复杂度是$O(1)$ 1 2 3 4 vector\u0026lt;int\u0026gt; a = {0, 1, 2, 3, 4}; vector\u0026lt;int\u0026gt; b = {5, 6, 7}; a.swap(b); // 交换 a 和 b 2.12 各种比较运算符（不常用） vector内部重写了\u0026lt; \u0026lt;= \u0026gt; \u0026gt;= == !=六个比较运算符 用来比较两个vector的关系 其判断机制有点类似于两个字符串大小的判断，但对于每个元素的比较是真正意义上的值的比较（是什么类型元素就怎么比较） 2.13 begin函数和end函数（不常用） begin返回vector起始的迭代器，end是vector最后一个元素的下一个位置的迭代器 注意：这两个函数虽然不常用，但在排序的时候非常常用 1 2 3 4 5 vector\u0026lt;int\u0026gt; v = {4, 5, 6, 7}; cout \u0026lt;\u0026lt; *v.begin() \u0026lt;\u0026lt; endl; // 输出4 cout \u0026lt;\u0026lt; *(v.end() - 1) \u0026lt;\u0026lt; endl; // 输出 7 3. string 最常用的stl容器之一，新手可以这么理解：从形式上看是一个字符串，从功能上看可以把它当做vector\u0026lt;char\u0026gt;，当然他比vector多了+和+=的操作，用于合并string，同时支持用cin输入cout输出 头文件：#include \u0026lt;stirng\u0026gt; 需要值得记住的是，string内子串的切割一般第一个参数是下标其实位置，第二个参数是长度，详情参考substr、replace等函数 3.1 基础声明方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 方式一 string s1; // 方式二 string s2 = \u0026#34;123\u0026#34;; // 方式三，初始化为由3个c组成的字符串 string s3(3, \u0026#39;c\u0026#39;); // 方式四 相当于方式二 string s4(\u0026#34;123\u0026#34;); // 方式五，和方式四是等价的 char chr[] = \u0026#34;abc\u0026#34;; string s5(chr); 3.2 访问遍历方式 和vector几乎一样 1 2 3 4 5 6 7 8 9 10 string s = \u0026#34;abcdef\u0026#34;; cout \u0026lt;\u0026lt; s[3] \u0026lt;\u0026lt; endl; // 输出：d // 遍历 for (int i = 0; i \u0026lt; 6; ++i) cout \u0026lt;\u0026lt; s[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl; // c++11方式 for (char c : s) cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#39; \u0026#39;; 3.3 和vector几乎用法一样的函数 - **push_back**和**pop_back**函数（常用） size函数，注意string还另外封装了length函数，其效果和用法和size一样 clear函数（常用） empty函数（常用） begin和end函数 各种比较运算符，需要注意的是string还多了+和+=的操作（常用） swap函数（不常用） resize函数（不常用） front和back函数（不常用） 3.4 关于string需要知道的一个常量string::npos stirng::npos是一个常量，由于stl容器中下标和容器大小的返回值一般都是size_t（一个无符型整数），固在string的一些函数返回值为了表示无或者是不存在等含义，则返回此常量string::npos，其值可以理解为-1，但由于它是无符型，固真正意义表示的是无穷大 3.5 find函数（常用） 用于从前往后查找子串或者字符串第一次出现的下标位置，若找到则返回stirng::npos，与其相对的从后往前找的是rfind函数，但个人觉得除了方便几乎没什么用，大不了自己写个KMP 时间复杂度$O(n)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 string s = \u0026#34;abcdef\u0026#34;; // 从0开始找第一个出现的字符\u0026#39;c\u0026#39; cout \u0026lt;\u0026lt; s.find(\u0026#39;c\u0026#39;) \u0026lt;\u0026lt; endl; // 输出为 2 // 从下标3开始找第一个字符\u0026#39;c\u0026#39; // 此时，由于查找不到，如返回的是stirng::npos // 这个输出值是size_t的最大值，对不同系统输出不一 cout \u0026lt;\u0026lt; s.find(\u0026#39;c\u0026#39;, 3) \u0026lt;\u0026lt; endl; // 但在判断是否找到可以用这种方式 if (s.find(\u0026#39;3\u0026#39;, 3) == string::npos) { cout \u0026lt;\u0026lt; \u0026#34;not find!!!\u0026#34; \u0026lt;\u0026lt; endl; } // 从下标0开始找字符串\u0026#34;bc\u0026#34; cout \u0026lt;\u0026lt; s.find(\u0026#34;bc\u0026#34;) \u0026lt;\u0026lt; endl; // 输出为 1 // 从下标1开始找 cout \u0026lt;\u0026lt; s.find(\u0026#34;ef\u0026#34;, 1) \u0026lt;\u0026lt; endl; // 输出为 4 3.6 substr函数（常用） 用于截取string的一个子串，返回值为string 时间复杂度$O(n)$，n为子串的长度 用法详情看代码片段， 1 2 3 4 5 6 7 8 9 10 11 string s = \u0026#34;abcdef\u0026#34;; // 截取 s 串中下标从2开始以后的子串 cout \u0026lt;\u0026lt; s.substr(2) \u0026lt;\u0026lt; endl; // cdef // 截取 s 串中下标从2开始长度为2的子串 cout \u0026lt;\u0026lt; s.substr(2, 2) \u0026lt;\u0026lt; endl; // cd // 截取 s 串中下标从3开始长度为无穷的子串，下面两句话是等价的 cout \u0026lt;\u0026lt; s.substr(3, -1) \u0026lt;\u0026lt; endl; // def cout \u0026lt;\u0026lt; s.substr(3, string::npos) \u0026lt;\u0026lt; endl; // def 3.7 replace函数（常用） 用于将字符串中的指定范围的子串来替换指定的子串，并返回替换后的结果 时间复杂度$O(1)$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 string s = \u0026#34;abcdef\u0026#34;; // 将s串中的下标从3开始长度为2的子串替换成\u0026#34;123456\u0026#34; s.replace(3, 2, \u0026#34;123456\u0026#34;); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; // abc123456f s = \u0026#34;abcdef\u0026#34;; // 将 s 串中从下标3开始长度为2的子串替换成 \u0026#34;123456\u0026#34; 的下标从2开始长度为3的子串 s.replace(3, 2, \u0026#34;123456\u0026#34;, 2, 3); // abc345f cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; s = \u0026#34;abcdef\u0026#34;; // 将 s 串中下标从3开始长度为1的子串替换成 5个 ’#‘ s.replace(3, 1, 5, \u0026#39;#\u0026#39;); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; // abc#####ef 3.8 append函数（不常用） 一个用来在string串尾部添加字符串的函数，并返回最终的字符串 个人感觉有+=这个函数就没必要了，加上两者复杂度一样 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 string s = \u0026#34;abcdef\u0026#34;; // 在 s 串尾部插入 \u0026#34;123\u0026#34; s.append(\u0026#34;123\u0026#34;); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; // abcdef123 string x = \u0026#34;123456\u0026#34;; s = \u0026#34;abcdef\u0026#34;; // 此方法和上一种写法是等价的 s.append(x); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; // abcdef123456 // 在上一种方法的基础上加个范围， 即 取 x 串下标从3开始长度为2的子串添加到 s 尾部 s = \u0026#34;abcdef\u0026#34;; s.append(x, 3, 2); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; // abcdef45 3.9 compare函数（不常用） 用于比较两个字符串的大小关系，其返回值和strcmp差不多，大于0则说明前者大于后者，以此类推 个人感觉在敲代码时有封装好的比较运算符就够了 他的传参和replace函数的一种传参很像 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 string a = \u0026#34;abcdef\u0026#34;; string b = \u0026#34;abdddd\u0026#34;; // 直接对比 if (a.compare(b) \u0026lt; 0) { cout \u0026lt;\u0026lt; \u0026#34;a \u0026lt; b\u0026#34; \u0026lt;\u0026lt; endl; // a \u0026lt; b } else { cout \u0026lt;\u0026lt; \u0026#34;a \u0026gt;= b\u0026#34; \u0026lt;\u0026lt; endl; } // 添加范围，注意传参意义第一数字是开始下标，第二个是长度 if (a.compare(2, 1, b, 3, 2) \u0026lt; 0) { cout \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;c\\\u0026#34; \u0026lt; \\\u0026#34;dd\\\u0026#34;\u0026#34; \u0026lt;\u0026lt; endl; // \u0026#34;c\u0026#34; \u0026lt; \u0026#34;dd\u0026#34; } else { cout \u0026lt;\u0026lt; \u0026#34;\\\u0026#34;c\\\u0026#34; \u0026gt;= \\\u0026#34;dd\\\u0026#34;\u0026#34; \u0026lt;\u0026lt; endl; } 3.10 insert函数（不常用） 如果说append函数只能在尾部插入，则此函数能在指定位置插入，并返回结果string的值 复杂度$O(n)$ 1 2 3 4 5 6 7 8 9 10 11 string a = \u0026#34;abcdef\u0026#34;; string b = \u0026#34;123456\u0026#34;; // 从 a 串中下标2开始后面插入b串 a.insert(2, b); cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // ab123456cdef a = \u0026#34;abcdef\u0026#34;; // 从 a 串中下标2开始后面插入b串中下标从3开始长度为2的子串 a.insert(2, b, 3, 2); cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // ab45cdef 3.11 erase函数（不常用） 删除指定范围的子串，并返回结果string值 1 2 3 4 5 6 7 8 9 10 string a = \u0026#34;abcdef\u0026#34;; string b = \u0026#34;123456\u0026#34;; // 删除 a 串中下标从3开始以后 a.erase(3); cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // abc // 删除 b 串下标从4开始长度为1的子串 b.erase(4, 1); cout \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; //12346 3.12 c_str函数（不常用） 其作用就是将字符串转换成char*类型的字符串 3.13 关于string的其他骚操作 3.13.1 to_string函数（常用） 用于将整数类型转换成string类型 可传入的参数有int、long long、double等 注意此函数为c++11提供的函数 1 2 3 4 5 6 7 int a = 1; long long b = 2; double c = 3.4; string x = to_string(a); string y = to_string(b); string z = to_string(c); // 一般不用，比较精度不好控制 3.13.2 stoi函数（不常用） 有点类似atoi函数的功能，但此函数传入的是string参数，即将string 转换成int类型 返回类型为int类型 与其类似的还有stol、stof、stod、stoll、stold、stoull等，分别对应返回值为long、double、long long、long double、unsigned long long 1 2 string s = \u0026#34;123456\u0026#34;; cout \u0026lt;\u0026lt; stoi(s) \u0026lt;\u0026lt; endl; // 123456 3.13.3 整行读入string 一般我们整行读入string用的都是以下方式，值得注意的是他和cin的返回值一样，固可以处理不定组输入写进while判断内 1 2 3 4 5 string s; // 值得注意的是，如果此前有换行符需要用getchar吃掉 while (getline(cin, s)) { cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; // 实现一行一行地读入 } 3.13.4 sstream的使用 用于对string的流控制，缺点是速度慢，好处就是大模拟时可以帮你省很多事 具体功能直接看代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;string\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;sstream\u0026gt; // 需要导入此头文件 using namespace std; int main() { string str = \u0026#34;what are you doing now\u0026#34;, sub; stringstream ss1(str); // 将流初始化 while (ss1 \u0026gt;\u0026gt; sub) { // 想流一样读入到sub里面 cout \u0026lt;\u0026lt; sub \u0026lt;\u0026lt; endl; } /* 输出结果 what are you doing now */ str = \u0026#34;123 45.6\u0026#34;; stringstream ss2; ss2 \u0026lt;\u0026lt; str; // 像流一样读入到ss2 int x; double y; ss2 \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; // 像流一样读入到 x 和 y 里面 cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; y; // 123 45.6 return 0; } 4. stack STL中封装好的栈，也挺常用的 头文件#include \u0026lt;stack\u0026gt; 初始化的话直接声明stack\u0026lt;int\u0026gt; st便可 遍历方式：由于他的意义是栈，固只能访问栈顶元素 4.1 size函数（常用） 返回栈的大小，用法和vector里的size函数一样 4.2 push和pop函数（常用） push用于将元素压入栈中，pop则是弹出栈顶元素，注意返回值都是void 1 2 3 4 stack\u0026lt;int\u0026gt; st; st.push(1); // 将1压入栈中 st.push(2); // 将2压入栈中 st.pop(); // 弹出栈顶元素 4.3 top函数（常用） 返回栈顶元素的引用变量 1 2 3 4 5 6 stack\u0026lt;int\u0026gt; st; st.push(1); // 将1压入栈中 st.push(2); // 将2压入栈中 cout \u0026lt;\u0026lt; st.top() \u0026lt;\u0026lt; endl; // 2 st.top() = 3; cout \u0026lt;\u0026lt; st.top() \u0026lt;\u0026lt; endl; // 3 4.4 empty函数（常用） 判断栈是否为空，为空返回true，否则返回false 4.5 关于stack需要注意的事 stack中没有封装clear函数，固需要清空时可以考虑用pop函数暴力清空（一般都是声明为局部变量，用完就不要的） stack在pop时如果没有把握，需要提前先判断栈是否为空，否则如果栈为空，则会报错 5. queue STL中封装好的队列，也挺常用的 头文件#include \u0026lt;queue\u0026gt; 声明规则和stack一样直接声明便可 遍历规则也和stack差不多，由于是队列，只能从队头访问遍历，但很多人不知道的是，queue是可以访问队尾元素的，并且修改队尾元素 5.1 和栈相同用法的函数 push和pop函数，值得注意的是，这两个函数和stack的用法一样，但意义不同，queue的push是将元素压入队列尾部，pop是取出队尾元素 size函数 empty函数 5.2 front函数和back函数 这两个函数和vector中的是一样的，分别返回队头和队尾的引用元素 6. priority_queue 一个STL封装的优先队列，通常我们将它当做堆来使用，其默认为大顶堆 头文件#include \u0026lt;queue\u0026gt; 6.1 声明方式 一般直接声明就好了 1 priority_queue\u0026lt;int\u0026gt; heap; 但如果想要改变成小顶堆，则需要这样声明 1 2 priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt; \u0026gt; heap1; // 小顶堆 priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, less\u0026lt;int\u0026gt; \u0026gt; heap2; // 大顶堆，即默认情况 若是自己定义的结构体则需要重写小于符号 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 struct pii { int x; // 注意比的是谁的优先级小 bool operator\u0026lt; (const pii\u0026amp; j) const { // 两个const必须加 if (this-\u0026gt;x \u0026gt; j.x) { return true; // 只有当this的x比j的x要大时，this的优先级才比j的优先级要小，即x越大，优先级越小 } return false; } }; int main() { priority_queue\u0026lt;pii\u0026gt; heap; heap.push({.x = 1}); heap.push({.x = 2}); cout \u0026lt;\u0026lt; heap.top().x \u0026lt;\u0026lt; endl; // 1 return 0; } 6.2 遍历方式 只能从堆顶访问元素 6.3 size函数（常用） 用于返回堆中元素的个数 6.4 push和pop函数（常用） 分别用于插入元素和取出堆顶元素 6.5 top函数（常用） 返回堆顶元素的引用 6.6 empty函数（常用） 判断堆中是否为空 7. pair 一个将两个类型的数捆绑在一起 头文件#include \u0026lt;utility\u0026gt;或者#include \u0026lt;map\u0026gt; 对于新手准备两种容易理解的仿内部实现原理参考，通过代码理解pair到底是什么(注意由于名字重了，所以建议读者自己吧结构名、类名改了再运行) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 struct pair { int first; double second; // 排序的时候 bool operator\u0026lt; (const pair \u0026amp;j) const { if (this-\u0026gt;first == j.first) { // 如果两者的first一样，则 return this-\u0026gt;second \u0026lt; j.second; // 对比second的大小 } return this-\u0026gt;first \u0026lt; j.first; // 不一样则对比first的大小 // 总结就是先如果first不一样，则对比first，否则对比second的大小 } }p; // 此时的p相当于是 pair\u0026lt;int, double\u0026gt; p的声明方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template\u0026lt;class T1, class T2\u0026gt; class pair { public: T1 first; T2 second; // 排序的时候 private: bool operator\u0026lt; (const pair \u0026amp;j) const { if (this-\u0026gt;first == j.first) { // 如果两者的first一样，则 return this-\u0026gt;second \u0026lt; j.second; // 对比second的大小 } return this-\u0026gt;first \u0026lt; j.first; // 不一样则对比first的大小 // 总结就是先如果first不一样，则对比first，否则对比second的大小 } }; 7.1 声明 直接声明就好了 例如，我想将int和string捆绑在一起 1 2 pair\u0026lt;int, string\u0026gt; p1; pair\u0026lt;int, string\u0026gt; p2 = {3, \u0026#34;haha\u0026#34;};// 好像有些编译版本用不了这样，具体多少忘记了 7.2 遍历方式 直接向类一样的点运算符访问就好了 例如我想知道first的值p.first就好 也可以看看前面auto中介绍的遍历方式 7.3 make_pair函数 此函数是用来给pair赋值的 1 2 pair\u0026lt;int, string\u0026gt; p; p = make_pair(3, \u0026#34;123\u0026#34;); 8. set 一个STL封装的集合的容器，其机制正如我说的集合一样，他保证了内部装元素是唯一的，即便你重复插入了 其在你插入时自动排序了，固插入的时间复杂度为$O(logn)$,你可以把他想象成封装好的平衡树（内部实现原理好像就是红黑树）,注意到，如果你要插入自己定义的结构体或者类，需要重写小于号，但一般遇到这种题可能真要你自己手写平衡树了 头文件#include \u0026lt;set\u0026gt; 8.1 声明方式 一般声明是直接声明的 也可以用数组形式初始化 1 2 3 4 5 6 7 8 9 // 方式一 set\u0026lt;int\u0026gt; ass1; // 方式二 set\u0026lt;int\u0026gt; ass2 = {3, 4, 2, 3}; // 方式三 int arr[] = {3, 4, 3, 2}; set\u0026lt;int\u0026gt; ass3(arr, arr + 4); 8.2 遍历方式 set是不能用下标遍历的，本人一般在可以用c++11的情况下是用以下的遍历方式的 1 2 3 4 5 set\u0026lt;int\u0026gt; ass = {3, 4, 3, 2, 5}; for (int x : ass) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } // 输出为： 2 3 4 5 8.3 insert函数（常用） 用于插入元素的函数，用法很简单 其返回值为一个pair类型，具体是pair\u0026lt;set\u0026lt;T\u0026gt;::iterator, bool\u0026gt; $O(logn)$ 1 2 3 4 5 set\u0026lt;int\u0026gt; ass = {3, 4, 3, 2, 5}; ass.insert(1); // 插入一个 1 if (ass.insert(3).second == false) { cout \u0026lt;\u0026lt; \u0026#34;插入失败，set里面有这个元素了\u0026#34; \u0026lt;\u0026lt; endl; // 这句话会被执行 } 8.4 erase函数（常用） 用于删除元素 若指定值进行删除，则返回值为size_t，一般删除成功返回1，失败返回0 若指定迭代器删除，则返回迭代器的下一个迭代器 也可以传入迭代器 $O(logn)$ 1 2 3 4 set\u0026lt;int\u0026gt; ass = {3, 4, 3, 2, 5, 1}; ass.erase(3); ass.erase(ass.begin()); // 删除指点迭代器的元素 ass.erasse(ass.begin(), ass.begin() + 2); // 删除连个迭代器范围内的数， 几乎用不上，不多解释 8.5 size函数（常用） 返回容器内部元素的个数，注意由于set内部保证元素唯一，已有的相同元素无论插入几次都是不会改变size的 8.6 empty函数（常用） 判断容器是否为空 8.7 count函数（常用） 返回某个元素在set内的个数 由于元素保证唯一，所以我们可以把它理解成判断某个元素是否存在（注在multiset中便是返回个数） 1 2 3 set\u0026lt;int\u0026gt; ass = {3, 4, 3, 2, 5}; cout \u0026lt;\u0026lt; ass.count(3) \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; ass.count(9) \u0026lt;\u0026lt; endl; // 0 8.8 clear函数（常用） 用于清空set容器，不用传参，时间复杂度$O(n)$吧 8.9 lower_bound函数（常用） $O(logn)$的时间复杂度内第一个大于等于指定元素的迭代器，找不到返回end() 1 2 3 4 5 6 set\u0026lt;int\u0026gt; ass = {8, 6, 4, 2}; // 2 4 6 8 cout \u0026lt;\u0026lt; *ass.lower_bound(3) \u0026lt;\u0026lt; endl; // 4 cout \u0026lt;\u0026lt; *ass.lower_bound(6) \u0026lt;\u0026lt; endl; // 6 if (ass.lower_bound(9) == ass.end()) { cout \u0026lt;\u0026lt; \u0026#34;not found\u0026#34; \u0026lt;\u0026lt; endl; // 被执行 } 8.10 upper_bound函数（常用） $O(logn)$的时间复杂度内第一个大于指定元素的迭代器，找不到返回end() 1 2 3 4 5 6 set\u0026lt;int\u0026gt; ass = {8, 6, 4, 2}; // 2 4 6 8 cout \u0026lt;\u0026lt; *ass.upper_bound(3) \u0026lt;\u0026lt; endl; // 4 cout \u0026lt;\u0026lt; *ass.upper_bound(6) \u0026lt;\u0026lt; endl; // 8 if (ass.upper_bound(9) == ass.end()) { cout \u0026lt;\u0026lt; \u0026#34;not found\u0026#34; \u0026lt;\u0026lt; endl; // 被执行 } 8.11 find函数（不太常用） 返回查找元素的迭代器，找不到返回end()，时间复杂度应该是$O(log(n))$ 9. unordered_set 如果说你只是希望存放元素，而不希望他帮你自动排序，则可以考虑用这个容器 由于少了插入后排序的功能，固他的速度比set快不少 set内部原理是红黑树，unordered_set的内部原理是hash 头文件#include \u0026lt;unordered_set\u0026gt; 除了几个lowwer_bound函数和upper_bound函数不提供外，其他几乎和set一样 10. multiset 如果说set是不能重复元素的话，那这个multiset就是可以重复了，常用的提供的接口和set是一样的 头文件#include \u0026lt;set\u0026gt; 需要注意的是erase函数，如果传入的参数是常量c，则函数会删除所有为c的元素，但如果传入的是迭代器，则只会删除传入的迭代器，看例子 1 2 3 4 5 6 7 8 9 10 11 12 multiset\u0026lt;int\u0026gt; st; st.insert(3); st.insert(3); cout \u0026lt;\u0026lt; st.count(3) \u0026lt;\u0026lt; endl;; // 2 // 如果我们这样：st.erase(3),则会将所有3都删除 // 固我们只想删除一个3时，可以这样做 st.erase(st.find(3)); cout \u0026lt;\u0026lt; st.count(3) \u0026lt;\u0026lt; endl;; // 1 11. map map是STL中提供的关联容器 如果说我们平时数组遍历是 arr[int] = T的话（[]内是整数），map就可做到map[T1] = T2的形式([]内的自己指定的数据类型，T2也是) 其内部也是用红黑树来实现的，固他会根据T1（key）的值来排序的，固插入查找修改的时间复杂度都是$O(logn)$ 头文件#include \u0026lt;map\u0026gt; 11.1 声明方式 一般我们在做题中，声明后是不会手动初始化的 1 2 3 4 5 6 7 8 9 // 方式一 map\u0026lt;double, long long\u0026gt; mp1; // 方式二，用得少 map\u0026lt;string, int\u0026gt; mp2 = { {\u0026#34;123\u0026#34;, 4}, {\u0026#34;abc\u0026#34;, 5}, {\u0026#34;ha\u0026#34;, 99999999}, {\u0026#34;##\u0026#34;, -100} }; 11.2 插入方式 如果传统的插入方式我们是使用insert函数进行插入的 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 map\u0026lt;string, int\u0026gt; mp = { {\u0026#34;123\u0026#34;, 4}, {\u0026#34;abc\u0026#34;, 5}, {\u0026#34;ha\u0026#34;, 99999999}, {\u0026#34;##\u0026#34;, -100} }; // 方式一 mp.insert({\u0026#34;222\u0026#34;, 5}); //方式二 mp.insert(pair\u0026lt;string, int\u0026gt;(\u0026#34;333\u0026#34;, 6)); // 方式三，和方式二等价 mp.insert(make_pair(\u0026#34;222\u0026#34;, 6)); // 但是插入失败了，因为之前有\u0026#34;222\u0026#34;的健值，固mp[\u0026#34;222\u0026#34;]依旧等于5 // 方式四,多个插入，几乎没用 mp.insert({ {\u0026#34;555\u0026#34;, 6}, {\u0026#34;666\u0026#34;, 7} }); 最常用的就是利用map的特性直接用[]运算符，如果key值存在，则修改其对应的value值，否则插入 1 2 3 4 5 6 7 8 map\u0026lt;string, int\u0026gt; mp = { {\u0026#34;123\u0026#34;, 4}, {\u0026#34;abc\u0026#34;, 5}, {\u0026#34;ha\u0026#34;, 99999999}, {\u0026#34;##\u0026#34;, -100} }; mp[\u0026#34;222\u0026#34;] = 5; // 由于原本没有\u0026#34;222\u0026#34;，固插入 mp[\u0026#34;222\u0026#34;] = 6; // 由于有了\u0026#34;222\u0026#34;，固改变其对应的值 11.3 遍历/访问方式 如果是单个遍历的的话我们直接利用[]符号便可 注意，使用这种遍历方式，如果访问量不存在的key值，则会返回其默认值好像，不同类型不同，固一般在不确定是否存在的情况下，先判断其是否存在，可以使用下面要讲的count函数判断，这里不再演示 1 2 3 4 5 6 7 map\u0026lt;string, int\u0026gt; mp = { {\u0026#34;123\u0026#34;, 4}, {\u0026#34;abc\u0026#34;, 5}, {\u0026#34;ha\u0026#34;, 99999999}, {\u0026#34;##\u0026#34;, -100} }; cout \u0026lt;\u0026lt; mp[\u0026#34;ha\u0026#34;] \u0026lt;\u0026lt; endl; // 99999999 如果是内部遍历，本人一般使用的是c++11的变量方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 map\u0026lt;string, int\u0026gt; mp = { {\u0026#34;123\u0026#34;, 4}, {\u0026#34;abc\u0026#34;, 5}, {\u0026#34;ha\u0026#34;, -99999999}, {\u0026#34;##\u0026#34;, 100} }; // 下面两种形式是等价的 for (pair\u0026lt;string, int\u0026gt; x : mp) { cout \u0026lt;\u0026lt; x.first \u0026lt;\u0026lt; \u0026#39;:\u0026#39; \u0026lt;\u0026lt; x.second \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;---------------\\n\u0026#34;; for (auto x : mp) { cout \u0026lt;\u0026lt; x.first \u0026lt;\u0026lt; \u0026#39;:\u0026#39; \u0026lt;\u0026lt; x.second \u0026lt;\u0026lt; endl; } /* 输出： ##:100 123:4 abc:5 ha:-99999999 --------------- ##:100 123:4 abc:5 ha:-99999999 */ 当然也可以用c++17的for的结构化绑定能力，更加方便 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 map\u0026lt;string, int\u0026gt; mp = { {\u0026#34;123\u0026#34;, 4}, {\u0026#34;abc\u0026#34;, 5}, {\u0026#34;ha\u0026#34;, -99999999}, {\u0026#34;##\u0026#34;, 100} }; for (auto [a, b] : mp) { cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } /* 输出： ##:100 123:4 abc:5 ha:-99999999 */ 11.4 erase函数（常用） 该函数传参一般有两种形式，一种是传入key值，一种是传入相应的迭代器，返回size_t类型，一般是删除成成功返回1，否则返回0 1 2 3 4 5 6 7 8 map\u0026lt;string, int\u0026gt; mp = { {\u0026#34;123\u0026#34;, 4}, {\u0026#34;abc\u0026#34;, 5}, {\u0026#34;ha\u0026#34;, -99999999}, {\u0026#34;##\u0026#34;, 100} }; mp.erase(\u0026#34;abc\u0026#34;); // 删除健值为\u0026#34;abc\u0026#34;的 mp.erase(mp.begin()); // 传入头部迭代器 11.5 count函数（常用） 作用和用法同set里的差不多 11.6 size函数（常用） 返回map的大小 11.7 empty函数（常用） 判断map是否为空 11.8 clear函数（常用） 用于清空map，时间复杂度好像是$O(n)$ 11.9 lower_bound函数（常用） 一般是传入健值查找第一个大于等于他的，返回查找到的迭代器，查找失败则返回end() 1 2 3 4 5 6 7 8 9 10 11 map\u0026lt;int, string\u0026gt; mp = { {1, \u0026#34;a\u0026#34;}, {-10, \u0026#34;b\u0026#34;}, {100, \u0026#34;c\u0026#34;}, {101, \u0026#34;d\u0026#34;}, {-4, \u0026#34;e\u0026#34;} }; cout \u0026lt;\u0026lt; mp.lower_bound(100)-\u0026gt;second \u0026lt;\u0026lt; endl; // 找到是mp[100] = c,固输出 c if (mp.lower_bound(9999) == mp.end()) { cout \u0026lt;\u0026lt; \u0026#34;not found\u0026#34; \u0026lt;\u0026lt; endl; // 被执行 } 11.10 upper_bound函数（不常用） 一般是传入健值查找第一个大于他的，返回查找到的迭代器，查找失败则返回end() 1 2 3 4 5 6 7 8 9 10 11 map\u0026lt;int, string\u0026gt; mp = { {1, \u0026#34;a\u0026#34;}, {-10, \u0026#34;b\u0026#34;}, {100, \u0026#34;c\u0026#34;}, {101, \u0026#34;d\u0026#34;}, {-4, \u0026#34;e\u0026#34;} }; cout \u0026lt;\u0026lt; mp.upper_bound(100)-\u0026gt;second \u0026lt;\u0026lt; endl; // 找到是mp[101] = d,固输出 d if (mp.upper_bound(9999) == mp.end()) { cout \u0026lt;\u0026lt; \u0026#34;not found\u0026#34; \u0026lt;\u0026lt; endl; // 被执行 } 11.11 find函数（不常用） 传入健值，返回查找到的迭代器，几乎没用 1 2 3 4 5 6 7 8 map\u0026lt;int, string\u0026gt; mp = { {1, \u0026#34;a\u0026#34;}, {-10, \u0026#34;b\u0026#34;}, {100, \u0026#34;c\u0026#34;}, {101, \u0026#34;d\u0026#34;}, {-4, \u0026#34;e\u0026#34;} }; cout \u0026lt;\u0026lt; mp.find(-4)-\u0026gt;second \u0026lt;\u0026lt; endl; // 等价于 mp[-4]，几乎没用 12. unordered_map 他和map的关系就像unordered_set和set的关系一样，挺有用的一个容器 头文件#incldue \u0026lt;unordered_map\u0026gt; 13. bitset 一个存放位的容器，挺常用的，一般用来优化一些算法，主要优化时间和空间，可以节省$1/64$常数好像\n比较神奇的是你开多少位，他就几乎占多少位\nc++还支持用cout对他输出\n这玩意好像是c++11的产品，忘记了\n13.1 声明方式 声明方式中需要注意的是\u0026lt;\u0026gt;里放的数字必须是常量，而且其表示的是你声明的长度 1 2 3 4 5 6 7 bitset\u0026lt;10\u0026gt; b1; //声明 10 位，每位都是0 bitset\u0026lt;10\u0026gt; b2(20); // 传入 unsigned long 类型值为20的参数，存放10位其二进制的值 cout \u0026lt;\u0026lt; b2 \u0026lt;\u0026lt; endl; // 0000010100 bitset\u0026lt;10\u0026gt; b3(\u0026#34;1010\u0026#34;); // 传入二进制字符串 cout \u0026lt;\u0026lt; b3 \u0026lt;\u0026lt; endl; // 0000001010 13.2 访问方式 一般我们直接把他当做bool数组看就好了，固我们可以用[]来访问其对应位数的值 13.3 运算 位运算支持的运算他都支持（自己探索吧） 13.4 其他函数 b.any() : b中是否存在置为1的二进制位 b.none() ：b中是否不存在为1的二进制位 b.count() : 返回1的个数 b.test(pos)：等价于b[pos] b.set()：将b中所有位都置1 b.set(pos)：等价于b[pos] = 1 b.reset()：将b中的所有位都置0 b.reset(pos)：等价于b[pos] = 0 b.filp()：等价于b = ~b b.filp(pos)：等价于b[pos] = !b[pos] b.to_string()：将其转换成string类型 b.to_ulong()：返回其二进制对应的unsigned long类型 b.to_ullong()：返回其二进制对应的unsigned long long类型 14. deque 一个双端队列，可以在头部和尾部插入和删除 和queue不同的是，为了区分头部尾部插入删除，头部插入删除用push_front和pop_front，尾部用push_back和pop_back 头文件#include \u0026lt;deque\u0026gt; 15. list 一个STL提供的双向链表容器 说实话不怎么常用，真考到一般我都是用链式前向星模拟的 学到这里的一般都能对STL中容器提供的函数其实差不多的 还有一点需要注意的是，它不支持随机访问，毕竟链表嘛 固这里直接贴常用函数的作用吧 15.1 声明方式 只写常用的声明方式 1 2 3 4 5 6 7 8 // 方式一 list\u0026lt;int\u0026gt; l1; // 方式二，声明长度为5，值为其默认，不同类型不同默认 list\u0026lt;int\u0026gt; l2(5); // 方式三， 声明长度为3，每个值都为2的 list\u0026lt;int\u0026gt; l3(3, 2); 15.2 遍历方式 直接c++11里for就好了 1 2 3 for(auto x : l) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; } 15.3 常用函数 push_front(val)：在头部插入 pop_front()：在头部删除 push_back(val)：尾部插入 pop_back()：尾部删除 insert(iterator, val)：在迭代器iterator前插入val insert(iterator, count, val)：在迭代器iterator前插入count个val front()、back()：返回头元素、尾元素的引用 begin()、end()：返回头部和尾部下一位置的迭代器 size()：大小 sort()：升序排序 clear()：清空 reverse()：翻转链表 merge(list2) ：用第二个有序的 list 合并一个有序 list splice(list.iterator, list2, list2.iterator_start, list2.iterator_end)：在本list的 iterator后插入list2的从 iterator_start 到 iterator_end， 后面两个可填可以不填，当填了iterator_start，可不填最后一个，时间复杂度O(1) erase(iterator)：删除iterator，返回删除前的下一个的迭代器 erase(iterator_start, iterator_end)：删除[iterator_start, iterator_end)范围内的元素，返回删除前的iterator_end 16. tuple 还记得pair吗？没错这个和pair差不多，pair只能放两个，而tuple元组则能放自定义个，来自c++11版本 但是这个不怎么常用 头文件#include \u0026lt;tuple\u0026gt; 16.1 声明 和pair差不多 1 2 3 tuple\u0026lt;int\u0026gt; t1 = {9}; // 绑定1个 tuple\u0026lt;int, double\u0026gt; t2; // 绑定2个 tuple\u0026lt;int, string, int\u0026gt; t3 = {1, \u0026#34;haha\u0026#34;, 10}; // 绑定3个 16.2 遍历方式 第一种是使用get\u0026lt;\u0026gt;()的方式遍历，注意：尖括号内部只能传入常量，圆括号内部传入需要读取的tuple元组名 1 2 3 4 5 tuple\u0026lt;int, string, double, char\u0026gt; t = {1, \u0026#34;okok\u0026#34;, 0.9, \u0026#39;y\u0026#39;}; cout \u0026lt;\u0026lt; get\u0026lt;0\u0026gt;(t) \u0026lt;\u0026lt; endl; // 输出：1 cout \u0026lt;\u0026lt; get\u0026lt;1\u0026gt;(t) \u0026lt;\u0026lt; endl; // 输出：okok cout \u0026lt;\u0026lt; get\u0026lt;2\u0026gt;(t) \u0026lt;\u0026lt; endl; // 输出：0.9 cout \u0026lt;\u0026lt; get\u0026lt;3\u0026gt;(t) \u0026lt;\u0026lt; endl; // 输出：y 当然auto也是可以的，之前也介绍过 1 2 3 tuple\u0026lt;int, string, double, char\u0026gt; t = {1, \u0026#34;okok\u0026#34;, 0.9, \u0026#39;y\u0026#39;}; auto [a, b, c, d] = t; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; // 输出：1 okok 0.9 y 16.3 make_tuple函数 不多说了，和make_pair差不多 1 tuple\u0026lt;int, string, double, char\u0026gt; t = make_tuple(1, \u0026#34;okok\u0026#34;, 0.9, \u0026#39;y\u0026#39;); 四、algorithm 本章介绍一些常用的函数，共同特点是都是在头文件#include \u0026lt;algorithm\u0026gt;中\n1. sort 最最最常用的算法函数之一 $O(nlogn)$ 其传参有两种 第一种：传入需要排序的数组的头的位置和尾的下一个位置指针 第二种：在第一种的前提下多一个比较函数 具体看代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 bool cmp(int\u0026amp; a, int\u0026amp; b) { return a \u0026gt; b; } int main() { int arr[10] = {8, 7, 4, 2, 1, 3, 9, 10, 5, 6}; // 形式一 sort(arr + 0, arr + 10); // 排序下标范围 [0, 10) // 形式二 sort(arr + 1, arr + 9, cmp); // 排序下标范围[1, 9), 用cmp函数比较，即降序排序 // 形式三 和形式二等价，只是用来lambda表达式罢了 sort(arr + 1, arr + 9, [](int a, int b) { return a \u0026gt; b; }); // 形式四 和形式二等价，只是用了c++封装好的函数 sort(arr + 1, arr + 9, greater\u0026lt;int\u0026gt;()); // 降序 // 对于vector需要传入迭代器 vector\u0026lt;int\u0026gt; vt(arr, arr + 10); // 赋值为arr的元素 // 和上面的其实差不多 sort(vt.begin(), vt.end()); // sort(vt.begin() + 1, vt.end() - 1, cmp); sort(vt.begin(), vt.end(), [](int a, int b) { return a \u0026gt; b; }); sort(vt.begin(), vt.end(), less\u0026lt;int\u0026gt;()); //升序 return 0; } abs 返回一个数的绝对值（int、long long、 double） 2. min和max 用于比较两个同类型（注意是同类型）的最小值和最大值 在c++11中还提供了多个数一起比较大小 1 2 cout \u0026lt;\u0026lt; max({100, 99, 10, 1000}) \u0026lt;\u0026lt; endl; // 1000 cout \u0026lt;\u0026lt; min({100, 99, 10, 1000}) \u0026lt;\u0026lt; endl; // 10 3. swap 用于交换两个同类型（注意是同类型）的变量 4. reserve 用来翻转指定范围的数组，传参规则和sort第一种传参形式一样 5. lower_bound 用于查找一个有序序列指定范围内的第一个大于等于给定值的位置，返回的是指针或者迭代器，即如果是数组，找不到返回范围的尾部，容器则返回end() 时间复杂度为$O(logn)$ 如果是自己定义的类型，记得重写小于符号（那还不如自己手写二分呢） 1 2 3 vector\u0026lt;int\u0026gt; vt = {0,2,4,6,8,10,12}; cout \u0026lt;\u0026lt; *lower_bound(vt.begin(), vt.end(), 3) \u0026lt;\u0026lt; endl; // 4 cout \u0026lt;\u0026lt; *lower_bound(vt.begin(), vt.end(), 4) \u0026lt;\u0026lt; endl; // 4 6. upper_bound 用于查找一个有序序列指定范围内的第一个大于给定值的位置，返回的是指针或者迭代器，即如果是数组，找不到返回范围的尾部，容器则返回end() 时间复杂度为$O(logn)$ 1 2 3 vector\u0026lt;int\u0026gt; vt = {0,2,4,6,8,10,12}; cout \u0026lt;\u0026lt; *upper_bound(vt.begin(), vt.end(), 3) \u0026lt;\u0026lt; endl; // 4 cout \u0026lt;\u0026lt; *upper_bound(vt.begin(), vt.end(), 4) \u0026lt;\u0026lt; endl; // 6 7. unique 用于将去除一个有序序列中指定范围内的重复元素（实际没有去除）,返回去除后的尾指针 1 2 3 vector\u0026lt;int\u0026gt; vt = {0,0,2,2,4,4,6,6,8,8,10,10,10,12,12}; int index = unique(vt.begin(), vt.end()) - vt.begin(); cout \u0026lt;\u0026lt; index \u0026lt;\u0026lt; endl; // 7 8. next_permutation 用于将序列指定范围的序列排成下一个排列 具体用法比较模板化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int arr[3] = {1, 2, 3}; do { for (int i = 0; i \u0026lt; 3; ++i) { cout \u0026lt;\u0026lt; arr[i]; } cout \u0026lt;\u0026lt; endl; } while (next_permutation(arr, arr + 3)); /* 输出： 123 132 213 231 312 321 */ 9. nth_element 一般用于获取序列（有序无序都可以）第n小的数 用法比较奇葩 时间复杂度接近$O(n)$ 1 2 3 4 5 6 7 8 9 int arr[10] = {8, 7, 4, 2, 1, 3, 9, 10, 5, 6}; nth_element(arr, arr + 6, arr + 10); // 让 arr + 6这个位置的数就绪，即将第7大的数放到arr[6] // 即执行完后，arr + 6位置前的数都比他小，后面的数都不低于他 for (int x : arr) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; endl; // 输出 6 5 4 2 1 3 7 8 10 9 cout \u0026lt;\u0026lt; arr[6] \u0026lt;\u0026lt; endl; // 获取排第7即位置6的数 输出 7 10. find 暴力查找一个序列中指定范围内的某个值第一次出现的位置，返回其位置的指针，若找不到返回尾指针 时间复杂度$O(n)$ 不重要，不细说 11. random_shuffle 一个用于随机打乱给定范围数组的序列 传入头指针和尾指针 12. fill 用于给序列指定区间范围的元素进行赋值 传入需要操作的头指针和尾指针（头迭代器和尾迭代器），需要赋的值 1 2 vector\u0026lt;int\u0026gt; v(10); fill(v.begin(), v.end(), 9); // 所有值都为9 13. fill_n 用于给序列从指定头结点开始，对指定数量进行赋值 传入头指针（头迭代器），需要赋值的数量，需要赋的值 1 2 vector\u0026lt;int\u0026gt; v(10); fill_n(v.begin(), 5, 9); // 从头结点开始，5个元素的值都被赋值为9 五、numeric 本章介绍几个在头文件#include \u0026lt;algorithm\u0026gt;中的函数，不是很常用，但可以用来简化代码，可以装逼\n1. accumulate 这个函数一般用于求和，传入头指针和尾指针（或迭代器），以初始值为init对序列做累加，返回累加的值 也可以自己定义操作的方式 具体看例子 1 2 3 4 5 6 7 vector\u0026lt;int\u0026gt; v = {1, 2, 3, 4, 5}; // 下面两个代码的init值为0 cout \u0026lt;\u0026lt; accumulate(v.begin(), v.end(), 0) \u0026lt;\u0026lt; endl; // 输出 15 cout \u0026lt;\u0026lt; accumulate(v.begin(), v.end(), 0, [](int res, int x) { return res + x * x; }); // 计算所有数的平方的和，输出55 2. iota 这个函数用于初始化一些数组或者序列容器（如vector），向序列中写入以value为初值的连续值（如我们通常可以用其来初始化并查集） 1 2 3 vector\u0026lt;int\u0026gt; v(10); // 此处的 value = 0 iota(v.begin(), v.end(), 0); // 此时v = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9} 作者的话 写得比较散，当时是想到什么就写什么的，篇幅较长，如有错误、缺漏等，敬请指正\n更新日志 22.1.6更新：添加了tuple的介绍 23.7.21更新：更改了一些函数的使用频率 23.9.1更新：为multiset和set添加了一些详细内容 23.10.7 更新：\n修改了一些代码片段的排版 更新了对vector的 resize 函数的解释 更新了对multiset的解释 增加了一些在头文件#include \u0026lt;numeric\u0026gt; 有些用的函数，用于简化代码，装逼用 23.10.21\n增加了fill和fill_n函数的说明 ","date":"2021-07-19T12:22:01+08:00","permalink":"https://example.com/2021/acm%E5%B8%B8%E7%94%A8c-stl%E6%80%BB%E7%BB%93/","title":"ACM常用C++stl总结"},{"content":"数位dp总结 数位dp思考形式与套路 对于区间的询问，一般利用的是前缀和的思想来求得答案\n在求解答案时，一般是从高位到低位开始对答案进行累计\n求解数位dp时，更像是在求解树上的信息\n某一位中在未超过限制位的信息可提前预处理出来\n值得注意的\n大多数时候要记录前几位设置为最高数的信息 若到了最后一位并将其设置为最高数时还需要特判 0要根据题意思考是否需要特判 允许前导0和非允许前导0是不一样的 一般递归版的数位dp求解代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 int num[100], dp[100]; int dfs(int indx, int limit, /*参数根据题意来添加*/) { if (indx == 0) { return 1;// 根据题意来返回 } int \u0026amp;ref = dp[indx]; if (!limit \u0026amp;\u0026amp; ref != -1) return ref; int res = 0; int up = (limit ? num[indx] : 9); for (int i = 0; i \u0026lt;= up; ++i) { // 更新res dfs(indx - 1, limit \u0026amp;\u0026amp; i == up); } if (!limit) ref = res; return res; } int solve(int x) { if (!x) return 1; // 根据题意来决定返回值 int len = 0; while (x) { num[++len] = x % 10; x /= 10; } return dfs(len, 1); } int main() { memset(dp, - 1, sizeof dp); // 此行省略读入 cout \u0026lt;\u0026lt; solve(r) - solve(l - 1) endl; } 一般递推版的数位dp求解代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 void prework() { // 对每一位未超过最高数时的信息进行预处理 } int solve(int x) { int num[10], len = 0, res = 0; // 不同题意res初始化不同，即一般是0算不算的区别 if (!x) return 1;// 返回什么根据题意来 while (x) { // 抠每一位出来 num[++len] = x % 10; x /= 10; } int last = 0; // 记录前几位需要信息，初始化根据题意来 for (int i = len; i \u0026gt;= 1; --i) { for (int j = 0; j \u0026lt; num[i]; ++j) { // 注意如果题目对前导0有要求可在第一位开始从1开始再到25行处处理第一位如果是0的情况 if (/*j 和 last放在一起不符合题意*/) continue; res += // 对每一位填未超过此位的数字时的答案进行累加，一般这里利用到prework预处理出来的东西 } // 来到这一步说明此位填num[i] if (/*此位填num[i]不符合题意*/) break; last += // 更新last if (last /*符合题意*/ \u0026amp;\u0026amp; i == 1) { // 更新res } } for (int i = len - 1; i \u0026gt;= 1; --i) { // 假设不能有前导0，则枚举从次高位开始到低位 for (int j = 1; j \u0026lt; 10; ++j) { // 枚举每一位都放1~9 res += // 更新res } } return res; } int main() { prework(); // 此行省略读入 cout \u0026lt;\u0026lt; solve(r) - solve(l - 1) endl; } 例题 LOJ 10166 数字游戏 递归写法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 /* 由于科协里最近真的很流行数字游戏，某人又命名了一种取模数，这种数字必须满足各位数字之和 mod n为0。现在大家又要玩游戏了，指定一个整数闭区间[a,b]，问这个区间内有多少个取模数。 */ #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #define ll long long #define pb push_back ll IO() { ll x = 0; int f = 0, c = getchar(); while (!isdigit(c)) { if (c == \u0026#39;-\u0026#39;) f = 1; c = getchar(); } while (isdigit(c)) x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + c - \u0026#39;0\u0026#39;, c = getchar(); return f ? -x : x; } void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } using namespace std; const int N = 1e4 + 5, M = 1 \u0026lt;\u0026lt; 10; const ll mod = 1e9 + 7; int num[N], n; ll dp[20][101]; ll dfs(int x, int limit, int m) { ll \u0026amp;res = dp[x][m]; if (!limit \u0026amp;\u0026amp; ~res) return res; if (x == 0) return m == 0; ll sum = 0; int up = (limit ? num[x] : 9); for (int i = 0; i \u0026lt;= up; ++i) { sum += dfs(x - 1, limit \u0026amp;\u0026amp; i == up, (m + i) % n); } if (!limit) res = sum; return sum; } ll solve(ll x) { if (!x) return 1; int len = 0; while (x) num[++len] = x % 10, x /= 10; return dfs(len, 1, 0); } void problem(ll l, ll r) { n = IO(); memset(dp, -1, sizeof dp); print(solve(r) - solve(l - 1)); puts(\u0026#34;\u0026#34;); } int main() { int n = 1, l, r; while (~scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;l, \u0026amp;r)) problem(l, r); return 0; } 递推写法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long ll IO() { ll x = 0; int f = 0; char c = getchar(); while (!isdigit(c)) { if (c == \u0026#39;-\u0026#39;) f = 1; c = getchar(); } while (isdigit(c)) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + c - \u0026#39;0\u0026#39;; c = getchar(); } return f ? -x : x; } using namespace std; ll dp[110][110]; int num[110], l, r, n; int f(int x) { return (x % n + n) % n; } int solve(int x) { if (!x) return 1; int len = 0; while (x) { num[++len] = x % 10; x /= 10; } int last = 0, res = 0; for (int i = len; i \u0026gt;= 1; --i) { for (int j = 0; j \u0026lt; num[i]; ++j) { res += dp[i - 1][f(n - last - j)]; } last = (num[i] + last) % n; if (last == 0 \u0026amp;\u0026amp; i == 1) res += 1; } return res; } void problem() { dp[0][0] = 1; for (int i = 1; i \u0026lt;= 31; ++i) { for (int j = 0; j \u0026lt; n; ++j) { dp[i][j] = 0; for (int k = 0; k \u0026lt; 10; ++k) { // dp[i][j] += dp[i - 1][f(j + k)]; dp[i][j] += dp[i - 1][f(j - k)]; } } } printf(\u0026#34;%d\\n\u0026#34;, solve(r) - solve(l - 1)); } int main() { #ifndef ONLINE_JUDGE freopen(\u0026#34;D:/MYCODE/vsCode-c/test.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;D:/MYCODE/vsCode-c/test.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif // int t = 1; while (~scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;l, \u0026amp;r, \u0026amp;n)) { problem(); } return 0; } LOJ windy数 递归写法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #define ll long long #define pb push_back ll IO() { ll x = 0; int f = 0, c = getchar(); while (!isdigit(c)) { if (c == \u0026#39;-\u0026#39;) f = 1; c = getchar(); } while (isdigit(c)) x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + c - \u0026#39;0\u0026#39;, c = getchar(); return f ? -x : x; } void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } using namespace std; const int N = 1e4 + 5, M = 1 \u0026lt;\u0026lt; 10; const ll mod = 1e9 + 7; int num[N], n; ll dp[20][15], len; ll dfs(int x, int limit, int last) { if (x == 0) { return 1; } ll \u0026amp;ref = dp[x][last], sum = 0; if (!limit \u0026amp;\u0026amp; ~ref) return ref; int up = (limit ? num[x] : 9); for (int i = 0; i \u0026lt;= up; ++i) { if (abs(last - i) \u0026lt; 2) continue; sum += dfs(x - 1, limit \u0026amp;\u0026amp; up == i, last == 12 \u0026amp;\u0026amp; i == 0 ? 12 : i); } if (~limit) ref = sum; return sum; } ll solve(ll x) { if (!x) return 1; len = 0; while (x) num[++len] = x % 10, x /= 10; return dfs(len, 1, 12); } void problem(ll l, ll r) { memset(dp, -1, sizeof dp); // print(solve(r)); print(solve(r) - solve(l - 1)); } int main() { int n = 1, l, r; while (~scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;l, \u0026amp;r)) problem(l, r); return 0; } 递推写法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #define ll long long #define pb push_back ll IO() { ll x = 0; int f = 0, c = getchar(); while (!isdigit(c)) { if (c == \u0026#39;-\u0026#39;) f = 1; c = getchar(); } while (isdigit(c)) x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + c - \u0026#39;0\u0026#39;, c = getchar(); return f ? -x : x; } void print(ll x) { if (x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;), x = -x; if (x \u0026gt; 9) print(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } using namespace std; const int N = 1e4 + 5, M = 1 \u0026lt;\u0026lt; 10, mod = 1e8; int dp[20][20]; void prework() { for (int i = 0; i \u0026lt; 10; ++i) dp[1][i] = 1; for (int i = 2; i \u0026lt;= 10; ++i) { for (int j = 0; j \u0026lt; 10; ++j) { for (int k = 0; k \u0026lt; 10; ++k) { if (abs(j - k) \u0026lt; 2) continue; dp[i][j] += dp[i - 1][k]; } } } } int solve(int x) { int num[15], len = 0, res = 0; if (!x) return 1; while (x) num[++len] = x % 10, x /= 10; int last = 100; for (int i = len; i \u0026gt;= 1; --i) { for (int j = (i == len); j \u0026lt; num[i]; ++j) { if (abs(last - j) \u0026lt; 2) continue; res += dp[i][j]; } if (abs(last - num[i]) \u0026lt; 2) break; last = num[i]; if (i == 1) res += 1; } for (int i = len - 1; i \u0026gt;= 1; --i) for (int j = 1; j \u0026lt; 10; ++j) res += dp[i][j]; return res + 1; } void problem() { int l = IO(), r = IO(); prework(); // print(solve(r)); // puts(\u0026#34;\u0026#34;); print(solve(r) - solve(l - 1)); } int main() { int n = 1; while (n--) problem(); return 0; } ","date":"2021-07-19T12:22:01+08:00","permalink":"https://example.com/2021/%E6%95%B0%E4%BD%8Ddp%E6%80%BB%E7%BB%93/","title":"数位dp总结"},{"content":"网络流 一、最大流 Ekmonds-Karp 主要思想就是先找增广路，就是一个贪心的过程，注意这是带反悔的贪心，固要建立一个流为0的反边 时间复杂度$O(nm^2)$ bfs记录前驱的寻找增广路 因为要记录一个点的前驱，该方法一次只能找到一条增广路，具体细节看代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;queue\u0026gt; bool vis[maxn]; // 记录是否在队内 ll minc[maxn]; // 记录增广路的最小流 struct pairs { int u, i; } pre[maxn]; // 用来记录前驱结点 bool bfs(int s, int t, int n) { queue\u0026lt;int\u0026gt; q; for (int i = 0; i \u0026lt;= n; ++i) vis[i] = false; q.push(s), vis[s] = true, minc[s] = inf; // 初始化minc为无穷大 while (q.size()) { int u = q.front(); q.pop(); for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to; if (vis[v] || !edge[i].c) continue; vis[v] = true, pre[v] = {.u = u, .i = i}; //记录当前点的前驱点和当前点的内存池编号 minc[v] = min(minc[u], edge[i].c); // 更新最小流 if (v == t) return true; //找到了终点（汇点） q.push(v); } } return false; } EK核心代码 一直找前驱，然后减去增广路中的最小费用 1 2 3 4 5 6 7 8 9 10 11 ll EK(int s, int t, int n) { ll ans = 0, \u0026amp;dif = minc[t]; // 引用到达汇点的最小费用 while (bfs(s, t, n)) { ans += dif; for (int i = t; i != s; i = pre[i].u) { edge[pre[i].i].c -= dif; // 正向边- edge[pre[i].i ^ 1].c += dif; // 反向边+ } } return ans; } 完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; #define ll long long #include \u0026lt;cctype\u0026gt; inline long long IO() // 快读略 class EK { struct edges { int to, next; ll cap, flow;// flow为记录当前路径流的流量，cap为容量 }; vector\u0026lt;edges\u0026gt; e; static const ll inf = 1e18; vector\u0026lt;int\u0026gt; head, vis, pre;// vis记录是否在队内, pre记录前驱内存池编号 vector\u0026lt;ll\u0026gt; minc; // minc记录增广路的最小流 int n; // 点的个数 int bfs(int s, int t) { queue\u0026lt;int\u0026gt; q; for (int i = 0; i \u0026lt;= n; ++i) vis[i] = 0, pre[i] = -1; q.push(s), vis[s] = 1, minc[s] = inf;// 初始化minc为无穷大 while (q.size()) { int u = q.front(); q.pop(); for (int i = head[u]; ~i; i = e[i].next) { int v = e[i].to; if (vis[v] || e[i].cap == e[i].flow) continue; vis[v] = 1, pre[v] = i; minc[v] = min(minc[u], e[i].cap - e[i].flow);// 更新最小流 if (v == t) return 1;//找到了终点（汇点） q.push(v); } } return 0; } public: EK(int n = 0) { init(n); } void init(int n) { this-\u0026gt;n = n; e.clear(); head.resize(n + 1); fill(head.begin(), head.end(), -1); pre.resize(n + 1), vis.resize(n + 1), minc.resize(n + 1); } void add_edge(int u, int v, ll cap, int f = 1) { e.push_back({v, head[u], cap, 0}); head[u] = e.size() - 1; if (f) add_edge(v, u, 0, 0); } ll maxflow(int s, int t) { // 计算最大流 ll ans = 0, \u0026amp;dif = minc[t]; while (bfs(s, t)) { ans += dif; for (int i = pre[t]; ~i; i = pre[e[i ^ 1].to]) { e[i].flow += dif; // 正向边flow+ e[i ^ 1].flow -= dif; // 反向边flow- } } return ans; } void clearflow() { // 将流清空 for (auto\u0026amp; x : e) x.flow = 0; } }; int main() { int n = IO(), m = IO(), s = IO(), t = IO(); EK ek(n); for (int i = 0; i \u0026lt; m; ++i) { int u = IO(), v = IO(), cap = IO(); ek.add_edge(u, v, cap); } printf(\u0026#34;%lld\u0026#34;, ek.maxflow(s, t)); return 0; } Dinic ek算法比较慢，原因在于每次只能找到一条增广路 dinic算法每次可以利用深度（bfs最近距离）找到多个增广路 复杂度$O(n^2m)$ bfs找多个增广路 利用$deep$数组记录每个点的距离源点的最近距离 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;queue\u0026gt; int deep[maxn], cur[maxn]; // bfs求增广路，一次求出多条增广路 bool bfs(int s, int t, int n) { queue\u0026lt;int\u0026gt; q; for (int i = 1; i \u0026lt;= n; ++i) deep[i] = 0; deep[s] = 1; // 源点的深度为1 q.push(s); while (q.size()) { int u = q.front(); q.pop(); for (int i = head[u]; ~i; i = edge[i].next) { const int \u0026amp;v = edge[i].to; const ll \u0026amp;c = edge[i].c; if (deep[v] || !c) continue; // 如果被遍历过，或者没有流量了 deep[v] = deep[u] + 1; q.push(v); } } return deep[t] != 0; } 递归在多个增广路上计算流 由于一次bfs能找到多条增广路，固可以用dfs对多条增广路同时计算流，这是dinic的核心 几个优化 当前弧优化：对于一条路被计算过后，后面的dfs时这条路就不会再进行对这条路进行计算了，例如$1 \\to 2 \\to 3$中当$1\\to 2$被计算过后，我们可以让$1\\to 3$这样 多路增广优化：普通的dinic一般都是一次bfs多次dfs，而利用多路增广的话就可以做到一次bfs一次dfs，做法就是记录后面的路总共的流再进行return流的总共的大小，这个优化较其他两个优秀 炸点优化：当一个点遍历完他的所有他的下一个节点，发现一条增广路都没有即nowflow = 0，则可以将这个点从图中去掉了，即deep[i] = -2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 当前弧优化+多路增广优化+炸点优化 ll dfs(int u, int t, ll f) { if (u == t) return f; ll nowflow = 0; for (int i = cur[u]; ~i; i = edge[i].next) { cur[u] = i; // 当前弧优化 int \u0026amp;v = edge[i].to; ll \u0026amp;c = edge[i].c; if (deep[v] != deep[u] + 1 || !c) continue; if (ll low = dfs(v, t, min(f - nowflow, c))) { c -= low, edge[i ^ 1].c += low; nowflow += low;// 多路增广优化 if (nowflow == f) break; // 满流了 } } if (!nowflow) deep[u] = -2; // 炸点优化 return nowflow; } ll dinic(int s, int t, int n) { ll ans = 0; while (bfs(s, t, n)) { for (int i = 1; i \u0026lt;= n; ++i) cur[i] = head[i]; // 预处理，方便当前弧优化 ans += dfs(s, t, inf); // 进过多路增广优化可不用循环 } return ans; } 完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #define ll long long using namespace std; #include \u0026lt;cctype\u0026gt; inline long long IO() // 快读略 class Dinic { struct edges { int to, next; ll cap, flow;// flow为记录当前路径流的流量，cap为容量 }; vector\u0026lt;edges\u0026gt; e; static const ll inf = 1e18; vector\u0026lt;int\u0026gt; head, cur, deep; int n; // bfs求增广路，一次求出多条增广路 int bfs(int s, int t) { queue\u0026lt;int\u0026gt; q; for (auto\u0026amp; x : deep) x = 0; deep[s] = 1, q.push(s); while (q.size()) { int u = q.front(); q.pop(); for (int i = head[u]; ~i; i = e[i].next) { int v = e[i].to; if (deep[v] || e[i].cap == e[i].flow) continue; deep[v] = deep[u] + 1; q.push(v); } } return deep[t] != 0; } ll dfs(int u, int t, ll flow) { if (u == t) return flow; ll nowflow = 0; for (int i = cur[u]; ~i; i = e[i].next) { cur[u] = i;// 当前弧优化 int v = e[i].to; if (deep[v] != deep[u] + 1 || e[i].cap == e[i].flow) continue; if (ll low = dfs(v, t, min(flow - nowflow, e[i].cap - e[i].flow))) { e[i].flow += low, e[i ^ 1].flow -= low; nowflow += low;// 多路增广优化 if (nowflow == flow) break; } } if (!nowflow) deep[u] = -2;// 炸点优化 return nowflow; } public: Dinic(int n = 0) { init(n); } void init(int n) { this-\u0026gt;n = n; e.clear(); head.resize(n + 1); fill(head.begin(), head.end(), -1); deep.resize(n + 1); } void add_edge(int u, int v, ll cap, int f = 1) { e.push_back({v, head[u], cap, 0}); head[u] = e.size() - 1; if (f) add_edge(v, u, 0, 0); } ll maxflow(int s, int t) { ll ans = 0; while (bfs(s, t)) { cur = head;// 预处理，方便当前弧优化 ans += dfs(s, t, inf);// 进过多路增广优化可不用循环 } return ans; } void clearflow() { for (auto\u0026amp; x : e) x.flow = 0; } }; int main() { int n = IO(), m = IO(), s = IO(), t = IO(); Dinic dinic(n); for (int i = 0; i \u0026lt; m; ++i) { int u = IO(), v = IO(); ll c = IO(); dinic.add_edge(u, v, c); } printf(\u0026#34;%lld\u0026#34;, dinic.maxflow(s, t)); return 0; } 二、最小费用最大流 最小费用最大流，我发现如果是普通的更改dinic会退化到比ek的复杂度还大（可能是我太菜了） 计算mcmf只要将计算最大流中寻找增广路的bfs修改成寻找最短路的就可以了（好像有个公式可以证明的） 注意：存图的反向图的边的流必须是0，同时它的费用必须是正向边的费用的相反数 EK版 直接将ek中的bfs换成spfa就好了 完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; #define ll long long #include \u0026lt;cctype\u0026gt; inline long long IO() // 快读略 class MCMF{ struct edges { int to, next; ll cap, cost, flow;;// flow为记录当前路径流的流量，cap为容量 }; vector\u0026lt;edges\u0026gt; e; static const ll inf = 1e15; vector\u0026lt;int\u0026gt; head, pre, inq; vector\u0026lt;ll\u0026gt; dist; int n; int spfa(int s, int t) {// 利用spaf找最小费用的路，即最短路 for (int i = 0; i \u0026lt;= n; ++i) inq[i] = 0, dist[i] = inf, pre[i] = -1; queue\u0026lt;int\u0026gt; q; inq[s] = 1, q.push(s), dist[s] = 0; while (q.size()) { int u = q.front(); q.pop(); inq[u] = 0; for (int i = head[u]; ~i; i = e[i].next) { int v = e[i].to; ll \u0026amp;cost = e[i].cost; if (dist[v] \u0026gt; dist[u] + cost \u0026amp;\u0026amp; e[i].cap \u0026gt; e[i].flow) { dist[v] = dist[u] + cost; pre[v] = i;//记录当前点的前驱的内存池编号 if (inq[v]) continue; inq[v] = 1 , q.push(v); } } } return pre[t] != -1;// 如果说t没有前驱则说明找不到增广路了 } public: MCMF(int n = 0) { init(n); } void add_edge(int u, int v, ll cap, ll cost, int f = 1) { e.push_back({v, head[u], cap, cost, 0}); head[u] = e.size() - 1; if (f) add_edge(v, u, 0, -cost, 0);// 建立反向弧，费用相反 } void init(int n) { this-\u0026gt;n = n; head.resize(n + 1, -1); pre.resize(n + 1), inq.resize(n + 1); dist.resize(n + 1); } pair\u0026lt;ll, ll\u0026gt; mcmf(int s, int t) { ll maxflow = 0, mincost = 0; while (spfa(s, t)) { ll low = inf; for (int i = pre[t]; ~i; i = pre[e[i ^ 1].to]) { low = min(low, e[i].cap - e[i].flow);//寻找最小流 } for (int i = pre[t]; ~i; i = pre[e[i ^ 1].to]) { e[i].flow += low; e[i ^ 1].flow -= low; mincost += low * e[i].cost; } maxflow += low; } return make_pair(maxflow, mincost); } void clearflow() { for (auto\u0026amp; x : e) x.flow = 0; } }; int main() { int n = IO(), m = IO(); MCMF mcmf(n); for (int i = 0; i \u0026lt; m; ++i) { int u = IO(), v = IO(); ll cap = IO(), cost = IO(); mcmf.add_edge(u, v, cap, cost); } auto [a, b] = mcmf.mcmf(1, n); // 注意c++17才能这样写 printf(\u0026#34;%lld %lld\u0026#34;, a, b); return 0; } 三、二分图最大匹配 解法1：利用匈牙利算法解决 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int match[M]; bool vis[M]; bool dfs(int u) { for (int \u0026amp;v : gp[u]) { if (vis[v]) continue; vis[v] = true; if (!match[v] || dfs(match[v])) { match[u] = v, match[v] = u; return true; } } return false; } // 主函数里 fill_n(match, n + 1, 0); // n是点的个数 for (int i = 1; i \u0026lt;= n; ++i) { if (match[i]) continue; fill_n(vis, n + 1, false); dfs(i); } 解法二：将所有结点 四、最小路径覆盖 原图中的每个点拆点，（将点u拆成u与u+n）； 将原图中的每条边 \u0026lt;u,v\u0026gt; 在新图中建立对应的边 \u0026lt;u,v+n\u0026gt;； 将点（1 ~ n）作为二分图的左部，将点（n+1 ~ 2 $\\times$ n）作为二分图的右部，进行二分图的最大匹配； 所求的最少路径数等于总点数n 减去 最大匹配数。 五、最小链覆盖（应该不是网络流的内容） ","date":"2021-05-26T12:22:01+08:00","permalink":"https://example.com/2021/%E7%BD%91%E7%BB%9C%E6%B5%81/","title":"网络流"},{"content":"dsu 树上启发式合并 刷题 套路代码（一） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 int son[M], dep[M], siz[M]; // son记录重儿子 // 寻找重儿子 void dfs(int u, int fa) { siz[u] = 1; dep[u] = dep[fa] + 1; // 记录深度，有些题不需要 for (/*遍历下一个结点*/) { v = /*下一个结点*/; if (v == fa) continue; dfs(v, u); siz[u] += siz[v]; if (siz[v] \u0026gt; siz[son[u]]) son[u] = v; } } int flag; void cal(int u, int fa, int k) { // 计算 // 遍历孩子，并利用 flag 避开重儿子 } void dsu(int u, int fa, int keep) { for (/*遍历下一个结点*/) { v = /*下一个结点*/; if (v != fa \u0026amp;\u0026amp; v != son[u]) dsu(v, u, 0); } if (son[u]) dsu(son[u], u, 1), flag = son[u]; // 如果存在重儿子,一定要最后计算重儿子 cal(u, fa, 1); // 计算 if (flag) flag = 0; if (!keep) cal(u, fa, -1); //删除 } 套路代码（二） 和（一）的本质是一样的，虽然（二）代码比较长，但感觉好理解也实用（对子树根结点有特殊处理的题有奇效）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 int son[M], dep[M], siz[M]; // son记录重儿子 // 寻找重儿子 void dfs(int u, int fa) { siz[u] = 1; dep[u] = dep[fa] + 1; // 记录深度，有些题不需要 for (/*遍历下一个结点*/) { v = /*下一个结点*/; if (v == fa) continue; dfs(v, u); siz[u] += siz[v]; if (siz[v] \u0026gt; siz[son[u]]) son[u] = v; } } void cal(int u, int fa, int k) { // 计算 } void dsu(int u, int fa, int keep) { for (/*遍历下一个结点*/) { v = /*下一个结点*/; if (v != fa \u0026amp;\u0026amp; v != son[u]) dsu(v, u, 0); } if (son[u]) dsu(son[u], u, 1); // 如果存在重儿子,一定要最后计算重儿子 /* 加上本结点 */ for (/*遍历下一个结点*/) { v = /*下一个结点*/; if (v != fa \u0026amp;\u0026amp; v != son[u]) cal(v, u, 1); //避开重儿子 } if (!keep) { // 删除 /*减去本结点 */ for (/*遍历下一个结点*/) { v = /*下一个结点*/; if (v != fa) cal(v, u, -1); // 注意，这里不用判重儿子 } } } 例题 CF600E Lomsat gelral 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 /* 题意： 有一棵 个结点的以 1 号结点为根的有根树。 每个结点都有一个颜色，颜色是以编号表示的，i 号结点的颜色编号为 ci 如果一种颜色在以 x 为根的子树内出现次数最多，称其在以 x 为根的子树中占主导地位。 显然，同一子树中可能有多种颜色占主导地位。 你的任务是对于每一个 i∈[1,n]，求出以 i 为根的子树中，占主导地位的颜色的编号和。 N\u0026lt;=1e5,ci\u0026lt;=n */ #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #define ll long long #define rep(u, v, e) for (int i = head[u], v = e[i].to; ~i; i = e[i].next, v = e[i].to) using namespace std; const int N = 1e5 + 5, M = 2e5 + 5; int head[N], cnt; //初始化 void init() { memset(head, -1, sizeof head); cnt = -1; } struct edges { int to, next; int w; void add(int t, int n, int w) { to = t, next = n, this-\u0026gt;w = w; } }edge[N \u0026lt;\u0026lt; 1]; //无向图则需要乘2 inline void add(int u, int v, int w = 1) { edge[++cnt].add(v, head[u], w); head[u] = cnt; } int son[N], siz[N]; void dfs(int u, int fa) { siz[u] = 1; rep(u, v, edge) { if (v == fa) continue; dfs(v, u); siz[u] += siz[v]; if (siz[v] \u0026gt; siz[son[u]]) son[u] = v; } } ll col[N], ans[N], flag, num[N], now, sum, tot; void cal(int u, int fa, int k) { num[col[u]] += k; if (k \u0026gt; 0) { if (num[col[u]] == tot) sum += col[u]; else if (num[col[u]] \u0026gt; tot) tot = num[col[u]], sum = col[u]; } rep(u, v, edge) { if (v == fa || v == flag) continue; cal(v, u, k); } } void dsu(int u, int fa, int keep) { rep(u, v, edge) { if (v == fa || v == son[u]) continue; dsu(v, u, 0); } if (son[u]) dsu(son[u], u, 1), flag = son[u]; now = u; cal(u, fa, 1); ans[u] = sum; if (flag) flag = 0; if (!keep) cal(u, fa, -1), tot = 0; } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); init(); for (int i = 1; i \u0026lt;= n; ++i) scanf(\u0026#34;%lld\u0026#34;, col + i); for (int i = 1; i \u0026lt; n; ++i) { int u, v; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;u, \u0026amp;v); add(u, v), add(v, u); } dfs(1, 0); dsu(1, 0, 1); for (int i = 1; i \u0026lt;= n; ++i) printf(\u0026#34;%lld \u0026#34;, ans[i]); return 0; } 反思：本题第二次做，sum值必须要开全局且是单值，而不是数组（即记录每个节点的答案），而是如代码所示的做法，直接用ans在dsu内复制，用sum值不开数组开全局的好处就是会一直保留重儿子的信息‘ CF570D Tree Requests 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 /* 给定一个以1为根的n个节点的树，每个点上有一个字母(a−z) 每个点的深度定义为该节点到1号节点路径上的点数. 每次询问 a,b， 查询以 a 为根的子树内深度为 b 的节点上的字母重新排列之后是否能构成回文串. */ #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int N = 5e5 + 5; vector\u0026lt;int\u0026gt; mp[N]; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q[N]; char s[N]; int col[N], dep[N], son[N], siz[N]; void dfs(int u) { siz[u] = 1; for (auto v : mp[u]) { dep[v] = dep[u] + 1; dfs(v); siz[u] += siz[v]; if (siz[son[u]] \u0026lt; siz[v]) son[u] = v; } } int cnt[N][30]; // cnt[i][c] 深度为i的字符c出现次数 int ans[N]; void cal(int u, int k) { cnt[dep[u]][col[u]] += k; for (auto v : mp[u]) { cal(v, k); } } void dsu(int u, int keep) { for (auto v : mp[u]) if (v != son[u]) dsu(v, 0); if (son[u]) dsu(son[u], 1); cnt[dep[u]][col[u]] += 1; for (auto v : mp[u]) { if (v != son[u]) { cal(v, 1); } } for (auto\u0026amp; [d, id] : q[u]) { int num = 0; for (int i = 0; i \u0026lt; 26; ++i) num += cnt[d][i] \u0026amp; 1; ans[id] = num \u0026gt; 1 ? 0 : 1; } if (keep == 0) { cnt[dep[u]][col[u]] -= 1; for (auto v : mp[u]) { cal(v, -1); } } } int main() { int n, m; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 2; i \u0026lt;= n; ++i) { int v; scanf(\u0026#34;%d\u0026#34;, \u0026amp;v); mp[v].push_back(i); } scanf(\u0026#34;%s\u0026#34;, s + 1); for (int i = 1; i \u0026lt;= n; ++i) { col[i] = s[i] - \u0026#39;a\u0026#39;; } dep[1] = 1; dfs(1); for (int i = 0; i \u0026lt; m; ++i) { int u, d; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;u, \u0026amp;d); q[u].push_back({d, i}); } dsu(1, 1); for (int i = 0; i \u0026lt; m; ++i) { puts(ans[i] ? \u0026#34;Yes\u0026#34; : \u0026#34;No\u0026#34;); } return 0; } CF208E Blood Cousins 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 //给你一片森林，每次询问一个点与多少个点拥有共同的K级祖先 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int N = 1e5 + 5; vector\u0026lt;int\u0026gt; mp[N]; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q[N]; int dep[N], son[N], siz[N], fa[N][20]; void dfs(int u) { siz[u] = 1; for (auto v : mp[u]) { dep[v] = dep[u] + 1, fa[v][0] = u; for (int i = 1; (1 \u0026lt;\u0026lt; i) \u0026lt;= dep[v]; ++i) { fa[v][i] = fa[fa[v][i - 1]][i - 1]; } dfs(v); siz[u] += siz[v]; if (siz[son[u]] \u0026lt; siz[v]) son[u] = v; } } int pth(int u, int p) { // 找u的p级祖先是谁 if (dep[u] \u0026lt;= p) return 0; for (int i = 20; i \u0026gt;= 0; --i) { if (p \u0026gt;= (1 \u0026lt;\u0026lt; i)) u = fa[u][i], p -= (1 \u0026lt;\u0026lt; i); } return u; } int cnt[N]; // 深度为i的个数 int ans[N]; void cal(int u, int k) { cnt[dep[u]] += k; for (int v : mp[u]) { cal(v, k); } } void dsu(int u, int keep) { for (int v : mp[u]) if (v != son[u]) dsu(v, 0); if (son[u]) dsu(son[u], 1); cnt[dep[u]] += 1; for (int v : mp[u]) { if (v != son[u]) { cal(v, 1); } } for (auto [d, id] : q[u]) { if (cnt[d]) ans[id] = cnt[d] - 1; else ans[id] = 0; // 应该不会走这个判断 } if (keep == 0) { cnt[dep[u]] -= 1; for (int v : mp[u]) cal(v, -1); } } int main() { int n, m; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { int fa; scanf(\u0026#34;%d\u0026#34;, \u0026amp;fa); mp[fa].push_back(i); } dfs(0); scanf(\u0026#34;%d\u0026#34;, \u0026amp;m); for (int i = 0; i \u0026lt; m; ++i) { int u, p; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;u, \u0026amp;p); int f = pth(u, p); if (f) q[f].push_back({p + dep[f], i}); // 将问题转化为以f为根结点的子树，距离0号结点的深度为p + dep[f]的结点个数 } dsu(0, 1); for (int i = 0; i \u0026lt; m; ++i) { printf(\u0026#34;%d \u0026#34;, ans[i]); } return 0; } CF246E Blood Cousins Return 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; const int N = 1e5 + 5; vector\u0026lt;int\u0026gt; mp[N]; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q[N]; int dep[N], son[N], siz[N], col[N]; void dfs(int u) { siz[u] = 1; for (auto v : mp[u]) { dep[v] = dep[u] + 1; dfs(v); siz[u] += siz[v]; if (siz[son[u]] \u0026lt; siz[v]) son[u] = v; } } map\u0026lt;int, int\u0026gt; cnt[N \u0026lt;\u0026lt; 1]; int ans[N]; void cal(int u, int k) { cnt[dep[u]][col[u]] += k; if (cnt[dep[u]][col[u]] == 0) cnt[dep[u]].erase(col[u]); for (int v : mp[u]) { cal(v, k); } } void dsu(int u, int keep) { for (int v : mp[u]) if (v != son[u]) dsu(v, 0); if (son[u]) dsu(son[u], 1); cnt[dep[u]][col[u]] += 1; for (int v : mp[u]) { if (v != son[u]) { cal(v, 1); } } for (auto [d, id] : q[u]) { ans[id] = cnt[d].size(); } if (keep == 0) { cnt[dep[u]][col[u]] -= 1; if (cnt[dep[u]][col[u]] == 0) cnt[dep[u]].erase(col[u]); for (int v : mp[u]) cal(v, -1); } } int main() { int n, m, cnt = 0; scanf(\u0026#34;%d\\n\u0026#34;, \u0026amp;n); map\u0026lt;string, int\u0026gt; ms; for (int i = 1; i \u0026lt;= n; ++i) { char ch[30]; int fa; scanf(\u0026#34;%s %d\\n\u0026#34;, ch, \u0026amp;fa); string s(ch); if (ms.count(s) == 0) ms[s] = ++cnt; col[i] = ms[s]; mp[fa].push_back(i); } dfs(0); scanf(\u0026#34;%d\u0026#34;, \u0026amp;m); for (int i = 0; i \u0026lt; m; ++i) { int u, k; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;u, \u0026amp;k); q[u].push_back({k + dep[u], i}); } dsu(0, 1); for (int i = 0; i \u0026lt; m; ++i) { printf(\u0026#34;%d\\n\u0026#34;, ans[i]); } return 0; } CF1009F Dominant Indices 这题的求解方式一开始想的是套个线段树+二分找，但发现直接记录最大的d(u,k)和最小的k就好了，这也突出了最后再计算重儿子的重要性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 /* 给定一棵以 1 为根，n 个节点的树。设 d(u,x) 为 u 子树中到 u 距离为 x 的节点数。 对于每个点，求一个最小的 k，使得 d(u,k)最大 */ #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int N = 1e6 + 5; vector\u0026lt;int\u0026gt; mp[N]; int dep[N], siz[N], son[N]; void dfs(int u, int fa) { siz[u] = 1, dep[u] = dep[fa] + 1; for (int v : mp[u]) { if (v == fa) continue; dfs(v, u); siz[u] += siz[v]; if (siz[v] \u0026gt; siz[son[u]]) son[u] = v; } } int ans[N], cnt[N], res, maxd;// cnt[i] 深度为i的个数 void cal(int u, int fa, int k, int flag) { if (u == flag) return; cnt[dep[u]] += k; if (k \u0026gt; 0 \u0026amp;\u0026amp; cnt[dep[u]] \u0026gt;= maxd) { if (cnt[dep[u]] \u0026gt; maxd) maxd = cnt[dep[u]], res = dep[u]; else if (res \u0026gt; dep[u]) res = dep[u]; } for (int v : mp[u]) { if (v == fa) continue; cal(v, u, k, flag); } } void dsu(int u, int fa, int keep) { for (int v : mp[u]) { if (v == fa || v == son[u]) continue; dsu(v, u, 0); } if (son[u]) dsu(son[u], u, 1); // 最后再计算重儿子 cal(u, fa, 1, son[u]); ans[u] = res - dep[u]; if (keep == 0) { cal(u, fa, -1, 0); maxd = res = 0; // 置0，不用担心，因为最后计算重儿子，不会影响u父亲fa的子树的重儿子的maxd和res值 } } int main() { #ifndef ONLINE_JUDGE freopen(\u0026#34;D:/MYCODE/vsCode-c/test.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); // freopen(\u0026#34;D:/MYCODE/vsCode-c/test.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt; n; ++i) { int u, v; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;u, \u0026amp;v); mp[u].push_back(v); mp[v].push_back(u); } dfs(1, 0); dsu(1, 0, 1); for (int i = 1; i \u0026lt;= n; ++i) { printf(\u0026#34;%d\\n\u0026#34;, ans[i]); } return 0; } CF375D Tree and Queries 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 // 问你以u为子树，颜色出现次数大于等于k的个数 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int N = 1e5 + 5; vector\u0026lt;int\u0026gt; mp[N]; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q[N]; int dep[N], siz[N], son[N], col[N]; void dfs(int u, int fa) { siz[u] = 1; for (int v : mp[u]) { if (v == fa) continue; dfs(v, u); siz[u] += siz[v]; if (siz[v] \u0026gt; siz[son[u]]) son[u] = v; } } int ans[N], cnt[N], num[N]; // cnt[i] 颜色为i的个数, num[i] 颜色数量为i的数量 void cal(int u, int fa, int k, int flag) { if (u == flag) return; if (k == -1) num[cnt[col[u]]] -= 1; cnt[col[u]] += k; if (k == 1) num[cnt[col[u]]] += 1; for (int v : mp[u]) { if (v == fa) continue; cal(v, u, k, flag); } } void dsu(int u, int fa, int keep) { for (int v : mp[u]) { if (v == fa || v == son[u]) continue; dsu(v, u, 0); } if (son[u]) dsu(son[u], u, 1); // 最后再计算重儿子 cal(u, fa, 1, son[u]); for (auto [k, id] : q[u]) ans[id] = num[k]; if (keep == 0) cal(u, fa, -1, 0); } int main() { int n, m; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; ++i) scanf(\u0026#34;%d\u0026#34;, col + i); for (int i = 1; i \u0026lt; n; ++i) { int u, v; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;u, \u0026amp;v); mp[u].push_back(v); mp[v].push_back(u); } dfs(1, 0); for (int i = 0; i \u0026lt; m; ++i) { int u, k; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;u, \u0026amp;k); q[u].push_back({k, i}); } dsu(1, 0, 1); for (int i = 0; i \u0026lt; m; ++i) printf(\u0026#34;%d\\n\u0026#34;, ans[i]); return 0; } ","date":"2021-05-12T12:22:01+08:00","permalink":"https://example.com/2021/%E6%A0%91%E4%B8%8Adsu%E6%80%BB%E7%BB%93/","title":"树上dsu总结"},{"content":"背包问题总结 本文从dp总结中搬出\n背包问题是一类非常经典的动规问题，包括了01背包、完全背包、多重背包、混合背包、二维费用背包、分组背包、有依赖的背包问题、背包问题求方案数、背包问题求具体方案（称为背包九讲） 本片博客会在个人觉得比较重要的地方上啰嗦qwq 01背包 最最经典的背包问题，背包九讲中说到：“它包含了背包问题中设计状态、方程的最基本思想。另外，别的类型的背包问题往往也可以转换成01 背包问题求解。”，固01背包的模型是非常重要的 下面的01背包会展示三种空间的优化手段，我发现这三种优化手段都是非常重要的，针对不同场景三种手段各有优势 直接看到最原汁原味的题 【例题1】AcWing 2. 01背包问题 题意不多说，就是原汁原味的01背包题，值得说的是以下内容均以V为容量，W为价值，c为背包总容量\n分析1:\n对于每个物品有选和不选的两种决策，固我们可以从dfs的角度加上记忆化来思考这道题 可以考虑每一层都代表一个物品，有选和不选两种方案，意味着有两个递归下去的道路 其余细节具体看代码 1 2 3 4 5 6 7 8 9 10 //调用时直接调用dfs(n, m)就好了 int dfs(int nums, int sum) {//第nums个物品，还剩下sum的容量， if (nums == n + 1) return 0; // 边界 if (vis[nums][sum]) return dp[nums][sum]; // 记忆化 vis[nums][sum] = true; int \u0026amp;ans = dp[nums][sum]; ans = dfs(nums + 1, sum); //不选当前的物品，则容量依旧还剩sum if (sum \u0026gt;= v[nums]) ans = max(ans, dfs(nums + 1, sum - v[nums]) + w[nums]); // 如果容量够，则选当前物品，则容量剩余sum - v[nums] return ans; } 可以看得出来，dfs+记忆化的好处就是简单易懂，似乎完全不用过多说明代码的意义 分析2：\n本题递归+记忆化的好处就是易于思考，不需要过多地打草稿 但考虑到01背包经典性和别的背包问题都可以转换成01背包来解决，所以只会递归是不够的 根据上述分析1的内容，可以很容易定义状态：设dp[i][j]为决策到第i个物品时，还剩j容量的储存的最大价值 根据分析1的代码不难得出状态转移方程 $$ dp[i][j] = max\\lbrace dp[i + 1][j], \\ \\ dp[i + 1][j - v[i]] + w[i]\\rbrace \\ \\ (j \u0026gt;= v[i]) $$ 递推部分代码如下，答案为dp[1][m] 1 2 3 4 5 6 for (int i = n; i \u0026gt;= 1; i--){ for (int j = 0; j \u0026lt;= m; j++) { dp[i][j] = dp[i + 1][j]; // 不选 if (j \u0026gt;= v[i]) dp[i][j] = max(dp[i][j], dp[i + 1][j - v[i]] + w[i]); // 选，前提是空间够 } } 其实从第1件物品开始也是一样的 输出答案为dp[n][m] 1 2 3 4 5 6 for (int i = 1; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= m; j++) { dp[i][j] = dp[i - 1][j]; if (j \u0026gt;= v[i]) dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i]] + w[i]); } } 上面这个代码比逆着来递推的好处就是可以边读边计算，剩下了一些空间 1 2 3 4 5 6 7 for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;v, \u0026amp;w); for (int j = 0; j \u0026lt;= m; j++) { dp[i][j] = dp[i - 1][j]; if (j \u0026gt;= v) dp[i][j] = max(dp[i][j], dp[i - 1][j - v] + w); } } 复杂度都是$O(nm)$ 空间优化1：\n不难发现，当遍历到第$i$个物品时（顺着来递推），它利用到的状态只有上一个物品的状态，即第i - 1个物品的状态，则这个第一维完全可以用滚动数组来优化，即优化成$2 * Maxn$的数组 直接看代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int Maxn = 1010; int n, m, dp[2][Maxn] = {0}; int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); int now = 1, pre = 0; // 一个本状态，一个上一个状态 for (int i = 1; i \u0026lt;= n; i++) { int v, w; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;v, \u0026amp;w); fill_n(dp[now], dp[now] + m + 1, 0); // 这句话就01背包而言可以不用加，但在其他动规问题时可能就必须初始化了 for (int j = 0; j \u0026lt;= m; ++j) { dp[now][j] = dp[pre][j]; if (j \u0026gt;= v) dp[now][j] = max(dp[now][j], dp[pre][j - v] + w); } swap(pre, now); // 滚动 } printf(\u0026#34;%d\u0026#34;, dp[pre][m]); // 答案是推出循环后的pre维数组里的答案 return 0; } 这种写法的好处就是当我们在处理动规时发现他的只和上一个状态有关时就可以用这种优化，注意第19行的初始化有时候是必加的，例如在计数类dp中，我们就必须初始化当前计算的数组（即当前循环的now维数组）为0 下面两种优化个人感觉比本空间优化1要重要 空间优化2\n根据空间优化1， 我们再来看他的第二维，它会利用到$j - v[i]$的状态，计算完成后$j - v[i]$的状态就没用了 综上，看图 01背包空间优化\r所以完全可以将二维优化成一维的数组，为了保持$j - v[i]$是上一个物品的状态，第二层递推时要逆着过来递推 状态转移方程如下 $$ dp[j] = max(dp[j],\\ \\ dp[j - v] + w) $$\n上述的状态方程是对应边读边计算的 最终代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int Maxn = 1010; int n, m, dp[Maxn] = {0}; int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i++) { int v, w; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;v, \u0026amp;w); for (int j = m; j \u0026gt;= v; j--) { dp[j] = max(dp[j], dp[j - v] + w); } } printf(\u0026#34;%d\u0026#34;, dp[m]); return 0; } 说明：这里的二层循环是m到v，一来是因为j要大于等于v数组才有意义，二来是因为最开始是从c到0时，当$j \u0026lt; v$时只有不选当前物品的选择，则状态就会继承自一个物品此时的容量的状态，而此时代码是m到v默认了$j \u0026lt; v$时的状态时继承自上一个物品同容量的状态 本优化多用于分组背包中空间优化，树形背包（有依赖的背包），记住子问题是01背包时，一维空间优化必须逆着来（有基础的同学可以回忆一下树形背包中的转化 空间优化3\n下面介绍个人认为最最有用的空间优化手段 先来说说第一种空间优化的好处：好理解，不必像第二种空间优化那样需要逆着过来更新状态（相信我，考虑循环的顺逆，在比赛时真的可以把自己搞晕） 然而第一种空间优化也是有缺陷的：维度依然没有变化，即本来是二维的还是二维（这样的坏处就是多维时比较折磨人，想想树形背包，我们之所以可以用在定义状态时只开二维，是因为利用到了01背包一维优化的思想，更新时是逆着更新的，若要顺着更新，则可能会退化到三维，哪怕你第三位用滚动数组优化（第一种优化）可能也会被pre和now维度下标弄晕） 而第二种空间优化的好处和缺陷正好是第一种空间优化的缺陷和好处 综上，接下来要推出一个能集合上面两种优化的好处的优化手段 先看代码，感觉看了代码就能秒懂了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int Maxn = 1010; int n, m, dp[Maxn] = {0}, tmp[Maxn]; int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i++) { int v, w; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;v, \u0026amp;w); for (int j = 0; j \u0026lt;= m; ++j) tmp[j] = dp[j]; // 用tmp数组存起上一次的状态 for (int j = 0; j \u0026lt;= m; ++j) { dp[j] = tmp[j]; // 这句话可以不加，具体问题具体分析吧 if (j \u0026gt;= v) dp[j] = max(dp[j], tmp[j - v] + w); } } printf(\u0026#34;%d\u0026#34;, dp[m]); return 0; } 当然还有另一种写法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int Maxn = 1010; int n, m, dp[Maxn] = {0}, tmp[Maxn]; int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i++) { int v, w; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;v, \u0026amp;w); for (int j = 0; j \u0026lt;= m; ++j) tmp[j] = 0; // 用tmp数组来装本次要更新的状态，初始化具体问题具体分析，例如dp找到是最大值则初始化为负无穷 for (int j = 0; j \u0026lt;= m; ++j) { tmp[j] = dp[j]; if (j \u0026gt;= v) tmp[j] = max(tmp[j], dp[j - v] + w); } for (int j = 0; j \u0026lt;= m; ++j) dp[j] = tmp[j]; // 把值赋回给dp数组 } printf(\u0026#34;%d\u0026#34;, dp[m]); return 0; } 上述两种写法都是一个道理的，他们的好处就是依旧是顺推，依旧是一维 怎么说呢，我觉得这种写法是上面两种空间优化的进化版吧，不懂的可以看后面的依赖背包写法中利用到这种方式更新状态的好处，当然多重背包单调队列优化也用到了这个技巧 上面的01背包问的是容量不超过m的最大价值，但如果问的是容量恰好是m的呢？\n下面将不超过容量m名为问题一，容量恰好为m为问题二\n回忆以下不超过c的最大价值的状态定义：dp[i][j]表示正在考虑第i件物品还剩下j的容量所能装下的最大价值\n说解法之前，先来看这么一组数据，物品个数为4，背包容量为9，物品重量分别为{2，3，4，5}，价值分别为{3，5，2，6}，则在不超过9容量的最大价值为11，但恰好是9容量的最大价值为10，为什么反而价值还少了呢，其实在问题一中，背包装的容量为8，并没有装满，这就意味着在问题一中dp[9] = dp[8]，有一格空间是没有用上的，使得装9和装8的价值一样，那为什么会有这种情况呢\n下面是dp[9]和dp[8]在问题一中的真正转移路程 $dp[9] = dp[4(9 - 5)] + 6 = (dp[1(4 - 3)] + 5) + 6 = (0 + 5) + 6$ $dp[8] = dp[3(8 - 5)] + 6 = (dp[0(3 - 3)] + 5) + 6 = (0 + 5) + 6$ 注意到dp[1]在问题一中是为0的，上面说过为0则表示什么都不装，但是在问题二中，除了容量本来就是0的背包外其余容量的背包在什么都不装的情况下价值不能定义为0，为什么？因为这样在问题二中转移时为默认认为多出的1格（以上面的例子为例）是不装东西的\n怎么解决呢，根据上述的一句话“除了容量本来就是0的背包外其余容量的背包在什么都不装的情况下价值不能定义为0”，这样这样操作：dp[0] = 0，其余的都初始化为$-∞$\n还不理解就这样想：恰好容量m一定是从容量为0的状态一步一步转移过来的\n完全背包 紫书是先说完全背包问题的，紫书是从完全背包来引入背包问题的，可能是因为完全背包和硬币模型十分相似，都是DAG模型的题，和硬币模型最明显不同的是硬币模型起点和终点都是固定的，而完全背包是起点固定，终点任意的题 直接看例题 【例题1】AcWing 3. 完全背包问题 完全背包的裸题，题意就不再赘述了\n分析方式1：\n刚刚说了，完全背包和无限硬币模型（硬币无限个，问你能否组成特定的面值）相似，只不过呢和硬币模型DAG有两个不同的地方，一是硬币模型的起点是要求的面值和，终点是0，而完全背包的DAG的起点是要求的背包总容量，而终点是任意的；二是硬币模型的边权是1，而完全背包问题的边权是对应物品的价值，固之前硬币问题中的“+1”就要变成“+w[i]”了 回忆一下硬币模型的状态定义：dp[i]表示面值为i的最大（最小）凑的数量，转移方程是：$dp[i] = max \\lbrace dp[i - coin[j]] \\rbrace + 1, \\ \\ i \\ge coin[j]$，其中除dp[0]为0外，其余都初始化为$-∞$ 上面说过，硬币模型的DAG终点是0，但完全背包问题的终点是任意的，固完全背包应该对所有dp值都初始化为0（这个和01背包中的不超过容量m和恰好容量是m的道理是一样的），不难得出完全背包的转移方程 $$ dp[i] = max\\lbrace dp[i - v[j]]\\ \\ +\\ \\ w[j]\\rbrace ,\\ \\ i \\ge v[j] $$ 和硬币模型差不多其中dp[i]表示容量为i的背包能装的最大价值，输出答案为dp[m] 代码如下 1 2 3 4 5 6 memset(dp, 0, sizeof dp); for (int i = 0; i \u0026lt;= m; i++) { // 面值 对应完全背包的背包容量 for (int j = 1; j \u0026lt;= n; j++) { // 硬币 对应完全背包的物品 if (i \u0026gt;= v[j]) dp[i] = max(dp[i], dp[i - v[j]] + w[j]); } } 以上代码是仿照凑硬币模型写的，第一层循环和第二层循环是完全可以对调的 1 2 3 4 5 6 memset(dp, 0, sizeof dp); for (int j = 1; j \u0026lt;= n; j++) { for (int i = 0; i \u0026lt;= m; i++) { if (i \u0026gt;= v[j]) dp[i] = max(dp[i], dp[i - v[j]] + w[j]); } } 注意到，上面的代码第二层循环的起点完全可以改成从v[j]到m，然后if语句就可以删去了 至于最终答案也是dp[m] 1 2 3 4 5 6 memset(dp, 0, sizeof dp); for (int j = 1; j \u0026lt;= n; j++) { for (int i = v[j]; i \u0026lt;= m; i++) { dp[i] = max(dp[i], dp[i - v[j]] + w[j]); } } 时间复杂度为O(mn) 对于并非第一次接触完全背包的同学，是不是觉得上面的代码很像最终学到的代码呢，没错，上面的代码就是即将进入的分析方式2的最终结论 此时比较乱的同学可能有疑惑，第二重循环能否逆着来呢，答案是不行，细心的同学可能发现了，如果逆着过来就是01背包了 那么为什么不行呢，其实很简单，回到最开始完全背包的代码甚至是硬币模型的代码，我们是从0开始一步一步递推到最终目标m的，这样能推出最终答案，仔细想想也是，怎么可能是先从目标c开始推呢？ 分析方式2：\n对于完全背包，上面的分析1完全是够用的，但是就以背包问题而言，这样是不够的 考虑这么一个物品，其重量为v[i]，则它最多只能装m/v[i]个，这个很重要，这个结论意味着完全背包可以转换成01背包来做 将每个无限个的物品看成有限的m/v[i]个，然后当成01背包来做，设dp[i][j]表示对于第i件物品，容量为j转移方程如下 $$ dp[i][j] = max\\lbrace dp[i - 1][j],\\ \\ dp[i - 1][j - k \\times v[i]] + k \\times w[i]\\rbrace \\ \\ k = 1, 2, 3, 4 \\cdots $$ 其中k = 0时就是dp[i - 1][j]，这个转移方程之所以这么写是为了对应01背包的转移方程 相应的代码如下 1 2 3 4 5 6 7 8 9 memset(dp, 0, sizeof dp); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= m; j++) { dp[i][j] = dp[i - 1][j]; // 不选 for (int k = 1; k * v[i] \u0026lt;= m; k++) { //选 if (j \u0026gt;= k * v[i]) dp[i][j] = max(dp[i][j], dp[i - 1][j - k * v[i]] + k * w[i]); } } } 时间复杂度为O($m n\\times \\frac{m}{v[i]}$) 很遗憾TLE了，对转移方程做一下变换 $$ dp[i][j] = max\\lbrace dp[i - 1][j], dp[i][j - v[i]] + w[i]\\rbrace $$ 解释：将每种无限的物品看成一个一个的，当不选这种物品时，则决策为上一种物品容量相同时的状态，当选这一种物品的一个时，其由同种物品的$j - v[i]$的容量转移过来 换句话说：如果我选当前物品，则应该是当前物品背包容量还剩$j - v[i]$加上当前物品的价值，即我选了当前物品我还能继续考虑是否选当前物品 状态定义是不变的代码如下 1 2 3 4 5 6 for (int i = 1; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= m; j++) { dp[i][j] = dp[i - 1][j]; // 不选 if (j \u0026gt;= v[i]) dp[i][j] = max(dp[i][j], dp[i][j - v[i]] + w[i]); //选 } } 时间复杂度为O(nm)，这回Ac了 但同样是转换成01背包，为什么这个转移方程复杂度就降得如此低呢？说起来有点绕，如果下面解释完了还没明白可以自己草稿模拟两个代码或者一层一层递推状态方程，找到区别 假设我们考虑到dp[i][j]时，对于复杂度为O(cn)的转移，dp[i][j]由两个状态转移而来\n一是dp[i - 1][j]，表示不选当前物品，状态来自上一种物品的同容量状态 二是dp[i][j - v[i]] + w[i]，表示选当前物品，状态来自同种物品，小v[i]容量的状态而来 根据动态规划的原则，上一个状态一定是计算好并且是当前最优解的值 而对于复杂度为O($m n\\times \\frac{m}{v[i]}$)的话，dp[i][j]则由多个状态而来 基本都是由上一种物品对应$j - k \\times v[i]$容量的状态而来，即$dp[i - 1][j - k \\times v[i]] + k \\times w[i]$ 注意到在复杂度为O($m n\\times \\frac{m}{v[i]}$)中计算dp[i][j]时，用到了一个状态就是dp[i - 1][j - 2 $\\times$ v[i]]，而我们在计算dp[i][j - v[i]]时也用到了dp[i - 1][j - k $\\times$ v[i]]这个状态，假设dp[i][j-v[i]]的最终值就是来自于dp[i - 1][j - t $\\times$ v[i]]，则dp[i][j]就相当于也利用到了$dp[i][j - v[i]]$的值，固可以把众多的[i - 1]的状态归纳为[i]，其余的便可以反推归纳为dp[i - 1][j] 真相已经浮出水面了：在复杂度为O(mn)的算法里dp[i][j - v[i]]的值可能本来就包含了（装了）若干个值为v[i]的物品，这就避免了复杂度为O($m n\\times \\frac{m}{v[i]}$)算法中许多的max计算 再来说说完全背包的空间优化 和01背包一样，可以把二维优化成一维的，但值得注意的是：j - v[i]的第一维是i，和01背包的i - 1不同，固它用的不是上一层的数据，而是刚更新的同层的下标在j之前的数据，所以第二层于01背包不同，要顺着遍历，即从小到达遍历 代码与分析1中的最终代码是一样的 1 2 3 4 5 6 memset(dp, 0, sizeof dp); for (int j = 1; j \u0026lt;= n; j++) { for (int i = v[j]; i \u0026lt;= m; i++) { dp[i] = max(dp[i], dp[i - v[j]] + w[j]); } } 一个重要的优化 对于0(mn)的复杂度应该说是非常优秀的了，但是O($m n\\times \\frac{m}{v[i]}$)在不换转移方程的思路下还是有别的优化方式的，能优化到O($nmlog\\frac{m}{v[i]}$) 采用一种二进制的方式优化 考虑这么一个数10，现在要你拆分成几个数，使得能够用这些数自由组合能够组合成和为1~10的数。最简单的方式就是把10拆成10个1，就能将1~10都能凑出来了 但是如果只拆成10个1就没有优化的意义了，现在要你拆分成最少的数使得自由组合能凑成1~10的数，有一种比较优秀的拆分方式，拆分的结果为：1，2，4，3；怎么分的？观察到第一个数是$2^0$，后面除了最后一个数依次是$2^1、2^2$，最后一个数是$10 - 2^0 - 2^1 - 2^2 = 3$得到的 这样做的好处是，这4个数，每个数只有选和不选两种选择，一次对应4个位数的二进制的数，例如0101就是选了2，3，于是就凑成了5 原话是这么说的：“这是二进制的思想。因为，不管最优策略选几件第i 种物品，其件数写成二进制后，总可以表示成若干个$2^k$件物品的和” 至于价值当然也要变成对应的倍数价格啦 对于每个拆分出来的新物品只有选和不选的两种决策，不就是01背包了嘛 其余的有点难解释，看代码细细地品吧 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int Max = 1010; int n, m, dp[100005][Max], v, w; struct goods{ int v, w; goods(int v = 0, int w = 0) : v(v), w(w) {} }; vector\u0026lt;goods\u0026gt; good; int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); good.push_back(goods(0, 0)); for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;v, \u0026amp;w); int num = m / v; for (int j = 1; j \u0026lt;= num; j \u0026lt;\u0026lt;= 1) { num -= j; good.push_back(goods(j * v, j * w)); } if (num) good.push_back(goods(num * v, num * w)); } int len = good.size(); for (int i = 1; i \u0026lt;= len; i++) {//01背包代码 for (int j = 0; j \u0026lt;= m; j++) { dp[i][j] = dp[i - 1][j]; // 不选 if (j \u0026gt;= good[i].v) dp[i][j] = max(dp[i][j], dp[i][j - good[i].v] + good[i].w); // 选 } } printf(\u0026#34;%d\u0026#34;, dp[len][m]); return 0; } 假设对于每个物品平均最多只能装num件，则这个代码的复杂度为O($mnlognum$)，这样的优化完全足够ac的，当然还能做的就是像01背包一样把二维优化成一维的空间优化，在这里直接把第一维未知的大小直接省去，达到一个非常大的空间优化效果，固01背包代码就要换成这样、答案最终为dp[m] 1 2 3 4 5 for (int i = 1; i \u0026lt;= len; i++) {//01背包代码 for (int j = m; j \u0026gt;= good[i].v; j--) { dp[j] = max(dp[j], dp[j - good[i].v] + good[i].w); } } 多重背包 和01背包不同，01背包是每个物品都只有一个，但多重背包的每个物品都有若干个 【例题1】AcWing 4. 多重背包问题 I 题意不多讲，但是值得一提的是，多重背包被分为了三种等级，对应的数据范围不同，本题数据范围是三种之中最小的\n分析：\n当成完全背包里的分析方式2一开始介绍的思路来做，每个物品有$s_i$个，只需改一下第三重循环便可 下面的代码顺便把空间也优化了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int Maxn = 110; int n, m, dp[Maxn]; int main () { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i++) { int v, w, s; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;v, \u0026amp;w, \u0026amp;s); for (int j = m; j \u0026gt;= v; j--) {//01背包逆着来 for (int k = 1; k \u0026lt;= s \u0026amp;\u0026amp; k * v \u0026lt;= j; k++) { dp[j] = max(dp[j], dp[j - k * v] + k * w); } } } printf(\u0026#34;%d\u0026#34;, dp[m]); return 0; } 时间复杂度为O(mns)，速度比较慢，对于本题物品个数不超过100个，足够跑了 【例题2】AcWing 5. 多重背包问题 II 本题和【例题1】的题意是一样的，只不过数据范围直接大了一位数\n分析：\n再用刚刚的思想完全是不够用的了，直接TLE了 还记得完全背包的二进制优化吗吗，利用那个思想，就能优化成O($mnlogs$)的复杂度了 具体代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; struct goods{ int v, w; goods(int v = 0, int w = 0) : v(v), w(w) {} }; const int M = 2010; int dp[M], m, n; int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i++) { int v, w, s; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;v, \u0026amp;w, \u0026amp;s); vector\u0026lt;goods\u0026gt; good; for (int j = 1; j \u0026lt;= s; j \u0026lt;\u0026lt;= 1) {//二进制优化 s -= j; good.push_back(goods(j * v, j * w)); } if (s) good.push_back(goods(s * v, s * w)); for (auto g : good) {//01背包 for (int j = m; j \u0026gt;= g.v; j--) { dp[j] = max(dp[j], dp[j - g.v] + g.w); } } } printf(\u0026#34;%d\u0026#34;, dp[m]); return 0; } 总结：通过多次用到了01背包的思想可以看出01背包的重要性\n【例题3】6. 多重背包问题 III 题意和【例题1】也是一样，但这题的数据范围更大，达到了2e5 这题需要用到单调队列优化（单调队列是什么？自学吧） 仔细看下面我截取例题1时的代码的部分 1 2 3 4 5 for (int j = m; j \u0026gt;= v; j--) {//01背包逆着来 for (int k = 1; k \u0026lt;= s \u0026amp;\u0026amp; k * v \u0026lt;= j; k++) { dp[j] = max(dp[j], dp[j - k * v] + k * w); } } 不难发现$j$只会利用到$j - k \\times v$来转化，这就意味着$j$只会和与$j(mod \\ \\ v)$同余的$dp$容量来转移，例如$j = 9, v = 2$则他只可能会利用容量为$7,5,3,1$的$dp$来转移 同时注意到第二重循环的第一个循环条件$k \\le s$，这就意味着$j$利用到的与$j(mod \\ \\ v)$同余的容量的个数是有限的，不超过$s$个，例如$j = 9, v = 2, s = 2$时，则只可能会利用容量为$7,5$的$dp$来转移 综上，是不是觉得很像一个在固定窗口大小里面找一个最大值？ 直接先看代码，然后再解刨 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int M = 2e4 + 5, N = 1e3 + 5; int dp[M], tmp[M], q[M]; int main() { int n, m; scanf(\u0026#34;%d %d\\n\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; ++i) { int v, w, s; scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;v, \u0026amp;w, \u0026amp;s); for (int i = 0; i \u0026lt;= m; ++i) tmp[i] = dp[i]; for (int j = 0; j \u0026lt; v; ++j) { // 枚举余数 int l = 0, r = -1; // 单调队列的左右指针 for (int k = j; k \u0026lt;= m; k += v) { // 枚举容量 if (l \u0026lt;= r \u0026amp;\u0026amp; q[l] \u0026lt; k - s * v) ++l;// 窗口范围必须是[k - s * v, k - v] if (l \u0026lt;= r) dp[k] = max(tmp[k], tmp[q[l]] + (k - q[l]) / v * w); while (l \u0026lt;= r \u0026amp;\u0026amp; tmp[q[r]] + (k - q[r]) / v * w \u0026lt;= tmp[k]) --r; q[++r] = k; } } } printf(\u0026#34;%d\\n\u0026#34;, dp[m]); return 0; } 下面对代码进行解刨 首先，由于我们之前说的$j$在只会利用到比他小的同余数，所以我们转移时必选顺着转移，不能再逆着来了，这时就要用到之前01背包说的第三种空间优化来达到顺着转移的目的了 目光移到第16行代码（枚举余数），把相同余数的容量同时一起转移，固第18行的循环中是k += v这样就保证了每次的余数都是j（当前解说的代码的j） 然后就是第18行循环的内部循环了，首先学过单调队列的同学都知道，我们为了方便处理队列，我们在队列内存的不是对应的值，而是下标（在这题下标就是容量）。前面说到我们窗口的大小是有限制的，不能超过s个，固对应下标的范围就是$[k - s\\times v,k - v]$，固若q[l] \u0026lt; k - s * v则弹出队头元素 然后就是20行的简单易懂的更新操作，用上一个状态和当前选取(k - q[l])/v个当前物品的状态进行对比转移 21和22行都是单调队列的入队操作，队尾弹出的条件就是容量为q[l]的状态加上(k - q[r]) / v * w的价值都没有当前k容量的状态价值大（小于等于） 如此时间复杂度便优化到了O(nm) 混合背包 混合背包就是有些物品只能选1次，有些物品最多只能选s次，有些物品无限次，分别对应01背包，多重背包，完全背包 【例题】 混合背包问题 解决方法很简单，全部转化为01背包就好了，对于本来就是01背包的不作处理，对于多重背包的物品可以用二进制优化变成01背包，完全背包同理可以转化为最多只能选$\\frac{m}{v}$次的多重背包后再用二进制优化 代码略 二维费用背包 就是一个多了体积限制的背包罢了 【例题】 二维费用的背包问题 很简单，多加一维体积的数组，转移时和01背包相同 直接看代码就好了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int Maxn = 110; int n, V, M, dp[Maxn][Maxn]; int main () { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;V, \u0026amp;M); for (int i = 1; i \u0026lt;= n; ++i) { int v, m, w; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;v, \u0026amp;m, \u0026amp;w); for (int i = V; i \u0026gt;= v; i--) for (int j = M; j \u0026gt;= m; j--) dp[i][j] = max(dp[i][j], dp[i - v][j - m] + w); } printf(\u0026#34;%d\u0026#34;, dp[V][M]); return 0; } 分组背包 分组背包就是有若干组物品，对于每组物品都有若干件物品，每组物品最多选一个物品，问你容量不超过c的能装的最大价值 【例题】AcWing9. 分组背包问题 题意不多说，就是一个赤果果的分组背包问题\n分析：\n可以把每一组物品看成一个物品，然后当成01背包来做，不同的是对于每种容量的背包，都要考虑每组物品的每一个物品 也可以这么理解，对于每组物品，都假设只有一个物品，这一组物品就是一个物品了，然后不就是01背包了吗 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int Maxn = 105; int n, m, dp[Maxn]; int main () { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1 ; i \u0026lt;= n; i++) { int v[105], w[105], s; scanf(\u0026#34;%d\u0026#34;, \u0026amp;s); for (int j = 0; j \u0026lt; s; j++) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;v[j], \u0026amp;w[j]); } for (int j = m; j \u0026gt;= 0; j--) { //01背包 for (int k = 0; k \u0026lt; s; k++) { //假设当前组只有这一个物品 if (j \u0026gt;= v[k]) dp[j] = max(dp[j], dp[j - v[k]] + w[k]); } } } printf(\u0026#34;%d\u0026#34;, dp[m]); return 0; } 值得注意的是第18行和19行的for循环是不可以互换的，因为一维01背包是从大到小遍历的，保持小的下标是之前的数据。若是调换过来就相当于把每件物品都看成了一件物品，而不是隶属于某一组的物品 还有一点很重要的就是分组背包的思想可以迁移到树形背包（有依赖的背包问题）的\n有依赖的背包问题 就是一个树形背包，即如果要选一个结点，则其父亲节点必须要被选 【例题】 有依赖的背包问题 核心：把一个结点的每个孩子结点看做不同的组，即可以当成分组背包来自，那么组内的物品是什么呢，答案就是每组的一个决策就是一个物品（就这题而言就是每一个dp容量值就是一个物品），注意：这个思想很重要，他是所有（应该是所有）树形背包dp的共同特点 先看代码再解刨 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #define ll long long #define pb emplace_back using namespace std; const int M = 105, N = 1e3 + 5, inf = 1e9; vector\u0026lt;int\u0026gt; mp[M]; int root, n, m, dp[M][M], w[M], v[M], tmp[M]; int dfs(int u) { int sum = v[u]; // 记录本棵树的物品总重量 dp[u][v[u]] = w[u]; for (int son : mp[u]) { int siz = dfs(son);// 计算孩子节点的决策，并获取他的物品总重量 for (int i = 0; i \u0026lt;= min(m, sum + siz); ++i) tmp[i] = dp[u][i]; // 还记得01背包的空间优化3吗 for (int i = 0; i \u0026lt;= siz; ++i) { // 这棵孩子子树选取i容量的物品 for (int j = v[u]; j \u0026lt;= sum; ++j) { // 之前组选取的容量j if (i + j \u0026gt; m) break; // 超过背包容量的不用转移 dp[u][i + j] = max(dp[u][i + j], tmp[j] + dp[son][i]); } } sum += siz; } return sum; //返回本树的总容量 } int main() { scanf(\u0026#34;%d %d\\n\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; ++i) { int p; scanf(\u0026#34;%d %d %d\\n\u0026#34;, \u0026amp;v[i], \u0026amp;w[i], \u0026amp;p); if (p != -1) mp[p].pb(i);//存树 else root = i; } int ans = dfs(root); printf(\u0026#34;%d\\n\u0026#34;, dp[root][min(ans, m)]); return 0; } 核心就是dfs内的函数，就直接解刨里面的吧 先来解释dp的含义dp[u][v]表示在u结点这颗子树中选取容量为v的最大价值 13行不解释，14行的话很显然，由于要选本结点的子结点则本结点必选，所以就有了14行的初始化 然后是17行，这是之前在01背包中第三种空间优化的一种手段，这样做的好处有：1、更新本结点的dp时可以顺着来更新（好理解），2、可以防止不必要的转移（具体看第21行dp的第二维转移方式）且保证了整个复杂度不高于$O(nm)$，既保证了每个（点）都只会在题目的LCA上计算一次，否则可能会使复杂度退化到O($nm^2$)，后面会解释 然后就是转移思想可以参考树形背包思考模型 接下来状态转移，先说说为什么这样转移，需要提前知道的是下面两个转移方程会导致复杂度不同 $$ dp[u][j] = max(dp[u][j], \\ \\ dp[son][i] + dp[u][j - i]) \\tag{1} $$\n$$ dp[u][i + j] = max(dp[u][i + j],\\ \\ dp[son][i] + dp[u][j]) \\tag{2} $$\n有经验的小伙伴可能知道，式子(1)是填表法，式子(2)是刷表法。对于树形背包问题有个很玄学的优化就是利用刷表法来更新当前结点，这样就能保证复杂度是O($nm$)而不是O($nm^2$)，我的理解就是刷表法保证了本结点的合法性，并且使得所有结点都只会在他们的LCA上被算一次。反观填表法在有些题目上十分难以拿捏本结点的合法性 固以上就是我选择18行到23内部循环的方式的原因 没了 背包问题求方案数 题意就是让我们求01背包最优解的方案 【例题】 背包问题求方案数 多建立一个数组f[i][j]表示前i个物品选取容量为j的最优解方案数 注意初始化f[0][j]应当都初始化为1，因为是不超过m容量，所以这样初始化就保证了第一个物品转移有效 直接看代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;cctype\u0026gt; #define ll long long using namespace std; const int M = 1e3 + 5, N = 1e3 + 5, inf = 1e9, mod = 1e9 + 7; int n, m, dp[M][M]; ll f[M][M]; int main() { scanf(\u0026#34;%d %d\\n\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 0; i \u0026lt;= m; ++i) f[0][i] = 1; for (int i = 1; i \u0026lt;= n; ++i) { int v, w; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;v, \u0026amp;w); for (int j = 0; j \u0026lt;= m; ++j) { dp[i][j] = dp[i - 1][j]; // 不选 f[i][j] = f[i - 1][j]; //不选 if (j \u0026gt;= v) { if (dp[i - 1][j - v] + w == dp[i][j]) f[i][j] = (f[i][j] + f[i - 1][j - v]) % mod; //如果相等就相加 if (dp[i - 1][j - v] + w \u0026gt; dp[i][j]) { f[i][j] = f[i - 1][j - v]; // 否则更新值 dp[i][j] = dp[i - 1][j - v] + w; } } } } printf(\u0026#34;%lld\\n\u0026#34;, f[n][m]); return 0; } 当然此题也可以空间优化 背包问题求具体方案 题意是让我们求01背包最优解的一个具体方案，并且输出字典序最小的那个 【例题】背包问题求具体方案 求解具体方案如果只是随便找，则直接在转移结束后倒过来找就好了，但是题目要求的是字典序最小，那么我们要在转移顺序上做一些改动，即从最后一个物品到第一个物品转移，然后再贪心找字典序最小的方案就好了 一下递归找方案个人比较喜欢 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #define pb emplace_back using namespace std; const int M = 1e3 + 5, N = 1e3 + 5, inf = 1e9, mod = 1e9 + 7; int n, m, dp[M][M], v[M], w[M]; vector\u0026lt;int\u0026gt; ans; //记录答案 void solve(int num, int m) { if (m == 0 || num == n + 1) { for (int\u0026amp; v : ans) printf(\u0026#34;%d \u0026#34;, v); exit(0); //结束程序 } if (m \u0026gt;= v[num] \u0026amp;\u0026amp; dp[num][m] == dp[num + 1][m - v[num]] + w[num]) { // 如果符合转移 ans.pb(num);//记录答案 solve(num + 1, m - v[num]); ans.pop_back(); // 回溯 } solve(num + 1, m); } int main() { scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; ++i) scanf(\u0026#34;%d %d\u0026#34;, v + i, w + i); for (int i = n; i; --i) { for (int j = 0; j \u0026lt;= m; ++j) { dp[i][j] = dp[i + 1][j]; if (j \u0026gt;= v[i]) dp[i][j] = max(dp[i][j], dp[i + 1][j - v[i]] + w[i]); } } solve(1, m); return 0; } 注意，这题不能空间优化了 结语 写了好久好久，早就有把acwing上的背包总结博客写好的念头了，结果从开始计划到现在过了两三个月参完工，我太懒了。 这篇博客严格上来说其实并不是所有的背包问题的总结，还有其他背包中比较深究的问题，比如说求解背包问题求解次优解，第k优解等等比较深入的问题，太菜了没学。 就这样告一段落吧 ","date":"2021-03-26T12:22:01+08:00","permalink":"https://example.com/2021/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","title":"背包问题"},{"content":"前言 终于开始刷贪心了，感觉cf很多题都喜欢出贪心，所以决定也练练 贪心貌似也有挺系统的分类和一些经典例题，把这些刷了应该就有提升了把 总结 贪心是指将问题通过当前最优解来求解得到最终的最优解，即局部最优解可以推出总体最优解。 给我的感觉就是一种思维题，通过一定技巧把题目旁敲侧击地解决了，但是如果没接触过或者想不出来，基本就很难了，但是贪心的代码实现并不长，所以说贪心即使很基础的算法也是很难的算法。 总得来说贪心算法难就难在每道题的贪心策略都不同，是否能贪心也很难看出来。 一般在解决贪心题的时候可以把他放到生活中的例子来，想想如果是生活中碰到这题，你会怎么解决让自己最舒服。 普通贪心 例题1：HDU 2111 Saving HDU\n题意：你有可以装k个宝贝容量的包，现在给你一些宝贝，每个宝贝价值p，有m个，问你最多可以装多少价值的宝贝 思路：将价值排序，先选大的，选到v = 0为止 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int n, v; int main() { while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;v), v) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; for (int i = 0; i \u0026lt; n; i++) { int p, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;p, \u0026amp;m); q.push_back(make_pair(p, m)); } sort(q.begin(), q.end()); int i = n - 1, ans = 0; while (i \u0026gt;= 0 \u0026amp;\u0026amp; v) { if (q[i].second \u0026lt; v) { ans += q[i].first * q[i].second; v -= q[i].second; } else { ans += q[i].first * v; v = 0; } i--; } printf(\u0026#34;%d\\n\u0026#34;, ans); } } 例题2：HDU 3348\n题意：你有1、5、10、50、100的钞票，给你各个钞票的张数，问你要凑齐某价格最多和最少需要多少张，如果凑不出来输出-1 思路：最少的话就从大面值的钞票开始贪心，如果最后剩余需要凑的钱不为0，则凑不齐，至于最多的话，贪心可以这样想：要凑用得最多，那言外之意就是我剩余得最少，所以可以凑最少的贪心策略去凑所有钞票的总价格 - 需要凑的价格，最后剩下的钞票数就是需要凑的价格，固剩下的钞票数量就是最多的答案 总结：这道题的寻找最多的那个答案，一开始死活想不出来，后来看了大佬的思路恍然大悟，所以有所感悟：有时候一个问题顺着想可能很难，那不妨试试逆着来想，所谓正难则反 代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int corn[] = {1, 5, 10, 50, 100}, t, n, nums[6] = {0}; int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { int tmp = n, indx = 4, Max = 0, Min = 0, sum = 0, csum = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 0; i \u0026lt; 5; i++) { scanf(\u0026#34;%d\u0026#34;, nums + i); sum += nums[i] * corn[i]; csum += nums[i]; } while (tmp \u0026amp;\u0026amp; indx \u0026gt;= 0) { int num = tmp / corn[indx]; if (num \u0026gt; nums[indx]) { num = nums[indx]; } tmp -= num * corn[indx]; Min += num; indx--; } if (tmp != 0) { printf(\u0026#34;-1 -1\\n\u0026#34;); continue; } //需要凑的最大数目 tmp = sum - n, indx = 4; while (tmp \u0026amp;\u0026amp; indx \u0026gt;= 0) { int num = tmp / corn[indx]; if (num \u0026gt; nums[indx]) { num = nums[indx]; } tmp -= num * corn[indx]; Max += num; indx--; } printf(\u0026#34;%d %d\\n\u0026#34;, Min, csum - Max); } return 0; } 例题3：cf 230A Dragons\n题意：打龙了， 你目前要打n条龙，你的力量是s，你打一个龙的话你的力量必须比龙大，如果你打死一条龙你也可以获得相应的力量，问你是否能把所有的龙都打完 思路：一道很简单的贪心，先从力量小的龙开始打，看看能不能打完就好了 代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;vector\u0026gt; #define all(x) x.begin(), x.end() using namespace std; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; dr; int n, s; int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;s, \u0026amp;n); for (int i = 0; i \u0026lt; n; i++) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); dr.push_back(make_pair(x, y)); } bool win = true; sort(all(dr)); for (int i = 0; i \u0026lt; n; i++) { if (s \u0026gt; dr[i].first) { s += dr[i].second; } else { win = false; puts(\u0026#34;NO\u0026#34;); break; } } if (win) puts(\u0026#34;YES\u0026#34;); return 0; } 例题4：51Nod - 1117 聪明的木匠\n题意：一个木段，现要锯成$L_1, L_2, L_3 …… L_n$的长度，但是据一段木段需要消耗相应的体力，例如要把长为8的木段锯成 3 和 5 的话需要消耗3 + 5 = 8的体力，现在问你最少要消耗多少体力锯好 错误的思路：一开始想不出来，单纯的觉得是一个简短的排序不等式的的贪心题，只要先据出最大的目标值，然后一直据下去就是最优解，但这是不对的，最多也就过个他给的样例。 正确的思路①：仔细想想，如果是没按要求切成题目要求目标长度切，那样的话当然是希望一切下去可以让后面的体力没这么多，比如要分成2 2 3 3，这样的话应该是先 5 5 再 2 3 5 最后就 2 3 2 3这样就是最小的，消耗为20， 如果是按照先前的想法就是21，所以先前的思路显然是不对的。那这个思路怎么实现呢，dfs？显然很难实现 正确的思路②：回忆上上题的总结，正难则反，反过来想，现在把问题改成拼成一个完整的木段，消耗最小，这样的话就是拼当前最小的两小木段，最终的答案就是最小的 代码如下(注释的部分是一开始错误的思路，交上去才发现思路不对)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; using ll = long long; int n, arr[50010], sum[50010]; priority_queue\u0026lt;int\u0026gt; heap; int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 0; i \u0026lt; n; i++) { // scanf(\u0026#34;%d\u0026#34;, \u0026amp;arr[i]); int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); heap.push(-x); } int ans = 0; while (heap.size()) { int x = -heap.top(); heap.pop(); int y = -heap.top(); heap.pop(); ans += x + y; if (heap.size()) heap.push(-(x + y)); } printf(\u0026#34;%d\u0026#34;, ans); /* sort(arr, arr + n); for (int i = 0; i \u0026lt; n; i++) { sum[i + 1] = sum[i] + arr[i]; } ll ans = 0; for (int i = n - 1; i \u0026gt;= 1; i--) { ans = ans + arr[i] + sum[i] - sum[0]; } printf(\u0026#34;%lld\\n\u0026#34;, ans); */ return 0; } 例题5：HDU 6709 Fishing Master\n题意：钓鱼家有一个锅和一个鱼竿，他有 n 条鱼要钓，钓一条鱼需要 k 时间，他的任务就是把这些鱼都钓上来，并且把它们都煮了，第i条鱼的煮熟所需要的时间为$t_i$，他钓鱼的时候不能往锅里放鱼并且要等他掉好k时间才可做下一件事，他可以在煮鱼的时候钓鱼，他可以同时拥有很多鱼，即他钓好后可以放在身边，因为锅一次只能煮一条鱼。现在问你他至少要花多少时间煮好n条鱼。 思路： 一开始看错题，wa了一下午，英语太差的锅。回归正题，显然第一条鱼是钓的时间是不可避免的，全部煮鱼的时间也是不可避免的。可以优化的就只有钓鱼多出来的时间了。 注意到只要我煮的鱼时间足够长，那么我就可以在煮鱼的这个空档里面钓足够多的鱼，即可以钓$t_i / k$条，如果鱼快煮好了，即再过$x(x \u0026lt; k)$的时间就煮好鱼了，不难发现这里的$x = t_i % k$，那么这时候是继续钓鱼呢，还是选择去等鱼煮好然后放下一条（前提是你手上有钓好的鱼） 如果你选择继续钓鱼，那时间就会多花$k - t_i % k$的时间 如果你选择去等待的话，那你手上就必须要有鱼，没鱼怎么办，那只能选择上个选择，即继续钓鱼 画图出来可能比较直观 fishing master配图\r对于这个配图，即便是$t_i \u0026lt; k$公式依旧成立 显然，根据图，我们贪心的策略就是在煮鱼的空档里尽可能多地钓鱼,比如上图，就是钓2条，然后去等待鱼煮好就放下一条，假设这样下去我们总共在钓鱼的空档里钓的鱼数量为$num$ 正如上述第一条鱼钓的时间是不可避免的，所以接下来只剩下n - 1条鱼需要我们在煮鱼的空档时钓上来，假设$num \\ge n - 1$，即我们在空档里钓的鱼比我们需要钓的鱼还多，那最终答案就是$k + \\sum{t_i}$ 若$num \u0026lt; n - 1$，即我们在空档的时候钓的鱼不够我们需要钓的，那我们就要在煮鱼的空档多钓一条了，如上图就是钓3条，这样的操作需要我们进行$n - 1 - num$次，很显然，我们希望总时间尽可能地短，那就必须让$k - t_i % k$尽可能地小 对于上述的操作，代码里面只要用个数组mor记录$k - t_i % k$，然后再ans里面加上前$n - 1 - num$小的$k - t_i % k$就好了 这题说得有点多了，因为自己一开始真的觉得有点难 但是听说还有另一种解法就是一种我所不知道的带反悔的贪心法 具体做法就是将鱼根据他们的煮的时间从大小排序，并且按顺序这样钓上来 然后幻想自己顺畅无阻地把0到n - 1的鱼一个一个地煮并且可以在每条鱼煮好后可以马上放下一条鱼（即幻想自己每条鱼都能在其空档期间充分钓足够的鱼为下一次煮鱼做准备） 而现实却不尽人意，所以需要每次记录在煮鱼的空档期间总共可以钓的鱼$num$，如果$num$小于我们幻想钓的鱼的数量就反悔，即穿越时空去我在前面其中一个煮鱼的空档里面多钓一条鱼，这个空档的条件依旧是和我的思路一样，即$k - t_i % k$尽可能地小 这个需要优先队列，具体代码也放出来吧，但是这代码不是我自己写的，是直接复制某大佬的懒得自己再写了转载传送门 代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; using ll = long long; int t, n; ll k, tim[100005], mor[100005]; int main() { #ifndef ONLINE_JUDGE freopen(\u0026#34;test.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;test.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { scanf(\u0026#34;%d%lld\u0026#34;, \u0026amp;n, \u0026amp;k); for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%lld\u0026#34;, tim + i); } ll ans = k, num = 0; for (int i = 0; i \u0026lt; n; i++) { ans += tim[i]; num += tim[i] / k; mor[i] = k - tim[i] % k; } if (num \u0026lt; n - 1) { sort(mor, mor + n); for (int i = 0; i \u0026lt; n - 1 - num; i++) { ans += mor[i]; } } printf(\u0026#34;%lld\\n\u0026#34;, ans); memset(mor, 0, sizeof mor); memset(tim, 0, sizeof tim); } return 0; } //下面是大佬的代码 #include \u0026lt;bits/stdc++.h\u0026gt; #define INF 0x3f3f3f3f #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; using namespace std; typedef long long LL; const int mx = 1e5+7; int a[mx]; priority_queue\u0026lt;int\u0026gt; q; int main(){ int t, n, k; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--){ while (!q.empty()) q.pop(); scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); sort(a+1, a+n+1, greater\u0026lt;int\u0026gt;()); LL ans = k, num = 1; for (int i = 1; i \u0026lt;= n; i++){ ans += a[i]; num += a[i] / k; q.push(a[i] % k); if (num \u0026lt; i){ ans += k-q.top(); q.pop(); } } printf(\u0026#34;%lld\\n\u0026#34;, ans); } return 0; } 例题6：Bin Packing\n题意：给你n个物品，每个物品的重量为$w_i$，你有容量为w的背包，每个背包最多只能装两件物品，问你最少要多少背包来装\n贪心就好了，贪心策略：将物品按重量排序，如果最重和最轻的物品一起不超过w就放一起，然后就让次重和次轻的放一起；否则重的单独放在一个背包，然后让次重的背包和最轻的一起，以此循环 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int M = 1e5 + 5; int n, w, wi[M]; int main () { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;w); for (int i = 0; i \u0026lt; n; i++) scanf(\u0026#34;%d\u0026#34;, wi + i); sort(wi, wi + n); int l = 0, r = n - 1, ans = 0; while (l \u0026lt;= r) { if (wi[l] + wi[r] \u0026lt;= w) l++, r--; else r--; ans++; } if (t) printf(\u0026#34;%d\\n\\n\u0026#34;, ans); else printf(\u0026#34;%d\\n\u0026#34;, ans); } return 0; } 区间贪心 例题1：HDU 2037 今年暑假不AC\n题意：给你一些区间，让你选出尽量多的不相交的区间 思路：把所有区间（x, y）根据y来从小到大排序，然后从第一区间开始，排除和他相交的区间，即对比前一个选定的区间的y和当前要对比的区间的x，如果x \u0026lt; y则不选，否则回到上一步 看代码容易懂\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int n; int main() { while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;n), n) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; coo; int x, y; for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); coo.push_back(make_pair(y, x)); } sort(coo.begin(), coo.end()); int num = 0, last = -0x3f3f3f3f; for (int i = 0; i \u0026lt; n; i++) { if (last \u0026lt;= coo[i].second) { num++; last = coo[i].first; } } printf(\u0026#34;%d\\n\u0026#34;, num); } } 领项交换法 例题1：LOJ 加工生产调度\n题意：一个物品必须要先在A车间加工，才能在B区间加工个，问你n个物品最短的加工结束时间是多少\n思路：一道Johnso不等式的题，不知道也没关系，只要你会邻项交换法就能写\n首先假设只有两个产品要加工，其中一种最优解，两个下标分别为$i,j$，则其最终加工的时间为 $$ max(a_i + b_i, a_i + a_j) + b_j $$ 假设调换$i,j$，则最终的加工时间为 $$ max(a_j + b_j, a_j + a_i) + b_i $$ 此时我当然是希望以下等式成立 $$ max(a_i + b_i, a_i + a_j) + b_j \u0026lt; max(a_j + b_j, a_j + a_i) + b_i $$ 固我们直接这样排序就可以了(这就是邻项交换法)，当然网上还有对上式继续化简后的不等式，据说是Johnson不等式（我也不是很懂这个不等式，总之挺有意思的） $$ max(a_i + b_i, a_i + a_j) + b_j \u0026lt; max(a_j + b_j, a_j + a_i) + b_i $$ $$ \\Rightarrow max(b_i,a_j) + a_i + b_j \u0026lt; max(b_j, a_i) + a_j + b_i $$ $$ \\Rightarrow max(b_i,a_j) - a_j - b_i \u0026lt; max(b_j, a_i) - a_i - b_j $$\n$$ \\Rightarrow max(-a_j,-b_i) \u0026lt; max(-a_i, -b_j) $$\n$$ \\Rightarrow min(a_j, b_i) \u0026gt; min(a_i, b_j) $$\n以上式子均可以放到sort中作为排序的依据 ac代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; #include \u0026lt;cctype\u0026gt; inline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == \u0026#39;-\u0026#39;) f = true; c = getchar(); } while (isdigit(c)) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c - \u0026#39;0\u0026#39;); c = getchar(); } return f ? -x : x; } const int M = 1e5 + 5, N = 1000 + 5, inf = 0x3f3f3f3f; int n, m; #define ll long long struct pairs { int i, a, b; }p[N]; int main() { n = IO(); for (int i = 0; i \u0026lt; n; ++i) { p[i].i = i, p[i].a = IO(); } for (int i = 0; i \u0026lt; n; ++i) p[i].b = IO(); sort(p, p + n, [] (pairs \u0026amp;i, pairs \u0026amp;j) { return max(i.b, j.a) + i.a + j.b \u0026lt; max(j.b, i.a) + j.a + i.b; // return min(j.a, i.b) \u0026gt; min(i.a, j.b);//这个也可以 }); int ans = 0, a = 0, b = 0; for (int i = 0; i \u0026lt; n; ++i) { a += p[i].a; b = max(a, b) + p[i].b; } ans = b; printf(\u0026#34;%d\\n\u0026#34;, ans); for (int i = 0; i \u0026lt; n; ++i) { printf(\u0026#34;%d\u0026#34;, p[i].i + 1); if (i != n - 1) putchar(\u0026#39; \u0026#39;); } return 0; } ddl贪心 例题1：智力大冲浪\n一种简单型的$ddl$贪心问题，每个任务都是单位时间就能完成\n贪心方案：先讲扣的分数降序排序，再从其$ddl$时间开始往前找时间给他完成（因为要尽量空出前面的时间给后面的任务，换句话说就是让当前任务尽可能是接近$ddl$的时间之前完成），若找不到这个时间则扣这个扣款数\nac代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; #include \u0026lt;cctype\u0026gt; inline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == \u0026#39;-\u0026#39;) f = true; c = getchar(); } while (isdigit(c)) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c - \u0026#39;0\u0026#39;); c = getchar(); } return f ? -x : x; } const int M = 1e5 + 5, N = 1000 + 5, inf = 0x3f3f3f3f; // int a[M], sum[M]; int n, m; #define ll long long struct pairs { int t, w; }p[N]; bool day[N]; int main() { #ifndef ONLINE_JUDGE freopen(\u0026#34;D:/MYCODE/vsCode-c/test.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;D:/MYCODE/vsCode-c/test.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif m = IO(), n = IO(); int sum = 0; for (int i = 1; i \u0026lt;= n; ++i) p[i].t = IO(); for (int i = 1; i \u0026lt;= n; ++i) sum += p[i].w = IO(); sort(p + 1, p + 1 + n, [](pairs\u0026amp; i, pairs\u0026amp; j) { return i.w \u0026gt; j.w; }); for (int i = 1; i \u0026lt;= n; ++i) { for (int j = p[i].t; j; --j) { if (day[j]) continue; day[j] = true; sum -= p[i].w; break; } } printf(\u0026#34;%d\u0026#34;, m - sum); return 0; } 例题2：家庭作业\n这题是一道进阶版的ddl贪心问题，和智力大冲浪一样，只是数据范围大了很多\n首先思路和智力大冲浪是一样的，先做了分高的，时间从这个分高的$ddl$后往前遍历，看看有没有时间能做，能就加上这个分，不能就跳过\n但是由于这个$ddl$的是长度太长了，两重循环一定会超时的，所以，就要优化一下\n优化方案一（线段树）\n不难发现，我们上面的思路的第二重循环目的就是为了找从$1$到$ddl$时间里面最靠后的时间是多少 所以可以用一个线段树优化，即查找区间最大值 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; #include \u0026lt;cctype\u0026gt; inline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == \u0026#39;-\u0026#39;) f = true; c = getchar(); } while (isdigit(c)) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c - \u0026#39;0\u0026#39;); c = getchar(); } return f ? -x : x; } const int M = 1e6 + 5, N = 7e5 + 5, inf = 0x3f3f3f3f; int n, m; struct pairs { int t, c; }p[M]; int seg[N \u0026lt;\u0026lt; 2]; void build(int l, int r, int node = 1) { if (l == r) { seg[node] = l; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, node \u0026lt;\u0026lt; 1), build(mid + 1, r, node \u0026lt;\u0026lt; 1 | 1); seg[node] = max(seg[node \u0026lt;\u0026lt; 1], seg[node \u0026lt;\u0026lt; 1 | 1]); } void update(int index, int l, int r, int node = 1) { if (l == r) { seg[node] = 0; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (index \u0026lt;= mid) update(index, l, mid, node \u0026lt;\u0026lt; 1); else update(index, mid + 1, r, node \u0026lt;\u0026lt; 1 | 1); seg[node] = max(seg[node \u0026lt;\u0026lt; 1], seg[node \u0026lt;\u0026lt; 1 | 1]); } int get(int index, int l, int r, int node = 1) { if (r \u0026lt;= index) return seg[node]; int mid = (l + r) \u0026gt;\u0026gt; 1; int res = get(index, l, mid, node \u0026lt;\u0026lt; 1); if (index \u0026gt; mid) res = max(res, get(index, mid + 1, r, node \u0026lt;\u0026lt; 1 | 1)); return res; } int main() { n = IO(); int ans = 0, d = 0; for (int i = 0; i \u0026lt; n; ++i) p[i].t = IO(), p[i].c = IO(), d = max(d, p[i].t); sort(p, p + n, [] (pairs\u0026amp; i, pairs\u0026amp; j) { return i.c \u0026gt; j.c; }); build(1, d); for (int i = 0; i \u0026lt; n; ++i) { int maxv = get(p[i].t, 1, d); if (maxv) { ans += p[i].c; update(maxv, 1, d); } } printf(\u0026#34;%d\u0026#34;, ans); return 0; } 优化方案二 （并查集）\n上面用线段树无非就是为了找从$1$到$ddl$的最大值 这个过程其实可以用并查集来做，即初始化从$1$到$ddl$的时间里面最大值都是他们自己，当这个时间被用了之后，就让其父亲指向前一个时间 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; #include \u0026lt;cctype\u0026gt; inline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == \u0026#39;-\u0026#39;) f = true; c = getchar(); } while (isdigit(c)) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c - \u0026#39;0\u0026#39;); c = getchar(); } return f ? -x : x; } const int M = 1e6 + 5, N = 7e5 + 5, inf = 0x3f3f3f3f; int n, m; struct pairs { int t, c; }p[M]; int fa[N]; int findset(int x) { return x == fa[x] ? x : fa[x] = findset(fa[x]); } int main() { n = IO(); int ans = 0, d = 0; for (int i = 0; i \u0026lt; n; ++i) p[i].t = IO(), p[i].c = IO(), d = max(d, p[i].t); sort(p, p + n, [] (pairs\u0026amp; i, pairs\u0026amp; j) { return i.c \u0026gt; j.c; }); for (int i = 0; i \u0026lt;= d; ++i) fa[i] = i; for (int i = 0; i \u0026lt; n; ++i) { int maxv = findset(p[i].t); if (maxv) { ans += p[i].c; fa[maxv] = maxv - 1; } } printf(\u0026#34;%d\u0026#34;, ans); return 0; } 优化方案三（优先队列）\n这个优化方案在$loj$不开O2优化依然超时 而且这个优化方案其实不是对上面超时的思路进行优化，但是挺好的，只是被$loj$卡了罢了 思路：首先对于一个任务，它会影响它$dll$时间后面的任务，但是不会影响$ddl$之前的任务 所以可以让时间从后往前遍历，对于一个任务，我肯定是想让他在其$ddl$时间之前之内完成，最贪心的方式就是在$ddl$当天完成，腾出前面的空间让给别人。 但是如果是当前的时间，相同的$ddl$有多个任务，那我肯定是先让分高的先做了，如果还有（从后往前遍历时遗留下来没做的任务）比当前时间靠后的$ddl$任务，也是先让分高的先做。 固可以用优先队列来模拟上面的过程 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; #include \u0026lt;cctype\u0026gt; inline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == \u0026#39;-\u0026#39;) f = true; c = getchar(); } while (isdigit(c)) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c ^ 48); c = getchar(); } return f ? -x : x; } const int M = 1e6 + 5, N = 7e5 + 5, inf = 0x3f3f3f3f; int a[M]; int n, m; #define ll long long #include \u0026lt;queue\u0026gt; struct pairs { int t, c; }p[M]; priority_queue\u0026lt;int\u0026gt; heap; int main() { n = IO(); int ans = 0, d = 0; for (int i = 0; i \u0026lt; n; ++i) p[i].t = IO(), p[i].c = IO(), d = max(d, p[i].t); sort(p, p + n, [] (pairs\u0026amp; i, pairs\u0026amp; j) { if (i.t == j.t) return i.c \u0026gt; j.c; return i.t \u0026gt; j.t; }); for (int i = 0; d; --d) { while (i \u0026lt; n) { if (p[i].t \u0026lt; d) break; heap.push(p[i++].c); } if (heap.empty()) continue; ans += heap.top(); heap.pop(); } printf(\u0026#34;%d\u0026#34;, ans); return 0; } ","date":"2021-03-23T12:22:01+08:00","permalink":"https://example.com/2021/%E8%B4%AA%E5%BF%83%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/","title":"贪心刷题总结"},{"content":"主席树 简介 主席树是用来求区间第k大的一个可持续化数据结构 主要思想就是权值线段树+前缀和思想 几个问题 1. 用权值线段树+前缀和的原因 首先、如果我们要求一个固定区间的第k大，其中一个可以使用数据结构就是权值线段树 由于题目要我们求的是不定区间的区间第k大，我们可以用前缀和的思想建立和区间同长个数的权值线段树，这样当我们要求$[l, r]$的第k大的时候，我们就可以用第$r$个权值线段树 减去 第$l - 1$个权值线段树得到的权值线段树来求第k大 为了节省空间，我们可以使第$i$个和第$i - 1$个 权值线段树公用一些结点 2. 内存池 这个有点像链式前向星的思路，每次要添加新的边就++cnt，并让对应的边的下标为cnt 同理，我们可以在每次新加一个结点时，就++cnt，并让对应的结点的下标为cnt 可以把这里的cnt想象成我们在为新的指针申请地址时的地址号 3. 不同版本的权值线段树的存储 显然，我们要找一颗树，只需要找他的根结点就可以了 固我们可以记录每个版本（不同时间线）的权值线段树的根结点的内存池下标 4. 离散化 因为我们要建立的是权值线段树，固需要对数据进行离散化，本文的离散化做了预处理打表 结构体存放树的结点 利用结构体存放结点的好处就是访问方便，代码好写 1 2 3 4 5 6 const int N = 2e5 + 5; struct nodes{ int l, r, sum; // 左孩子的内存池编号、 右孩子内存池编号、 线段树的结点权值 nodes() : sum(0) {} }hjt[N \u0026lt;\u0026lt; 5]; // 开多点，一边都是32倍管够 int root[N], cnt; // 记录每个根结点的内存池编号， 内存池 建树 看AgOH的视频里面并没有加这个建树的操作，但是我觉得还是挺有必要加的，因为后面的一些可持续化数据结构能够用得上 初始建树其实可以想象成我们前缀和的第0项 1 2 3 4 5 6 7 8 9 int build(int l, int r) { int now = ++cnt; // 内存申请 if (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; hjt[now].l = build(l, mid); // hjt[now].r = build(mid + 1, r); // } return now; // 返回当前节点的内存池编号 } 插入新的权值 插入新的权值即新建一颗权值线段树 但注意，由于要复用之前的一些结点，固有些东西的写法和普通的权值线段树是不一样的，具体看代码 1 2 3 4 5 6 7 8 9 10 11 // 插入新节点的操作 int update(int pre, int l, int r, int x) { // 插入一个新的权值为x int now = ++cnt; // 内存申请 hjt[now] = hjt[pre], ++hjt[now].sum; // 继承上一个版本的结点，即复用，因为新加了一个值，所以结点权值+1 if (l \u0026lt; r) { // 寻找拼接点 int mid = (l + r) \u0026gt;\u0026gt; 1; if (x \u0026lt;= mid) hjt[now].l = update(hjt[now].l, l, mid, x); // 如果x在左边，则让当前新节点的左孩子接继承后的左孩子 else hjt[now].r = update(hjt[now].r, mid + 1, r, x); // 否则同理 } return now; } 主席树插入\r代码的第4行的第一语句就像是图中一个8号新节点用两个红色的边与连向1号结点的两个孩子 代码的第8行就像是图中将8号结点的右孩子边 \u0026ldquo;剪掉\u0026rdquo; 再用一个新的绿色边和下一个新结点相连 询问 查询是最后的操作了，具体做法主要的思想就是前缀和的思想 计算左孩子的$l, r$版本权值和的差，然后再对比 每次查询可以想象成只有一颗线段树上查找第k大 1 2 3 4 5 6 7 8 // 返回第qr版本的主席树 - 第ql版本的主席树， 注意返回的是离散化后的值 int get(int ql, int qr, int l, int r, int k) { if (l == r) return l; // 返回权值点上的权值 int mid = (l + r) \u0026gt;\u0026gt; 1; int dif = hjt[hjt[qr].l].sum - hjt[hjt[ql].l].sum; // 计算左孩子的版本权值和的差 if (k \u0026lt;= dif) return get(hjt[ql].l, hjt[qr].l, l, mid, k); // 答案在左孩子上 return get(hjt[ql].r, hjt[qr].r, mid + 1, r, k - dif); // 答案在右孩子上，记得这时是找第k - dif的 } 完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cctype\u0026gt; inline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == \u0026#39;-\u0026#39;) f = true; c = getchar(); } while (isdigit(c)) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c - \u0026#39;0\u0026#39;); c = getchar(); } return f ? -x : x; } using namespace std; /*************************************离散化********************************************/ // vt存放可用于查询原本的数（用离散化值），打表后用于查询离散化表（用下标） vector\u0026lt;int\u0026gt; vt; inline int get_id(const int \u0026amp;x) { return lower_bound(vt.begin(), vt.end(), x) - vt.begin() + 1; } inline void erase_vt() { sort(vt.begin(), vt.end()); vt.erase(unique(vt.begin(), vt.end()), vt.end()); } // 打表, 注意，原数组下标要从1开始，返回离散化后的表大小 inline int id_table(int n, int *a, vector\u0026lt;int\u0026gt; \u0026amp;res) { res.emplace_back(0); for (int i = 1; i \u0026lt;= n; ++i) res.emplace_back(get_id(a[i])); return vt.size(); } /*************************************主席树********************************************/ const int N = 2e5 + 5; struct nodes{ int l, r, sum; nodes() : sum(0) {} }hjt[N \u0026lt;\u0026lt; 5]; int root[N], cnt; // 记录每个根结点的内存池编号， 内存池 int build(int l, int r) { int now = ++cnt; // 内存申请 if (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; hjt[now].l = build(l, mid); hjt[now].r = build(mid + 1, r); } return now; } // 插入新节点的操作 int update(int pre, int l, int r, int x) { int now = ++cnt; // 内存申请 hjt[now] = hjt[pre], ++hjt[now].sum; // 继承 if (l \u0026lt; r) { // 寻找拼接点 int mid = (l + r) \u0026gt;\u0026gt; 1; if (x \u0026lt;= mid) hjt[now].l = update(hjt[now].l, l, mid, x); // 如果x在左边，则让当前新节点的左孩子接继承后的左孩子 else hjt[now].r = update(hjt[now].r, mid + 1, r, x); // 否则同理 } return now; } // 返回第qr版本的主席树 - 第ql版本的主席树， 注意返回的是离散化后的值 int get(int ql, int qr, int l, int r, int k) { if (l == r) return l; int mid = (l + r) \u0026gt;\u0026gt; 1; int dif = hjt[hjt[qr].l].sum - hjt[hjt[ql].l].sum; if (k \u0026lt;= dif) return get(hjt[ql].l, hjt[qr].l, l, mid, k); // 左孩子上 return get(hjt[ql].r, hjt[qr].r, mid + 1, r, k - dif); // 右孩子上 } /*************************************主函数********************************************/ int a[N]; int main() { int n = IO(), m = IO(); for (int i = 1; i \u0026lt;= n; ++i) a[i] = IO(), vt.emplace_back(a[i]); erase_vt(); vector\u0026lt;int\u0026gt; id; int siz = id_table(n, a, id); root[0] = build(1, siz); for (int i = 1; i \u0026lt;= n; ++i) root[i] = update(root[i - 1], 1, siz, id[i]); while (m--) { int l = IO(), r = IO(), k = IO(); printf(\u0026#34;%d\\n\u0026#34;, vt[get(root[l - 1], root[r], 1, siz, k) - 1]); } return 0; } ","date":"2021-03-23T12:22:01+08:00","permalink":"https://example.com/2021/%E4%B8%BB%E5%B8%AD%E6%A0%91/","title":"主席树"},{"content":"二分图 判图 利用染色法判\n1 2 3 4 5 6 7 8 9 10 11 12 // 未试过 bool dfs(int u, int c) { col[u] = c; for (int \u0026amp;v : gp[u]) { if (!col[v]) dfs(v, 3 - c); else if (col[v] == c) return false; } return true; } for (int i = 1; i \u0026lt;= n; ++i){ if (col[i] == 0) dfs(i, 1); } 最大匹配 匈牙利算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int match[M]; bool vis[M]; bool dfs(int u) { for (int \u0026amp;v : gp[u]) { if (vis[v]) continue; vis[v] = true; if (!match[v] || dfs(match[v])) { match[u] = v, match[v] = u; return true; } } return false; } // 主函数里 fill_n(match, n + 1, 0); // n是点的个数 for (int i = 1; i \u0026lt;= n; ++i) { if (match[i]) continue; fill_n(vis, n + 1, false); dfs(i); } ","date":"2021-03-15T12:22:01+08:00","permalink":"https://example.com/2021/%E4%BA%8C%E5%88%86%E5%9B%BE/","title":"二分图"},{"content":"FHQ Treap 简介 fhq treap主要有两个操作：分裂、合并 作为平衡树，他所有的平衡树操作都是基于这两个操作实现的 关于结点的存储与生成新的结点 由于一个结点要维护挺多信息的，所以用结构体来存储一个结点会比较好 如代码，存放的有：结点的权值、左孩子、右孩子、子树的大小、关键值（用随机函数赋值）,其中左右孩子值为0代表是叶子，即无内存池编号 1 2 3 4 const int N = 4e5 + 10; struct treap{ int val, l, r, size, key; }fhq[N]; 而生成一个新的结点和主席树的动态开点是有点像的，看代码就能懂了 1 2 3 4 5 6 int root, cnt; // 因为只有一棵树，所以只要一个root记录树的根节点就行了，cnt为内存池 mt19937 rnd(233); // 随机函数，头文件 random int new_node(int val) { fhq[++cnt] = {.val = val, .l = 0, .r = 0, .size = 1, .key = rnd()}; return cnt; } 注意，由于我们多维护了一个树的大小，固我们还要写一个更新结点的函数 1 2 3 inline void update(int now) { // 左孩子的大小 + 右孩子的大小 + 1 fhq[now].size = fhq[fhq[now].l].size + fhq[fhq[now].r].size + 1; } 分裂 分裂操作有两种 第一种是按照权值分裂，一边分裂成小于等于某个值的，另一边分裂成大于某个值的 具体细节看代码 1 2 3 4 5 6 7 void split(int now, int val, int \u0026amp;x, int \u0026amp;y) { // 分裂成x y两棵treap树 if (!now) { x = y = 0; return; } // 如果当前结点为空，则不作分裂 // 如果当前结点的值小于等于分裂要求的值，则让x树接上当前结点，并递归下去找当前结点的右孩子和y树应该拼接哪个结点 if (fhq[now].val \u0026lt;= val) x = now, split(fhq[now].r, val, fhq[now].r, y); else y = now, split(fhq[now].l, val, x, fhq[now].l); // 否则同理 update(now); // 因为分裂了，记得更新 } 第二种就是按照数的大小分裂 待补…… 合并 合并的话也不难 显然刚刚分裂时分裂出来的x和y，x树上的所有权值都小于y树上的权值 注：代码中的实现显然有y树上的结点永远只会接在x树上的右孩子上，即没有一步是往x树的左孩子走，x树接到y树也是同理，即最后合并好的树一定是一个合法的fhq平衡树 具体细节看代码（以大根堆为例：每个结点的值都大于其子结点） 1 2 3 4 5 6 7 8 9 10 11 int merge(int x, int y) { // 默认传入的x树的所有权值都小于y树上的所有权值 if (!x || !y) return x | y; // 大根堆 if (fhq[x].key \u0026gt; fhq[y].key) { //如果x的key值大于y的key值，则根据堆和平衡树的性质 fhq[x].r = merge(fhq[x].r, y), update(x); // 让x的右子树为（x的右子树和y合并的结果的根）， 记得更新结点 return x; // 返回合并后的根结点的内存池的编号 } // 否则同理 fhq[y].l = merge(x, fhq[y].l), update(y); return y; // 返回合并后的根 } 平衡树的基本操作 1、插入 首先先将整棵平衡树分裂成$\\le val$的x子Treap树和$\u0026gt;val$的y子treap树 然后再新建一个权值为$val$的结点 让x和新结点合并，再和y合并 1 2 3 4 5 inline void insert(int val) { int x, y; split(root, val, x, y); root = merge(merge(x, new_node(val)), y); } 2、按值删除 将整棵树分裂成x、y、z，分别为$\u0026lt;val$、$=val$、$\u0026gt;val$ 然后将y的根结点删除 最后再合并回去 1 2 3 4 5 6 7 inline void del(int val) { int x, y, z; split(root, val, x, z); // 分裂1 split(x, val - 1, x, y); //分裂2 y = merge(fhq[y].l, fhq[y].r); // 删除y的根结点 root = merge(merge(x, y), z); // 最后合并回去 } 3、按值获取排名 将整棵树分裂成x（$\u0026lt; val$）和y（$\\ge val$） $val$的排名就是x的数的大小+1 1 2 3 4 5 6 7 inline int getrank(int val) { int x, y, ans; split(root, val - 1, x, y); // 分裂 ans = fhq[x].size + 1; // 记录答案 root = merge(x, y); // 合并回去 return ans; } 4、按排名获取值 获取一个排名其实就是找一棵子树的左子树大小 + 1为rank 从根结点一直往下找就可以了 1 2 3 4 5 6 7 8 9 inline int getval(int rank) { int now = root; while (now) { if (fhq[fhq[now].l].size + 1 == rank) break; // 找到了 else if (fhq[fhq[now].l].size \u0026gt;= rank) now = fhq[now].l; // 在左子树上 else rank -= fhq[fhq[now].l].size + 1, now = fhq[now].r; // 寻找右子树记得改动排名 } return fhq[now].val;//最后的答案 } 5、求一个数的前驱或后继 找$val$的前驱只需要将整棵树分裂成x（$\u0026lt; val$）和y（$\\ge val$） 然后x树中的最大值就是$val$的前驱，一直往右子树找就可以了 后继的找法同理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 求前驱 inline int pre(int val) { int x, y; split(root, val - 1, x, y); int now = x; while (fhq[now].r) now = fhq[now].r; root = merge(x, y); return fhq[now].val; } // 求后继 inline int nxt(int val) { int x, y; split(root, val, x, y); int now = y; while (fhq[now].l) now = fhq[now].l; root = merge(x, y); return fhq[now].val; } 完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 // 洛谷板子题 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;random\u0026gt; #include \u0026lt;cctype\u0026gt; inline long long IO() { long long x = 0; bool f = false; char c = getchar(); while (!isdigit(c)) { if (c == \u0026#39;-\u0026#39;) f = true; c = getchar(); } while (isdigit(c)) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c - \u0026#39;0\u0026#39;); c = getchar(); } return f ? -x : x; } using namespace std; const int N = 4e5 + 10; mt19937 rnd(233); struct treap{ int val, l, r, size, key; }fhq[N]; int root, cnt; inline void update(int now) { fhq[now].size = fhq[fhq[now].l].size + fhq[fhq[now].r].size + 1; } int new_node(int val) { fhq[++cnt] = {.val = val, .l = 0, .r = 0, .size = 1, .key = rnd()}; return cnt; } void split(int now, int val, int \u0026amp;x, int \u0026amp;y) { if (!now) { x = y = 0; return; } if (fhq[now].val \u0026lt;= val) x = now, split(fhq[now].r, val, fhq[now].r, y); else y = now, split(fhq[now].l, val, x, fhq[now].l); update(now); } int merge(int x, int y) { if (!x || !y) return x | y; // 大根堆 if (fhq[x].key \u0026gt; fhq[y].key) { //右下角 fhq[x].r = merge(fhq[x].r, y), update(x); return x; } // 左下角 fhq[y].l = merge(x, fhq[y].l), update(y); return y; } // 插入 inline void insert(int val) { int x, y; split(root, val, x, y); root = merge(merge(x, new_node(val)), y); } // 按值删除 inline void del(int val) { int x, y, z; split(root, val, x, z); split(x, val - 1, x, y); y = merge(fhq[y].l, fhq[y].r); root = merge(merge(x, y), z); } // 按值获取排名 inline int getrank(int val) { int x, y, ans; split(root, val - 1, x, y); ans = fhq[x].size + 1; root = merge(x, y); return ans; } // 按排名获取值 inline int getval(int rank) { int now = root; while (now) { if (fhq[fhq[now].l].size + 1 == rank) break; else if (fhq[fhq[now].l].size \u0026gt;= rank) now = fhq[now].l; else rank -= fhq[fhq[now].l].size + 1, now = fhq[now].r; } return fhq[now].val; } // 求前驱 inline int pre(int val) { int x, y; split(root, val - 1, x, y); int now = x; while (fhq[now].r) now = fhq[now].r; root = merge(x, y); return fhq[now].val; } // 求后继 inline int nxt(int val) { int x, y; split(root, val, x, y); int now = y; while (fhq[now].l) now = fhq[now].l; root = merge(x, y); return fhq[now].val; } int main() { int t = IO(); while (t--) { int q = IO(), val = IO(); if (q == 1) insert(val); else if (q == 2) del(val); else if (q == 3) printf(\u0026#34;%d\\n\u0026#34;, getrank(val)); else if (q == 4) printf(\u0026#34;%d\\n\u0026#34;, getval(val)); else if (q == 5) printf(\u0026#34;%d\\n\u0026#34;, pre(val)); else printf(\u0026#34;%d\\n\u0026#34;, nxt(val)); } return 0; } ","date":"2021-03-09T12:22:01+08:00","permalink":"https://example.com/2021/fhq%E6%A0%91/","title":"FHQ树"},{"content":"寒假cf刷题 cf478B Random Teams(*1300) 求参赛员的朋友数 贪心就好，最少的情况就是均分，最多的情况就是其余m-1队都只有1人的情况 总结：找找规律，大胆猜测：最大和最小一定是两个极端。做的时候读不懂题目，后来靠样例猜出的题目的意思。 cf1463B Find The Array(*1400) 给定一个长度为n的数组a，总和为s，求一个同长的数组b，使其和给定的数组每个对应的数的绝对值即$a_i - b_i$的二倍小于等于s，并且对于每一对相邻的数$b_i$和$b_{i+1}$要么$b_i \\mod b_{i+1} == 0$要么$b_{i+1} \\mod b_i == 0$ 我的思路：不难发现目的就是为了使得$a_i - b_i$尽可能的小，那就很容易想到可以使其直接为0，然后又要满足相邻的可以被除的条件，则可是在奇数（或者偶数）下标取$a_i$，在偶数（或者奇数）下标取1，这样的话只需要求出给定数组的奇数下标的和与偶数下标的和，对比大小来决定到底是奇数放1还是偶数放1了 大佬的思路：对于b数组让每个数都是2的k次幂即$2^k,k\\ge0$，并且保证$2^k \\le a_i$ 总结：回归本质，思考题目设置的限制条件的意义，从那里出发思考，同时可以自己举例子 cf1453B Suffix Operations(*1400) 给一个数组，有操作：选取一个下标i，将i（包括i）之后的所有数加一或者减一，你有一次可以把任何数变换的机会，问你将所有数变成一样的最小操作数（不包括变换的那个操作） 去除那个变换的机会，（大胆猜测）不难发现如果要将所有数变成一样的，所需要的操作顺序是任意的，其最小的操作次数就是相邻两个数的差值的绝对值之和。对于那个把任意数变换的一次机会我们可以将一个数变成其前面的数或者后面的数以减小差值绝对值。做法求一下差值的绝对值的和，之后再暴力遍历每一个数，要么变成前面的数，要么变成后面的数，最后取一个最小值就行了 总结：将问题分解一步一步地找到解决问题的方法，还可以大胆猜想出一个结论出来，证明无误后，利用这个结论来解题 cf1408B Arrays Sum(*1400) 给一个单调不减的数组a，求一个数组组，数组组中的每个数组的也要是单调不减且不同数的个数不超过k，并且数组的下标i的总和正好为$a_i$，输出最小的数组组的大小，无解输出-1 纸上模拟，反向推演找数组组，不难发现若要个数不超过k，除了第一次，之后的每次最多能使k - 1个数变为0，而第一次能使k个数变为0（包括本来的0）。所以最终得到的公式就是$k + (k - 1) * num \\ge dif$，其中dif为a数组不同数的个数，num为答案。不难发现若$dif \u0026gt; k$则无解 总结：想清楚题目要我干嘛，寻找规律，大胆猜想，纸上推演，理清思路，排除不必要的干扰，防止思维混乱。 cf1393B Applejack and Storages(*1400) 起初你有n根木棍，有q询问，每次询问都添加一根或者去除一根，同时你要回答每次添加或者去除后能否组成一个正方形和一个长方形（正方形也是长方形） 正难则反，不难发现要一个正方形必须要4根同长的木棍，一个长方形要1对2根同长的木棍;我的做法：用三个set分别存放个数为1，个数为2和3的，个数为不低于4的，剩下的就是模拟了。大佬的做法：用两个变量记录个数是2的倍数的two，和个数为4的倍数的four，无论是询问还是原本有的木棍，假设成一根一根添加，一旦添加到为2的倍数则two自增，一旦添加到为4的倍数则four自增，最终答案就是$four \\ge 2$或者$four \\ge 1 \u0026amp;\u0026amp; two \\ge 3$就能达到目的 总结：我的思路是比较贴近现实生活中遇到此问题时我们会怎么解决来思考的，大佬的做法是在此基础上加上更加妙的实现做法 cf1365C Rotation Matching(*1400) 给你两个长度相等为n的排列数组a和b，问题经过平移后最多有多少个相等的数下标能对应上 仔细思考不难发现：假设平移b数组，并且只能向一个方向平移，若$a_i$和$b_j$相等，要使其位置对应，则平移的位置就是$(i - j + n) % n$，最终就是求相同平移量的个数最大值 总结：从本质出发，不用考虑太多算法，就是纯思维 cf1144D Equalize Them All(*1400) 给你一个数组，你能选择相邻的两个数$a_i$和$a_{i+1}$进行操作:$a_i = a_i + |a_i - a_{i+1}|$或者$a_i = a_i - |a_i - a_{i+1}|$，问你最小的操作数使得数组所有数都相等，输出方案 贪心就好，首先纸上推演，题中给的操作能够实现将一个数变成另一个数，然后就是大胆贪心，最小的操作次数一定是数组中所有的数最终变成原本数组的众数，利用发现的规律来使得所有数都变成那个数便可以了 总结：大胆猜想，然后验证，目前主要障碍就是读题，还有码代码时候优先选择思路清晰的码代码方式，基本内存可能很大，wa了之后人肉跑一遍代码检查，还是查不出就举反例 cf1355D Game With Array(*1400) 请你求一个长度为n的数组，其总和为s，输出一个k，使得你求的数组没有一个子数组的总和为k，若无解输出NO，否则输出YES和数组和k 仔细思考一下，贪心，最极端的就是n-1个1，设剩下一个就是x = s - (n - 1)，不难啊发现x到s范围的都可以组合出来，若$n - 1 \\ge x - 1$，则说明1到n-1都能组合出来，即无解，否则有解 大佬思路：让所有数都大于等于2，最后k = 1，便可。至于无解情况就是$s \u0026lt; n * 2$ 总结：大胆猜想，贪心，从极端情况考虑 cf1348B Phoenix and Beauty(*1400) 给你一个长度为n的数组a，求一个数组b，数组a是数组b的子序列，数组b的所有长度为k的连续子序列的和总是一样，有解输出数组b，无解输出-1 不难发现，要让b数组的长度为k的连续子数组和总是相等，其实只要让其一直循环长度为k的数组就好了，对于数组a是数组b的子序列也不难处理，显然若要有解就是a数组中的不同个数不得超过k 总结：这题不是很难，但是要注意细节，有些时候检查代码人肉跑一次是非常必要的，在一定不会超时的前提下怎么方便怎么来，stl放心用 cf1316B String Modification(*1400) 给你一个字符串，你可以操作：从左到右遍历，每k个就进行翻转。让你计算一个最小的k，操作后字典序最小 观察不难这样的操作，其实就是把从下标为k - 1开始到最后的子串平移到最前面，然后就是将0到k-2下标的补到后面，若k-1之后的个数为奇数，则需要将0到k-2的子串进行翻转再补到后面 总结：这题不难，但是字符串的处理有点麻烦，同上题一样，不超时放心用stl的东西 cf1270C Make Good(*1400) 给你一个数组a，让你添加不超过3个数，使得$a_1 + a_2 \u0026hellip; a_n = 2\\times(a_1 \\bigoplus a_2 \u0026hellip; \\bigoplus a_n)$ 纸上推演，利用异或的特性可以推出第一次异或本来的异或和使等式右边为0，再来就是异或左边加上刚刚的异或值的和，便是答案，可见这个方法只要加两个数便可以了 总结：本题不难，思考问题从位运算的特性中思考，还有就是注意此题会爆int cf1266C Diverse Matrix 你需要求出以个$r\\times c$的矩阵，并且对于矩阵的每一行每一列的最大公因数都不一样，让你求最小化这个矩阵中行列的最大公因数的矩阵 此题有点偏数学，在纸上推理，不难发现：最小的最大公因数一定是r + c，然后就是反向推演，不难发现对列和行从1到r+c编号，然后对于矩阵上的一个数要满足题意只需要求出对应编号的最小公倍数即可，但需要注意的是编号优先从行数和列数中小的开始，例如行数比列数少，则编号需要从行开始 总结：纸上推演，大胆猜想，然后简单验证和人肉debug ","date":"2021-01-12T12:22:01+08:00","permalink":"https://example.com/2021/%E5%AF%92%E5%81%87cf%E5%88%B7%E9%A2%98/","title":"寒假cf刷题"},{"content":"Color Length 题意：给你两个长度分别为$n、m(1 \\le n, m \\le 5000)$的字符串，让你求出组成新串的最小$l(c)$（具体组成方式看原题） 个人感觉这题很难，一度怀疑自己的能力和紫书题目的难易分布，最后费了九牛二虎之力终于想通为什么了，所以本文可能会花大篇幅来解释这题是怎么想的 思路：一开始看着有点LCS的影子，想着想着就写出了DP的递归函数，但是却死活想不出下一步怎么递归，即如下代码的$[]$片段 1 2 3 4 5 6 int DP(int a, int b) { if (vis[a][b]) return dp[a][b]; vis[a][b] = true; int \u0026amp;res = dp[a][b]; return res = min(DP(a - 1, b) + [], DP(a, b - 1) + []); } 显然，可以猜测dp方程是 $$ dp[i][j] = min(dp[i - 1][j] + ?_1, dp[i][j - 1] + ?_2) $$\n想了好久终于还是去看了别人的博客题解，没怎么看懂，于是看了许多人的博客题解，大概知道了一件事：这题的难点就在于求 $?_1 和 \\ \\ ?_2$，即需要预处理就出这个 $?_1 和 \\ \\ ?_2$\n先来说说这个 $?_1 和 \\ \\ ?_2$到底是什么东西\n首先，如果我们暴力直接来求这个 $?_1 和 \\ \\ ?_2$，，即每转移一次就求一次 $?_1 和 \\ \\ ?_2$，这样的话不仅麻烦，而且还不好想，最重要的是时间复杂度太大了 那么如何来理解这个转移所需要的 $?_1 和 \\ \\ ?_2$呢？这需要先了解dp代表的是什么意思： $dp[i][j]$代表的是：从字符串1中选取了前i个字符和字符串2中选取了前j个字符拼接成的字符产生的总$l(c)$值的最小值 举个例子，拿题目中给的GBBY和YRRGB，如果在字符串1中选取了G，从字符串2中选取了Y的话，则$dp[1][1]$就是1，代表G和Y在这种情况下（注意这个“这种情况下”，意味着如果换了两个只有第一个字符相同的字符串的话$dp[i][j]$的值可能就会不一样，这个很重要，现在先不说明，下面在解释 $?_1 和 \\ \\ ?_2$时会用上）的最小总$l(c)$为1 解释一下为什么是1，因为Y和G都还没有全部从字符串1和2中全部拿出来，即在字符串1和2中都还有未拿出来拼接的Y和G，则当前拼接成的字符串YG对未来拼接影响$l(c)$最小是$1(Y) + 0(G) = 1$（拼成GY的dp也是一样的值，即$1(G) + 0(Y) = 1$） 如果字符串2是选取了前3个即YRR的话，则最小的总$l(c)$值就是4，即$dp[1][3] = 4$，具体拼接方式是YRRG，因为R字母已经全部抽取了出来所以其$l(c) = 1$，总值就是$4 = 1(R) + 3(Y) + 0(G)$ 可能很难懂，没关系，当理解了 $?_1 和 \\ \\ ?_2$后可以再回来看这个dp的含义 说了这么多还是每开始说明 $?_1 和 \\ \\ ?_2$是什么东西，别着急，还需要几个要理解的： 用紫书上的说法就是：“当把一个颜色移到最终序列前，需要把所有“已经出现但还没结束”的颜色的$l(c)$值加1。更进一步地，因为并不关心每个颜色的$l(c)$，所以只需要知道有多少种颜色已经开始但尚未结束。” 一开始我就是一直在纠结怎么记录每种颜色在之前的拼接中放的位置，卡了很久 举个例子来说明紫书上的意思：还是那个题目中给的GBBY和YRRGB，假如现在已经拼接成了GY，则$dp[1][1] = 1$，接下来再从字符串2中抽出个R，则拼成的结果的$dp[1][2] = 3$（假如拼接成的是GYR），则分别加的两个值就是G加了1，和Y加了1，因为加了一个字母R导致字符串的长度加了1并且G和Y都没全部抽取出来，固都需要加一 若再从字符串2中抽取出R来的话，$dp[1][3] = 4$，可能有人会疑惑为什么是4而不是6，因为R和Y和G都要加1，总加的值就是3，所以答案不应该是$3 + 3 = 6$吗?，先冷静，还记得吗，dp的含义。我们拼接的应该是YRRG的样子才是最小值，这个时候R已经全部抽出来了，所以R值不用加1，完全可以计算他本身的$l(c)$值，所以总的$dp[1][3] = 3(Y) + 1(R) + 0(G) = 4$ 已经懂的可以跳过这一段的，原谅我再啰嗦一下，假如再从字符串2抽取一个G，则$dp[1][4] = 4(Y) + 1(R) + 1(G) = 6$，即G和R都已经全部抽取出来了，要加一的是Y，而G和R只需计算自身的$l(c)$就行了 发现没有至始至终Y的$l(c)$是一直在加一的，而其他的由于中途已经全部抽取出来了，固没有加一而是计算自身的$l(c)$值 到这里就可以解密?是什么了：$add[i][j]$代表从字符串抽取了前i个字符和从字符串抽取了前j个字符中已经出现但还没有全部抽取出来的字符有多少个 因为只有已经出现但还没有全部抽取出来的字符在我们不断地拼接新的字符的时候才要加一 关于$add[i][j]$的预处理转移方式： 首先是要记录每个字符在两个字符串中的开始和结束位置，这个目的是知道当前字符是不是已经出现但还没有全部抽取出来的字符 对于$add[i][j]$当$i \u0026gt; 1$并且$j \u0026gt; 1$时，其可以从两个方面转移过来，即$add[i][j - 1]$和$add[i - 1][j]$，可以这么想：从两个字符串中分别抽取前i、j个字符的前一个状态可以是从前两个字符串中分别抽取前i - 1、j或者前i、j - 1个字符的状态，对应分只要考虑字符串1的第i个字符是不是已经抽取完了或者字符串2的第j个字符是不是已经抽取完了，都是可以的，代码片段只会从一种中计算出来，而不是两种计算方式都用上我要最求速度 如果如果当前新拼接的字符是已经出现但还没有全部抽取出来的字符，则$add[i][j]$就自加一，如果是已经出现并且全部都抽取出来的字符，则$add[i][j]$就自减一 具体结果就是如图： uva1625\rdp前对add的预处理代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 struct strings{ int s, t; strings(int s = INF, int t = 0) : s(s), t(t) {} }; void init(char *a, char *b) { int n = strlen(a + 1), m = strlen(b + 1); strings aa[27], bb[27]; for (int i = 1; i \u0026lt;= n; i++) {//记录每个字符在字符串1中的开始位置和结束位置 strings \u0026amp;t = aa[a[i] - \u0026#39;A\u0026#39;]; t.s = min(t.s, i), t.t = i; } for (int i = 1; i \u0026lt;= m; i++) {//记录每个字符在字符串2中的开始位置和结束位置 strings \u0026amp;t = bb[b[i] - \u0026#39;A\u0026#39;]; t.s = min(t.s, i), t.t = i; } for (int i = 0; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= m; j++) { add[i][j] = 0; bool ok = true;//就计算一次add[i][j] if (i) { add[i][j] = add[i - 1][j]; int x = a[i] - \u0026#39;A\u0026#39;; if (aa[x].s == i \u0026amp;\u0026amp; bb[x].s \u0026gt; j) add[i][j]++;//如果是已经出现但还没有全部抽取出来的字符 if (aa[x].t \u0026lt;= i \u0026amp;\u0026amp; bb[x].t \u0026lt;= j) add[i][j]--;//如果是已经出现并且全部都抽取出来的字符 ok = false; } if (ok \u0026amp;\u0026amp; j) { add[i][j] = add[i][j - 1]; int x = b[j] - \u0026#39;A\u0026#39;; if (bb[x].s == j \u0026amp;\u0026amp; aa[x].s \u0026gt; i) add[i][j]++; if (bb[x].t \u0026lt;= j \u0026amp;\u0026amp; aa[x].t \u0026lt;= i) add[i][j]--; } // printf(\u0026#34;%d \u0026#34;, add[i][j]); } // puts(\u0026#34;\u0026#34;); } // printf(\u0026#34;%d\u0026#34;, aa[\u0026#39;R\u0026#39; - \u0026#39;A\u0026#39;].t); } 接下来就是dp的转移方程了\n$$ dp[i][j] = min(dp[i - 1][j] + add[i - 1][j], \\ \\ i \u0026gt; 0 \\ \\ ①, dp[i][j - 1] + add[i][j - 1], \\ \\ j \u0026gt; 0 \\ \\ ② ) $$\n注意①式和②式代表的含义是不同的，其中①式代表抽取前i、j个字符的之前状态时抽取前i - 1、j个字符的状态，即第i个字符一定是放在拼接后的最后一位，②式同理，给个转移图体会体会 uva1625\r还不懂的可以草稿纸模拟一下，从上面介绍dp内涵开始重看 最终ac代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int M = 5e3 + 10, INF = 0x3f3f3f3f; int add[M][M], dp[M][M]; struct strings{ int s, t; strings(int s = INF, int t = 0) : s(s), t(t) {} }; void init(char *a, char *b) { int n = strlen(a + 1), m = strlen(b + 1); strings aa[27], bb[27]; for (int i = 1; i \u0026lt;= n; i++) { strings \u0026amp;t = aa[a[i] - \u0026#39;A\u0026#39;]; t.s = min(t.s, i), t.t = i; } for (int i = 1; i \u0026lt;= m; i++) { strings \u0026amp;t = bb[b[i] - \u0026#39;A\u0026#39;]; t.s = min(t.s, i), t.t = i; } for (int i = 0; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= m; j++) { add[i][j] = 0; bool ok = true; if (i) { add[i][j] = add[i - 1][j]; int x = a[i] - \u0026#39;A\u0026#39;; if (aa[x].s == i \u0026amp;\u0026amp; bb[x].s \u0026gt; j) add[i][j]++; if (aa[x].t \u0026lt;= i \u0026amp;\u0026amp; bb[x].t \u0026lt;= j) add[i][j]--; ok = false; } if (ok \u0026amp;\u0026amp; j) { add[i][j] = add[i][j - 1]; int x = b[j] - \u0026#39;A\u0026#39;; if (bb[x].s == j \u0026amp;\u0026amp; aa[x].s \u0026gt; i) add[i][j]++; if (bb[x].t \u0026lt;= j \u0026amp;\u0026amp; aa[x].t \u0026lt;= i) add[i][j]--; } // printf(\u0026#34;%d \u0026#34;, add[i][j]); } // puts(\u0026#34;\u0026#34;); } // printf(\u0026#34;%d\u0026#34;, aa[\u0026#39;R\u0026#39; - \u0026#39;A\u0026#39;].t); } int DP(char *a, char *b) { int n = strlen(a + 1), m = strlen(b + 1); dp[0][0] = 0; for (int i = 0; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= m; j++) { if (i) { dp[i][j] = dp[i - 1][j] + add[i - 1][j]; } if (j) { if (i) dp[i][j] = min(dp[i][j], dp[i][j - 1] + add[i][j - 1]); else dp[i][j] = dp[i][j - 1] + add[i][j - 1]; } } } return dp[n][m]; } void solve(){ char a[M], b[M]; gets(a + 1), gets(b + 1); init(a, b); printf(\u0026#34;%d\\n\u0026#34;, DP(a, b)); } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); getchar(); while (n--) solve(); return 0; } ","date":"2020-09-07T20:44:19+08:00","permalink":"https://example.com/2020/uva1625/","title":"UVA1625"},{"content":"Partitioning by Palindromes 题意：给你一个字符串，让你求分割成最少回文串的数量，比如racecar最少就是1，fastcar就是7，aaadbccb就是3\n思路：\n说实话，不放到动态规划的专题我可能都不知道怎么做 提供一种比较好想的思路：记一个长度为$l$的字符串最大的分割数量就是$l$，如果说第$l$个字符和第$l - 1$个字符拼成的字符串是回文串，则分割数量就可以减少，即将$l - 1$ ~ $l$的字符串看成一个字符，固分割数减一，以此类推往前找能够看成单个字符的回文串来求出长度为$l$的字符串的最小的分割数 设dp[i]为从0i的字符串的最小分割数，当j + 1 ~ i是回文串时，其分割数就为dp[j] + 1，设isp[i][j]表示字符串下标从ij是否为回文串，状态转移方程为 $$ dp[i] = min{dp[j] + 1},\\ \\ isp[j + 1][i] = true $$ 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int dp[1005], len; bool isp[1005][1005]; char str[1005]; void check() { len = strlen(\u0026amp;str[1]) + 1; for (int i = 1; i \u0026lt; len; i++) { isp[i][i] = true; } for (int i = 1; i + 1 \u0026lt; len; i++) { isp[i][i + 1] = (str[i] == str[i + 1]); } for (int i = 2; i \u0026lt; len; i++) { for (int j = 1; j + i \u0026lt; len; j++) { if (str[j] == str[j + i] \u0026amp;\u0026amp; isp[j + 1][j + i - 1]) isp[j][j + i] = true; } } } void solve(){ memset(isp, 0, sizeof isp); memset(dp, 0x3f, sizeof dp); scanf(\u0026#34;%s\u0026#34;, \u0026amp;str[1]); check(); dp[0] = 0; for (int i = 1; i \u0026lt; len; i++) { for (int j = i; j \u0026gt; 0; j--) { if(!isp[j][i]) continue; dp[i] = min(dp[i], dp[j - 1] + 1); } } printf(\u0026#34;%d\\n\u0026#34;, dp[len - 1]); } int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while(T--) solve(); return 0; } ","date":"2020-08-31T19:20:38+08:00","permalink":"https://example.com/2020/uva11584/","title":"UVA11584"},{"content":"Lighting System Design 题意：你要设计一个一共需要n种不同电压灯泡的照明系统，不同种类的灯泡用不同的电源，同一种灯泡必须要用同一个电源，现在为了省钱，在亮度不减的前提下，可以用电压高的灯泡来换电压低的灯泡减小费用，现给你每种灯泡的电压V，电源费用K，每个灯泡的费用C，每种灯泡所需要的数量L，问你计算出最优的方案的费用\n思路：\n为了减少电压之间的比较可以对灯泡进行从小到大的排序，这样的话就可以默认是下标大的换下标小的 注意到对于一种灯泡，要不就全换掉，要不就全部都不换，不可能说最优的方案是当前这种灯泡只换一部分 设dp[i]表示当决策到第i种灯泡时的最优方案 将sum[i]表示前i种灯泡需要的总数量，相当于一个前缀和，则转移方程为 $$ dp[i] = max{dp[j] + (sum[i] - sum[j]) * c[i] + k[i]} $$ 解释：相当于是dp[i]的最优方案是第j + 1 ~ i种的灯泡都用第i种灯泡，然后再加上前j种灯泡中的最优方案，即dp[j] 因为每种灯泡的电压都是不一样的，所以这个方程的转移不用担心出现两种的灯泡的使用电压是一样但是电源或者灯泡的单价不一样的情况 再来就是第i种的灯泡在将前面的灯泡替换时一定是连续的，即j + 1 ~ i种是连续的不会出现断续的情况，因为如果出现断续的k（j + 1 ~ k - 1 和 k + 1 ~ i）的情况，则第k种灯泡替换成j + 1 ~ k的方案一定会比替换成i要优 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int n, dp[1010], sum[1010]; struct lamps{ int v, k ,c, l; lamps(){} lamps(int v, int k, int c, int l) : v(v), k(k), c(c), l(l) {} }lamp[1010]; int main() { while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;n), n) { for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;lamp[i].v, \u0026amp;lamp[i].k, \u0026amp;lamp[i].c, \u0026amp;lamp[i].l); memset(dp, 0x3f, sizeof dp); sum[0] = 0, dp[0] = 0; sort(lamp + 1, lamp + n + 1, [](lamps a, lamps b) { return a.v \u0026lt; b.v; }); for (int i = 1; i \u0026lt;= n; i++) { sum[i] = lamp[i].l + sum[i - 1]; } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= i; j++) { dp[i] = min(dp[i], dp[j] + lamp[i].c * (sum[i] - sum[j]) + lamp[i].k); } } printf(\u0026#34;%d\\n\u0026#34;, dp[n]); } return 0; } ","date":"2020-08-31T16:12:16+08:00","permalink":"https://example.com/2020/uva11400/","title":"UVA11400"},{"content":"Jin Ge Jin Qu hao 大致题意：在KTV里，如果还剩下1秒的时间，则可以点一首更长的歌，因为他会播放完最后一首歌才停止，现在给你剩下的时间$m$和$n(n \\le 50)$首歌，每首歌的时长$t_1, t_2, t_3 ……t_n$，现让你算出在剩余的时间内能唱的歌的最大数量，然后利用空出来的时间最后再点一首长为678秒的歌，输出能唱的最大数量，对应的时间 简单的分析： 题目中说最后会点一首678秒的歌来延长时间，则策略就是计算在不超过$m - 1$时间里选最多的歌 读一读上面的一句话，是不是感觉很想01背包？是的就是01背包问题，每个物品的价值默认是1了（一首歌嘛） 题目中说$m \\le 10^9$，其实并没有这么大，~~我一开始也很苦恼这怎么建数组，~~后来发现其实并没有这么大，他说n + 1首歌的时长严格大于剩余的时长，并且每一首歌不会超过3分钟，这么算的话$180 \\times 50 + 678 = 9678$，固数组完全够开 值得注意的是这题计算在选歌的数量多的前提下最后尽量晚地结束KTV，这就需要讨论了，一开始被这个搞得十分地晕，冷静下来后发现一个if是不够的，于是就特判3次 首先如果当前抉择的歌曲数量还没之前算的多，直接跳过 如果当前抉择的歌曲数量严格比之前算的还多，则更新歌曲数量和时间总长度 如果当前抉择的歌曲数量和之前算的一样多，则还要判断当前抉择的时长是严格比上次算还多，则更新时间总长度 具体看代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int n, t, dp[10010], m, kase = 0, sum[10010]; void solve() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); memset(dp, 0, sizeof dp); memset(sum, 0, sizeof sum); for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); for (int j = m; j \u0026gt; t; j--) { if (dp[j] \u0026gt; dp[j - t] + 1) continue;//特判1 if (dp[j] \u0026lt; dp[j - t] + 1) { //特判2 dp[j] = dp[j - t] + 1; sum[j] = sum[j - t] + t; } else if (sum[j] \u0026lt; sum[j - t] + t){//特判3 sum[j] = sum[j - t] + t; } } } printf(\u0026#34;Case %d: %d %d\\n\u0026#34;, ++kase, dp[m] + 1, sum[m] + 678); } int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { solve(); } return 0; } ","date":"2020-08-21T21:29:02+08:00","permalink":"https://example.com/2020/uva12563/","title":"UVA12563"},{"content":"Unidirectional TSP 大致题意：有个$m \\times n$矩阵，对于每个点你可以向直接向右、右上，右下走，第1行的上一行是第m行，第m行的下一行是第1行，问你从第一列的某一行出发，到达最后一列所经历的点的和最小是多少，并且打印出每一列的行号，如果有多解，输出字典序最小的\n简单的分析：\n可以看出是一个数塔问题的变种 书中说这种问题叫做多阶段决策问题中的一类——多阶段图的最短路问题，所谓多阶段图按书中说法就是图中结点可以划分成若干个阶段 这里我的理解就是原数塔问题也可以说是一个DAG，而这题相当于多个数塔重合的版本，固每一列都有对应着不用的阶段 计算最短路就是简单的数塔解法了 真正让人头疼的是最小字典序这里，一开始我的做法是写一大堆if判断，最后对比了一下刘老师的代码，妙不可言，用了大小为3的数组存下一列的决策行数 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int INF = 0x3f3f3f3f; int m, n, g[15][110], ans[15][110], Min, dp[15][110], f; bool vis[15][110]; int DP(int r, int c) { if (c == n) return 0; if (vis[r][c]) return dp[r][c]; int \u0026amp;res = dp[r][c], M = INF, \u0026amp;i = ans[r][c + 1], row[] = {r - 1, r, r + 1}; vis[r][c] = true, res = g[r][c]; if (r == 0) row[0] = m - 1; if (r == m - 1) row[2] = 0; sort(row, row + 3); for (int j = 0; j \u0026lt; 3; j++) if (M \u0026gt; DP(row[j], c + 1)) M = DP(row[j], c + 1), i = row[j]; res += M; return res; } int main() { while (~scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;m, \u0026amp;n)) { for (int i = 0; i \u0026lt; m; i++) for (int j = 0; j \u0026lt; n; j++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;g[i][j]); Min = INF; memset(vis, 0, sizeof vis); for (int i = 0; i \u0026lt; m; i++){ int tmp = DP(i, 0); if (Min \u0026gt; tmp) Min = tmp, f = i; } printf(\u0026#34;%d\u0026#34;, f + 1); for (int i = 1, j = ans[f][i]; i \u0026lt; n; j = ans[j][++i]) printf(\u0026#34; %d\u0026#34;, j + 1); printf(\u0026#34;\\n%d\\n\u0026#34;, Min); } return 0; } ","date":"2020-08-21T14:36:57+08:00","permalink":"https://example.com/2020/uva116/","title":"UVA116"},{"content":"The Tower of Babylon 题意：给你n种有无数个的立方体，现在让你用这些立方体堆一个塔，每个立方体的底面长宽都要严格小于下面立方体的底面长宽，问你最高能堆多高 简单的分析 能看得出来是一个矩形嵌套的变种问题，用DAG模型建立来做会非常好码代码 一种立方体有三种摆放方式，假设一个立方体的长宽高为a、b、c，则三种摆放方式分别是以a、b、c为高的摆放方式，固一种立方体可以看成三个立方体 下面就是建立DAG了，如果一个立方体的底面长宽严格大于另一个底面长宽的立方体则连一条有向边过去 最后就DP就是求从某个节点出发的最大距离就是答案 注意到，无论是思考还是码代码都不需要再去想状态方程来，直接当成一个图求最远距离来做，为了加速，我用了邻接表来建立图 下面是代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int n, kase = 0, head[100], cnt = 0, dp[500], vis[500]; struct rect{ int a, b, c; rect(){} rect(int a, int b, int c) : a(a), b(b), c(c) {} }r[100]; struct edges{ int to, next; edges(int to = 0, int next = -1) : to(to), next(next) {} }edge[10010]; bool ok(const rect\u0026amp; x, const rect\u0026amp; y) { return (x.a \u0026gt; y.a \u0026amp;\u0026amp; x.b \u0026gt; y.b) || (x.b \u0026gt; y.a \u0026amp;\u0026amp; x.a \u0026gt; y.b); } void add_edge(int u, int v) { edge[++cnt] = edges(v, head[u]); head[u] = cnt; } bool read() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); if (!n) return false; int x[3]; for (int i = 0; i \u0026lt; 3 * n;) { for (auto \u0026amp;j : x) scanf(\u0026#34;%d\u0026#34;, \u0026amp;j); r[i++] = rect(x[0], x[1], x[2]); r[i++] = rect(x[0], x[2], x[1]); r[i++] = rect(x[1], x[2], x[0]); } memset(head, -1, sizeof head); memset(edge, 0, sizeof edge); memset(dp, 0, sizeof dp); memset(vis, 0, sizeof vis); cnt = 0; for (int u = 0; u \u0026lt; 3 * n; u++) { for (int v = 0; v \u0026lt; 3 * n; v++) { if (u == v) continue; if (!ok(r[u], r[v])) continue; add_edge(u, v);//邻接表建图 } } return true; } int DP(int u) { if (u \u0026gt;= 3 * n) return 0; if (vis[u]) return dp[u]; int \u0026amp;res = dp[u], Max = 0; res = r[u].c, vis[u] = true; for (int v = head[u]; ~v; v = edge[v].next) {//它的下一个节点 Max = max(Max, DP(edge[v].to)); } return res += Max; } int main() { while (read()) { int ans = 0; for (int i = 0; i \u0026lt; 3 * n; i++) ans = max(ans, DP(i)); printf(\u0026#34;Case %d: maximum height = %d\\n\u0026#34;, ++kase, ans); } return 0; } ","date":"2020-08-21T09:46:38+08:00","permalink":"https://example.com/2020/uva437/","title":"UVA437"},{"content":"A Spy in the Metro 本篇是由DP总结中搬出的，目的是记录刷题进度 大致题意：一个线性的地铁，有$n(2 \\le n \\le 50)$个站，目标是在$T(0 \\le T \\le 200)$时刻从1号站到n号站，注是规定刚好T时刻，不是在T时刻之前也不是在T时刻之后，从1号点出发，可以在途中转乘，问你最少的中途等车时间 第i站到第i + 1站需要花的时间为$t_i$ 有$M1(M1 \\le 50)$个车从1号站出发，出发时间分别为$d_1, d_2, d_3……, d_{M1}\\ \\ (d_i \u0026lt; d_{i + 1}, d_i \\le 250)$，同样有M2个车从n号站出发，时间格式同上 其余细节看题 简单分析： 就看当先的状态，假设现在的时间是tim，正在第p个站有三种策略 等1分钟，剩下的下一分钟再说 如果有向1号站行的车，乘坐上去 如果有向n号站行的车，乘坐上去 那么这个是怎么建立DAG图的呢，对于每个点，定义它包括的属性有时间和站点，如果当前时间当前站点有开往下个一或者上一个站的车，则将到站的时间和对应的站点连一条有向的边，例如当前时间是15，站点是3，并且有开向第2站点的车，10单位的时间后到达，但没有向下一个站开的车，则在属性为（15，3）的节点连一条有向边到（25，2）的节点， 当然千万别忘了一点就是下1单位时间的同一站点也有一条边，即（15，3）到（16，3）也有一条有向边 然后就可以利用这个DAG图的节点属性来定义状态了，即设dp[p][tim]为在p站点tim时刻的状态，既然是求最小路，则状态就是到当前节点的最短路 对应三种策略的状态转移方式 当前的状态等于下一单位时间的状态加1的等待时间 当前状态等于到站后的时间和站点的状态 同上 最后取一个最小值 边界条件就是如果在T时刻和n站点刚好到达，则返回0，因为不用等了，如果超过了T时间，则说明是从某个站点到另一个站点后时间过了，则返回无穷大表示不用等了，如果刚好到T时刻且没到达n站点，则说明后面再怎么坐车时间也过了，也返回无穷大 说了这么多，却没写状态转移方程是因为打算使用记忆化来做，所有不用转移方程，直接考虑当前递归的来自哪些结果就好了 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int INF = 0x3f3f3f3f; int n, T, t[100], kase = 0, dp[110][210]; bool has_train[110][210][2], vis[110][210]; bool read() { int m, x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); if(!n) return false; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); for (int i = 1; i \u0026lt; n; i++) scanf(\u0026#34;%d\u0026#34;, t + i); memset(has_train, 0, sizeof has_train); memset(vis, 0, sizeof vis); scanf(\u0026#34;%d\u0026#34;, \u0026amp;m); for (int i = 0; i \u0026lt; m; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); has_train[1][x][0] = true; for (int j = 2; j \u0026lt;= n; j++) { has_train[j][x + t[j - 1]][0] = true; x += t[j - 1]; } } scanf(\u0026#34;%d\u0026#34;, \u0026amp;m); for (int i = 0; i \u0026lt; m; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); has_train[n][x][1] = true; for (int j = n - 1; j \u0026gt;= 1; j--) { has_train[j][x + t[j]][1] = true; x += t[j]; } } return true; } int DP(int p, int tim) { int \u0026amp;d = dp[p][tim]; if (tim \u0026gt; T) return INF; if (tim == T) return p == n ? 0 : INF; if (vis[p][tim]) return d; vis[p][tim] = true, d = INF; d = DP(p, tim + 1) + 1; if (p \u0026lt; n \u0026amp;\u0026amp; has_train[p][tim][0]) d = min(d, DP(p + 1, tim + t[p])); if (p \u0026gt; 1 \u0026amp;\u0026amp; has_train[p][tim][1]) d = min(d, DP(p - 1, tim + t[p - 1])); return d; } int main() { while (read()) { int ans = DP(1, 0); if (ans \u0026gt;= INF) printf(\u0026#34;Case Number %d: impossible\\n\u0026#34;, ++kase); else printf(\u0026#34;Case Number %d: %d\\n\u0026#34;, ++kase, ans); } return 0; } ","date":"2020-08-20T19:32:31+08:00","permalink":"https://example.com/2020/uva1025/","title":"UVA1025"},{"content":"1. 写在前面的话 之前写了一篇不像总结的动态规划总结，感觉更像是一个成长历程，所以就打算重写一篇。 2. 对DP简单的总结 dp的题目特点： 求最大或者最小值（如背包：价值最大、凑硬币：数量最少……） 计数（如：爬楼梯：计算上到n台阶的方法数） 求存在性或者胜负（如：能否胜利……） dp的使用条件 拥有子问题，子问题最优解（即拥有最优子结构），对于一个原问题解最优，其子问题必定也是最优，同时原问题的最优解依赖于其子问题的最优解 子问题重复性，一个子问题可能会影响多个不同的下一阶段的原问题 无后效性，即此时的之前状态无法直接影响未来的决策，换句话说就是之前的每个状态如何得来并不影响未来对此时（当前）状态的利用或者查找，因为我们最后对此时（当前）状态的利用只考虑结果不考虑过程。 dp的思考方式及注意事项 若问题有dp的味道，应当优先从主问题出发来思考，即从末尾（结果）开始思考（例如爬楼梯问题） 接下来，对于一个主问题，应当思考此问题的结果由什么得来（由什么决定、怎么决策等）和有什么因素影响 或者思考此问题类似什么DP题（如:背包、LIS……） 实在想不出可以思考如果是用dfs（或普通递归），应当如何解决问题（个人觉得有时候道理是相同的，记得吗：递归 + 记忆化 = 递推） 注意1：在思考一个状态的得来时，目光应当只集中在此时的状态（无后效性），而不要多想之前的状态变化和未来的状态影响 注意2：状态的定义很重要，要结合题目需求和状态影响因素来定义 关于dp三步走 1.状态定义 → 2.列状态转移方程 → 3.验证方程 对于第一步和第二步主要可以利用上述的思考方式或者是闫氏DP分析法来解决 第三步虽然不难，但是很重要，因为第三步包括：验证状态推理是否合理或者是否是答案最优，并且思考状态是否满足题目条件需求，前者均没问题后再思考边界是什么。对于一般验证发现有问题通常的解决办法有：1、修改状态定义；2、给状态增加维度；3、优化转移方程 补充的话 读了紫书上的动规篇才开始补这篇博客的坑 学到了很多东西，包括用记忆化搜索的优势、刷表法、DAG模型等等 所以有些代码写的不是递推的方式是为了练习记忆化式的递归 阅读了紫书动规篇后彻底抛弃了递推就一定比记忆化递归还快的观念，也使我再一次对自己当年总结的dp思考方式（递推 = 递归 + 记忆化）感到肯定 先来说说记忆化的优势： ①便于思考，有时完全都不用所谓的状态转移方程，只需要考虑当选状态下如何选择下一步的策略来进行码代码，在比赛的时候这个优势是非常大的 ②有些题无法用递推的方式来写，甚至状态都可能是无限的，这时候记忆化的优势将会进一步地放大 ③用记忆化不一定就比递推慢，仔细思考一下，有时候有些状态是不用计算的，而记忆化在这方面会比全部计算出来的递推要好，固速度不必递推差 记忆化的技巧 多开一个数组来做记忆化的操作比将状态数组定义成特殊值来判定是否又有算过好一些，不仅能够增强可读性，还更方便调试操作 如果状态做记忆化用另开数组的方式还是麻烦，不妨试试用map来存被算过的状态 用引用来调用状态数组可以简化代码 刷表法 和刷表法相对的是填表法，所谓填表法我的理解就是传统的利用之前选好的状态来计算当前的状态，书中是这么说的“对于每个状态i，计算f(i)，这需要对于每个状态i都找到f(i)的依赖的所有状态” 正如书中的一句话“在某些时候并不方便”，即找f(i)的所有依赖状态不好找，于是就诞生了刷表法 所谓刷表法，我的理解就是用计算好的状态更新它所影响到的状态，书中原话“对于每个状态i，更新f(i)所影响到的状态，但需要注意的是，只有当每个状态所依赖的状态对它的影响相互独立时才能用刷表法”，后半句话我也不是很理解，以后遇到了能理解的对应的题再说 DAG模型 动态规划能够概括出DAG模型是紫书动态规划篇给我最大的惊喜，巧妙地把我之前总结的那繁多的模型分类大大地再次概括了一遍 DAG模型有点像刷搜索题时一般，将题目抽象成一个有向无环图，然后求解最大距离或者是最小距离 个人感觉由于有时太过抽象，所有很难把它的图给抽象出来 3. 几个重要的模型 动规模型\r上图中有很多模型都可以归类为DAG模型（习得紫书后才了解到的），但是有些是完全可以单拿出来作为经典模型的 借用陈峰老师的一句话：子结构状态形成的如果是一棵树，不就是搜索了吗，如果是一个图，不就是动态规划了吗 原话是这个意思，感触很深，确实，有些题遇到了把他抽象出来如果是一颗树，基本应该优先考虑dfs、bfs等搜索操作，如果是一个图，即有重复的子结构，就可以考虑动规了 数塔模型 这个模型是许多人动规入门的题，变种不多，但是却很经典 【例题】HDU 2084 数塔 题意：有一个树形的塔，每个节点都有权值，让你求出从根节点到最后一层叶子节点的的最大权值和\n简单的分析\n这题是不能贪心的，即不能只选出当前最大的叶子权值 假设已经算好了第2层的节点的最大权值和，则第1层的节点（根节点）的最大权值就为第二层的两个节点的最大权值和加上第一层的权值 其余节点也可假设成第一层和第二层来思考 所以设$dp[ i][ j]$为第i层的第j个节点的最大权值和，边界条件就是最后一层的最大权值和就是其本身 状态转移方程如下 $$ dp[i][j] = max(dp[i - 1][j],\\ \\ dp[i - 1][j + 1]) + tree[i][j] $$\n发现空间还是可以优化的，因为当前层数的dp值利用的只有下一层的dp值，而数组的的第二维计算时利用的是后面的（j + 1）的值，所以第二维是下标小的先更新，下标大的后更新，所以完全可以把第一维抛弃掉，但这样的话dp下标循环起来必须是从小到大循环 状态转移方程如下 $$ dp[j] = max(dp[j], dp[j + 1]) + tree[i][j] $$\n代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int c, n; int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;c); while (c--) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int tree[110][110] = {0}; for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt;= i; j++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;tree[i][j]); int *dp = new int[n]; for (int i = 0; i \u0026lt; n; i++) { dp[i] = tree[n - 1][i]; } for (int i = n - 2; i \u0026gt;= 0; i--) for (int j = 0; j \u0026lt;= i; j++) dp[j] = max(dp[j], dp[j + 1]) + tree[i][j]; printf(\u0026#34;%d\\n\u0026#34;, dp[0]); } return 0; } 凑硬币模型 凑硬币模型是一个经典的模型，题目大概就是给你一个目标，你有许多不同的结构，你要用这些结构来组成这个目标，让你求最大组成量、最小组成量或者是组成方法数（组成方法数可以说是爬楼梯模型） 【例题1】leetcode 322 零钱兑换 大致题意：给你不同面额的硬币，让你输出凑成价值n的最小使用数量，若无法凑成则返回-1\n这题就是一个凑硬币的板子题\n简单分析：\n假如你有1 2 5的硬币，假设你已经求出$x$的最小使用数量$y$，则就能算出 $x + 1$ 、$x + 2$ 、$x + 5$ 的最小使用数量，即都为 $y + 1$ 设 $dp[ x]$ 表示价值为x的最小凑的数量，边界的话显然，$x = 0$ 时最小要凑的数量为 $0$，所以边界就是 $dp[ 0] = 0$ 所以不难得出状态转移方程 $$ dp[ x] = min \\lbrace dp[ x - coins[ i]] + 1 \\rbrace ,\\ \\ x \\ge coins[ i],\\ \\ i = 0, 1, 2 \\cdots $$\n代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: int coinChange(vector\u0026lt;int\u0026gt;\u0026amp; coins, int amount) { vector\u0026lt;int\u0026gt; dp(amount + 1, 0x3f3f3f3f); dp[0] = 0; for (int i = 0; i \u0026lt;= amount; i++) { for (auto c : coins) { if (i \u0026gt;= c) dp[i] = min(dp[i - c] + 1, dp[i]); } } if (dp[amount] == 0x3f3f3f3f) return -1; return dp[amount]; } }; 【例题2】leetcode 279 完全平方数 大致题意：平方数{1, 4, 9, 16 ……}，给你一个数n，让你用平方数组成该数，求最小组成数量\n简单的分析：\n把平方数看成硬币，然后就是硬币题了 状态转移方程一样的，直接上代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: int numSquares(int n) { vector\u0026lt;int\u0026gt; dp(n + 1, 0); dp[0] = 0; for (int i = 1; i \u0026lt;= n; i++) { dp[i] = dp[i - 1] + 1; for (int j = 2; i - j * j \u0026gt;= 0; j++) { dp[i] = dp[i] \u0026gt; (dp[i - j * j] + 1) ? dp[i - j * j] + 1 : dp[i]; } } return dp[n]; } }; LIS模型 LIS就是所谓的最长不下降子序列问题，变种不多，但很经典，所以直接看例题 【例题1】leetcode 300 最长上升子序列 题意：给定一个无序的整数数组，找到其中最长上升子序列的长度，注意严格上升\n简单的分析：\n分享一下一开始我学动规的时候LIS定义的状态是dp[i]表示下标为i的数组之前的最长上升子序列（即可以不选$nums[i]$），但是这样来定义我发现很难进一步地对状态进行转移，后来还是妥协了书中的状态定义方式 这件事现在看来也是有点感慨，因为现在的我明白：状态定义的不同，转移的方式可能也会完全不一样，所以有时候不同的状态定义会影响转移的难易程度，在思考一道动规题时，如果发现状态难以转移，不妨试试换个状态定义 设dp[i]表示选择下标为i的数为结尾的最长子序列，这样做的好处就是方便后面的转移，方便利用当前下标数和之前算好的dp状态的下标数进行对比大小，可以想象成当前状态是和之前算好的状态进行拼接 则转移方程为 $$ dp[i] = max\\lbrace 1,\\ \\ dp[j] + 1 \\ \\ | \\ \\ 0 \\le j \u0026lt; i, nums[j] \u0026lt; nums[i] \\rbrace $$ 不难发现，状态转移需要利用到下标为j的原数组的数，所以这个说明了状态定义就很重要了 最终的答案就是取其中的最大值 这种做法的时间复杂度是O($n^2$)，当然还有更快的速度可以达到O($nlogn$)，这里不再赘述了 dp代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: int lengthOfLIS(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int len = nums.size(), Max = 0; vector\u0026lt;int\u0026gt; dp(len, 1); for (int i = 0; i \u0026lt; len; i++) { for (int j = 0; j \u0026lt; i; j++) { if (dp[i] \u0026lt; dp[j] + 1 \u0026amp;\u0026amp; nums[j] \u0026lt; nums[i]) dp[i] = dp[j] + 1; } Max = max(Max, dp[i]); } return Max; } }; LCS模型 LCS就是最长公共子序列，也很经典 【例题1】AcWing 897. 最长公共子序列 题意：给你两个长度分别为n、m的字符串，让你求最长的公共子序列有多长\n简单的分析：\n设a序列的字符分别为$a_1, a_2,a_3……a_n$，b序列的字符分别为$b_1, b_2, b_3……b_m$ 假如序列a为ab，b为a，则他们的LCS就是1，注意到，如果b序列后面加个b变为ab，则LCS就是2，但如果加的是c变为ac，则LCS则还是1 设$dp[i][j]$表示a序列长度为i，b序列长度为j时的LCS，假设已经求出了之前的状态，则当$a_i = b_j$时，则$dp[i][j] = dp[i - 1][j - 1] + 1$，即LCS长度加一，但如果不相等，则$dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])$，不难看出这个转移方程的意义，下面上一个图更好理解 LCA递推图\r其中红色是a序列的各个字符，橙黄色是b序列的各个字符，表格中的数字是相对应的LCS 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int n, m, dp[1010][1010]; char a[1010], b[1010]; int main() { scanf(\u0026#34;%d%d%s%s\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;a[1], \u0026amp;b[1]); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { if (a[i] == b[j]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } printf(\u0026#34;%d\u0026#34;, dp[n][m]); return 0; } 背包模型 背包问题是经典的一类动规问题 篇幅过长已搬出（传送门） DAG模型 DAG模型是一个概括非常广的模型，它包括凑硬币模型、背包模型等等，但还是要写写，因为我觉得DAG更多的是一种思想，把DP问题抽象成一个DAG的图，便于思考 【例题1】UVA 1025 A Spy in the Metro 大致题意：一个线性的地铁，有$n(2 \\le n \\le 50)$个站，目标是在$T(0 \\le T \\le 200)$时刻从1号站到n号站，注是规定刚好T时刻，不是在T时刻之前也不是在T时刻之后，从1号点出发，可以在途中转乘，问你最少的中途等车时间\n第i站到第i + 1站需要花的时间为$t_i$ 有$M1(M1 \\le 50)$个车从1号站出发，出发时间分别为$d_1, d_2, d_3……, d_{M1}\\ \\ (d_i \u0026lt; d_{i + 1}, d_i \\le 250)$，同样有M2个车从n号站出发，时间格式同上 其余细节看题 简单分析：\n就看当先的状态，假设现在的时间是tim，正在第p个站有三种策略 等1分钟，剩下的下一分钟再说 如果有向1号站行的车，乘坐上去 如果有向n号站行的车，乘坐上去 那么这个是怎么建立DAG图的呢，对于每个点，定义它包括的属性有时间和站点，如果当前时间当前站点有开往下个一或者上一个站的车，则将到站的时间和对应的站点连一条有向的边，例如当前时间是15，站点是3，并且有开向第2站点的车，10单位的时间后到达，但没有向下一个站开的车，则在属性为（15，3）的节点连一条有向边到（25，2）的节点， 当然千万别忘了一点就是下1单位时间的同一站点也有一条边，即（15，3）到（16，3）也有一条有向边 然后就可以利用这个DAG图的节点属性来定义状态了，即设dp[p][tim]为在p站点tim时刻的状态，既然是求最小路，则状态就是到当前节点的最短路 对应三种策略的状态转移方式 当前的状态等于下一单位时间的状态加1的等待时间 当前状态等于到站后的时间和站点的状态 同上 最后取一个最小值 边界条件就是如果在T时刻和n站点刚好到达，则返回0，因为不用等了，如果超过了T时间，则说明是从某个站点到另一个站点后时间过了，则返回无穷大表示不用等了，如果刚好到T时刻且没到达n站点，则说明后面再怎么坐车时间也过了，也返回无穷大 说了这么多，却没写状态转移方程是因为打算使用记忆化来做，所有不用转移方程，直接考虑当前递归的来自哪些结果就好了 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int INF = 0x3f3f3f3f; int n, T, t[100], kase = 0, dp[110][210]; bool has_train[110][210][2], vis[110][210]; bool read() { int m, x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); if(!n) return false; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); for (int i = 1; i \u0026lt; n; i++) scanf(\u0026#34;%d\u0026#34;, t + i); memset(has_train, 0, sizeof has_train); memset(vis, 0, sizeof vis); scanf(\u0026#34;%d\u0026#34;, \u0026amp;m); for (int i = 0; i \u0026lt; m; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); has_train[1][x][0] = true; for (int j = 2; j \u0026lt;= n; j++) { has_train[j][x + t[j - 1]][0] = true; x += t[j - 1]; } } scanf(\u0026#34;%d\u0026#34;, \u0026amp;m); for (int i = 0; i \u0026lt; m; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); has_train[n][x][1] = true; for (int j = n - 1; j \u0026gt;= 1; j--) { has_train[j][x + t[j]][1] = true; x += t[j]; } } return true; } int DP(int p, int tim) { int \u0026amp;d = dp[p][tim]; if (tim \u0026gt; T) return INF; if (tim == T) return p == n ? 0 : INF; if (vis[p][tim]) return d; vis[p][tim] = true, d = INF; d = DP(p, tim + 1) + 1; if (p \u0026lt; n \u0026amp;\u0026amp; has_train[p][tim][0]) d = min(d, DP(p + 1, tim + t[p])); if (p \u0026gt; 1 \u0026amp;\u0026amp; has_train[p][tim][1]) d = min(d, DP(p - 1, tim + t[p - 1])); return d; } int main() { while (read()) { int ans = DP(1, 0); if (ans \u0026gt;= INF) printf(\u0026#34;Case Number %d: impossible\\n\u0026#34;, ++kase); else printf(\u0026#34;Case Number %d: %d\\n\u0026#34;, ++kase, ans); } return 0; } 【例子2】UVA 437 The Tower of Babylon 题意：给你n种有无数个的立方体，现在让你用这些立方体堆一个塔，每个立方体的底面长宽都要严格小于下面立方体的底面长宽，问你最高能堆多高\n简单的分析\n能看得出来是一个矩形嵌套的变种问题，用DAG模型建立来做会非常好码代码 一种立方体有三种摆放方式，假设一个立方体的长宽高为a、b、c，则三种摆放方式分别是以a、b、c为高的摆放方式，固一种立方体可以看成三个立方体 下面就是建立DAG了，如果一个立方体的底面长宽严格大于另一个底面长宽的立方体则连一条有向边过去 最后就DP就是求从某个节点出发的最大距离就是答案 注意到，无论是思考还是码代码都不需要再去想状态方程来，直接当成一个图求最远距离来做，为了加速，我用了邻接表来建立图 下面是代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int n, kase = 0, head[100], cnt = 0, dp[500], vis[500]; struct rect{ int a, b, c; rect(){} rect(int a, int b, int c) : a(a), b(b), c(c) {} }r[100]; struct edges{ int to, next; edges(int to = 0, int next = -1) : to(to), next(next) {} }edge[10010]; bool ok(const rect\u0026amp; x, const rect\u0026amp; y) { return (x.a \u0026gt; y.a \u0026amp;\u0026amp; x.b \u0026gt; y.b) || (x.b \u0026gt; y.a \u0026amp;\u0026amp; x.a \u0026gt; y.b); } void add_edge(int u, int v) { edge[++cnt] = edges(v, head[u]); head[u] = cnt; } bool read() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); if (!n) return false; int x[3]; for (int i = 0; i \u0026lt; 3 * n;) { for (auto \u0026amp;j : x) scanf(\u0026#34;%d\u0026#34;, \u0026amp;j); r[i++] = rect(x[0], x[1], x[2]); r[i++] = rect(x[0], x[2], x[1]); r[i++] = rect(x[1], x[2], x[0]); } memset(head, -1, sizeof head); memset(edge, 0, sizeof edge); memset(dp, 0, sizeof dp); memset(vis, 0, sizeof vis); cnt = 0; for (int u = 0; u \u0026lt; 3 * n; u++) { for (int v = 0; v \u0026lt; 3 * n; v++) { if (u == v) continue; if (!ok(r[u], r[v])) continue; add_edge(u, v);//邻接表建图 } } return true; } int DP(int u) { if (u \u0026gt;= 3 * n) return 0; if (vis[u]) return dp[u]; int \u0026amp;res = dp[u], Max = 0; res = r[u].c, vis[u] = true; for (int v = head[u]; ~v; v = edge[v].next) {//它的下一个节点 Max = max(Max, DP(edge[v].to)); } return res += Max; } int main() { while (read()) { int ans = 0; for (int i = 0; i \u0026lt; 3 * n; i++) ans = max(ans, DP(i)); printf(\u0026#34;Case %d: maximum height = %d\\n\u0026#34;, ++kase, ans); } return 0; } 【例题3】UVA 116 Unidirectional TSP 大致题意：有个$m \\times n$矩阵，对于每个点你可以向直接向右、右上，右下走，第1行的上一行是第m行，第m行的下一行是第1行，问你从第一列的某一行出发，到达最后一列所经历的点的和最小是多少，并且打印出每一列的行号，如果有多解，输出字典序最小的\n简单的分析：\n可以看出是一个数塔问题的变种 书中说这种问题叫做多阶段决策问题中的一类——多阶段图的最短路问题，所谓多阶段图按书中说法就是图中结点可以划分成若干个阶段 在递归过程中即将完成的决策被称为阶段，回忆解答树中星号之前的第一个数字，应该就是书中所说的阶段吧，或者说每个序就是一个阶段（因为在01背包中，一个物品有选和不选两种决策，每个物品序号可以看成一个阶段） 这题我的理解就是原数塔问题也可以说是一个DAG，而这题相当于多个数塔重合的版本，固每一列都是对应着一个的阶段，而每个阶段都有许多状态，每个状态都由上一个阶段能影响它的状态推得 引用《算法笔记》的话是这样的：“它可以描述成若干个有序的阶段，且每个阶段的状态只和上一个阶段的状态有关” 计算最短路就是简单的数塔解法了 真正让人头疼的是最小字典序这里，一开始我的做法是写一大堆if判断，最后对比了一下刘老师的代码，妙不可言，用了大小为3的数组存下一列的决策行数 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int INF = 0x3f3f3f3f; int m, n, g[15][110], ans[15][110], Min, dp[15][110], f; bool vis[15][110]; int DP(int r, int c) { if (c == n) return 0; if (vis[r][c]) return dp[r][c]; int \u0026amp;res = dp[r][c], M = INF, \u0026amp;i = ans[r][c + 1], row[] = {r - 1, r, r + 1}; vis[r][c] = true, res = g[r][c]; if (r == 0) row[0] = m - 1; if (r == m - 1) row[2] = 0; sort(row, row + 3); for (int j = 0; j \u0026lt; 3; j++) if (M \u0026gt; DP(row[j], c + 1)) M = DP(row[j], c + 1), i = row[j]; res += M; return res; } int main() { while (~scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;m, \u0026amp;n)) { for (int i = 0; i \u0026lt; m; i++) for (int j = 0; j \u0026lt; n; j++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;g[i][j]); Min = INF; memset(vis, 0, sizeof vis); for (int i = 0; i \u0026lt; m; i++){ int tmp = DP(i, 0); if (Min \u0026gt; tmp) Min = tmp, f = i; } printf(\u0026#34;%d\u0026#34;, f + 1); for (int i = 1, j = ans[f][i]; i \u0026lt; n; j = ans[j][++i]) printf(\u0026#34; %d\u0026#34;, j + 1); printf(\u0026#34;\\n%d\\n\u0026#34;, Min); } return 0; } 【例题4】UVA 12563 Jin Ge Jin Qu hao 大致题意：在KTV里，如果还剩下1秒的时间，则可以点一首更长的歌，因为他会播放完最后一首歌才停止，现在给你剩下的时间$m$和$n(n \\le 50)$首歌，每首歌的时长$t_1, t_2, t_3 ……t_n$，现让你算出在剩余的时间内能唱的歌的最大数量，然后利用空出来的时间最后再点一首长为678秒的歌，输出能唱的最大数量，对应的时间\n简单的分析：\n题目中说最后会点一首678秒的歌来延长时间，则策略就是计算在不超过$m - 1$时间里选最多的歌 读一读上面的一句话，是不是感觉很想01背包？是的就是01背包问题，每个物品的价值默认是1了（一首歌嘛） 题目中说$m \\le 10^9$，其实并没有这么大，我一开始也很苦恼这怎么建数组，后来发现其实并没有这么大，他说n + 1首歌的时长严格大于剩余的时长，并且每一首歌不会超过3分钟，这么算的话$180 \\times 50 + 678 = 9678$，固数组完全够开 值得注意的是这题计算在选歌的数量多的前提下最后尽量晚地结束KTV，这就需要讨论了，一开始被这个搞得十分地晕，冷静下来后发现一个if是不够的，于是就特判3次 首先如果当前抉择的歌曲数量还没之前算的多，直接跳过 如果当前抉择的歌曲数量严格比之前算的还多，则更新歌曲数量和时间总长度 如果当前抉择的歌曲数量和之前算的一样多，则还要判断当前抉择的时长是严格比上次算还多，则更新时间总长度 具体看代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int n, t, dp[10010], m, kase = 0, sum[10010]; void solve() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); memset(dp, 0, sizeof dp); memset(sum, 0, sizeof sum); for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); for (int j = m; j \u0026gt; t; j--) { if (dp[j] \u0026gt; dp[j - t] + 1) continue;//特判1 if (dp[j] \u0026lt; dp[j - t] + 1) { //特判2 dp[j] = dp[j - t] + 1; sum[j] = sum[j - t] + t; } else if (sum[j] \u0026lt; sum[j - t] + t){//特判3 sum[j] = sum[j - t] + t; } } } printf(\u0026#34;Case %d: %d %d\\n\u0026#34;, ++kase, dp[m] + 1, sum[m] + 678); } int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { solve(); } return 0; } 4. 分类 dp分类\r① 线性DP ② 区间DP 区间dp一般是将状态定义成某某区间内的某个解 一般遍历方式 1 2 3 4 5 6 7 8 9 10 11 for(int len = 1; i \u0026lt;= n; ++i) { // 先枚举区间长度 for (int i = 1, j = i + len - 1; j \u0026lt;= n; ++j, ++i) { // 再枚举起始节点 // } } for(int i = n; i \u0026gt;= 1; --i) { // 先枚举左端点 for (int j = i; i \u0026lt;= n; ++j) { // 再枚举右端点 // } } ③ 树型DP 来自2021.3.22的更新，回来看了一下，以前的写博客也太蠢了吧，不想改了，直接看下面几篇博客[放博客链接]\n所谓树状DP（树形DP）就是说一个动态规划的问题他的数据（或者子问题）之间是建立在树的基础上提问的，即父节点的最优是由其子节点的最优来推出来的（大部分是这样）。\n【例题1】HDU 1520 Anniversary party 大致题意：一棵树，一共有n个节点，父节点和子节点不能同时选，每个节点都有权值，问怎么选权值总和最大\n显然是要用到树DP了废话，给我的感觉有点像是一个变种的01背包问题不清楚\n简单的分析：\n对于一个节点有两种可能，选或者不选。那么我们就这样定义状态：dp[i][j], $1 \\le i \\le n$、 $0 \\le j \\le 1$，表示i节点的权值总和最大，$j = 0$表示不选择当前节点时的权值总和最大，$j = 1$表示选择当前节点时的权值总和最大\n当一个节点选了之后，那么它的所有子节点都不能选（当然它的父节点也不能选，但是考虑到我们这题用dp来解，为了不扰乱思维，我们只看它和它的子节点），看图： 父选子不选\r黄色为选，灰色为不选，父亲节点选了后，它下面的2、3、4、5、6……都不能选了（清楚明了），喂喂喂，你可别再想1号节点的父亲的事了，我们正在dp呢，它父亲节点以后它爷爷节点会搞定的，别再多想了，不然会扰乱思维。那么很容易得到这部分的转移方程(son[i]表示i的子节点, w[i]表示当前节点的权值)： $$ dp[i][1] = w[i] + \\sum dp[son[i]][0] $$\n如果这个节点不选呢？不说话，先看图： 父不选子选\r还是一样：黄色为选，灰色为不选。可能有人很奇怪：“哎呀，为什么儿子还有不选的情况，既然父亲都不选了，那么他的儿子全选不就总和最大了吗”。别急，且听我慢慢道来，如果这个是一条链，那么你这种想法可能就是对的，但这个是一棵树，之所以会有这个疑惑是因为我的图没上画完呢。 父选子不选补充\r说明：方形内的数字是节点的权值。显然如果要总和最大，那么5号节点就不能选，因为它的5号几点的子节点（8号节点）的权值更大（清楚明了😁）。所以又可以得到相应的转移方程： $$ dp[i][0] = \\sum max(dp[son[i]][1], dp[son[i]][0]) $$\n最后我这题采用的是自顶向下的递归来求的，最后根节点是通过回溯得来，当然如果喜欢自底向上的童鞋可以采用栈来遍历也可以哦。而我们的状态转移方程总结为 $$ dp[i][1] = w[i] + \\sum dp[son[i]][0]，\\ \\ (选择i节点) $$ $$ dp[i][0] = \\sum max(dp[son[i]][1], dp[son[i]][0]) \\ \\ (不选择i节点) $$\n那么最后的答案就是根节点的选和不选两状态的最大值,即 max(dp[root][1], dp[root][0])，（其余细节看注释）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; #define debug(n) printf(\u0026#34;(%d)\u0026#34;, n); using namespace std; const int N = 6e3 + 10; int n, l, k, w[N], dp[N][2]; vector\u0026lt;int\u0026gt; son[N]; void dfs(int r) { dp[r][0] = 0, dp[r][1] = w[r]; //初始化，方便转移时的求和 for (auto s : son[r]) { //遍历所有子节点 dfs(s); //先求子节点的最优 //↓然后回溯↓ dp[r][1] += dp[s][0]; //当前节点选 dp[r][0] += max(dp[s][0], dp[s][1]); //当前节点不选 } } int main() { while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;n) != EOF) { //不定组输入，输入节点数 vector\u0026lt;int\u0026gt; fa[N]; //记录节点的父亲，用来寻找根节点 for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, w + i); //输入节点权值 while (scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;l, \u0026amp;k) != EOF) { //输入节点之间的关系 if (l == 0 \u0026amp;\u0026amp; k == 0) break; //结束输入 son[k].push_back(l); fa[l].push_back(k); } //寻找根节点 int root = 1; for (int i = 1; i \u0026lt;= n; i++) { root = fa[i].size() == 0 ? i : root; } //开始转移 dfs(root); int ans = dp[root][1] \u0026gt; dp[root][0] ? dp[root][1] : dp[root][0]; printf(\u0026#34;%d\\n\u0026#34;, ans); //输出答案 //下面全是清空数组的代码，忽略就好 memset(dp, 0, sizeof dp); memset(w, 0, sizeof w); for (int i = 1; i \u0026lt;= n; i++) { for (auto it = son[i].begin(); it != son[i].end();) it = son[i].erase(it); } } return 0; } 平均时间复杂度应该是O($n$) 空间复杂度是O(n)，，应该不是O($ n ^ 2$),因为用的是vector。 【例题2】HDU 2196 Computer 大致题意：给你一个棵无向树，每个相连的节点之间都有个距离，即边有权，让你求出每个节点距离该节点的最远节点的距离。\n又是一道树状DP都放树状DP里了，怎么可能不是呢😂，但是这题是无向的，恰恰是因为这样给了一丝丝方便。\n简单的分析\n首先既然是无向，为了方便我们把他看作有向的，就设1号节点（1号电脑）是根节点，任性图方便。\n每个节点，他只有两种状态（除根节点，和叶子节点），一、要么是从它的子节点过来的距离；二、要么不是从它的子节点过来。如图不画了，自己脑补😂。\n那么我们就这样定义状态：dp[i][j], i表示的是节点编号（$1 \\le i \\le n$），而 j（$0 \\le j \\le 1$）的话就是，当 $j = 0$ 时表示 i 节点到其最远从属于它的叶子节点 （即他的子节点过来）的距离， $j = 1$ 时表示不是从它子节点过来的最远距离。\n对于从子节点到来本节点的距离，只需要对比大小便可，为了方便思考，我把题目的例子改了一下，如图（这回有图啊！！） 树状例题2图01\r说明：方形里的数字代表距离（边权）。不难看出从2号节点的子节点（7号节点、6号节点、3号节点）到2号节点的最大距离就是子节点到来的最大值（老规矩，别想他的父节点），有点拗口，看方程（son[i]表示 i 节点的子节点, len(son[i])则表示它的子节点到他它自己的距离）： $$ dp[i][0] = max\\lbrace dp[son[i]][0] + len(son[i])\\rbrace $$\n简单吧，下面就来看看比较难的：不是从他的子节点到来的最大距离。先上图（画的好累）： 树状例题2图ii\r清楚吧，不用解释了吧，好吧好吧，我们把目光放到3号节点上，如果计算不是从它子节点过来的距离的话，只有两种可能，其中最简单的一条路就是从它的爷爷节点来再到他的父亲节点来的距离（黄色箭头路线），为什么只有一条？因为它肯定只有一个爷爷和父亲，不可能有两个，不可能！！！这个世界还是很美好滴；第二种可能就是从它的兄弟节点来，这个比较多路（蓝色和绿色箭头路线），因为它可以有很多兄弟，也可以没有兄弟（独生子😁）。这样理解的话方程就能出来了（fa[i]表示 i 节点父节点，所以son[fa[i]]就代表 i 节点 的兄弟节点，len的含义和上面一样）： $$ dp[i][1] = max\\lbrace dp[fa[i]][1]+ len(i), dp[son[fa[i]]][0] + len(son[fa[i]]\\rbrace+ len(i)) $$\n化简一下 $$ dp[i][1] = max\\lbrace dp[fa[i]][1], dp[son[fa[i]]][0] + len(son[fa[i]])\\rbrace + len(i) $$\n解释：max内部的前者是上述的第一种可能，后者是第二种可能，是不是简单明了😁，但是对于这个状态还利用到来我们第一个讲的（$j = 0$）状态。所以我们在计算时要先把所有 $j = 0$ 的状态先计算，即做两遍dfs（当然你也可以把他们的dfs放到一起，都一样的，为了方便~~我不会😂~~我选择做两遍dfs），注意：这个状态方程的状态，即 $j = 1$ 时的状态一定要自顶向下计算，因为方程中还用到了它父亲的第二（$j = 1$）状态。所以最终的状态转移方程总结为： $$ dp[i][0] = max\\lbrace dp[son[i]][0] + len(son[i])\\rbrace， \\ \\ （第一种状态） $$ $$ dp[i][1] = max\\lbrace dp[fa[i]][1], dp[son[fa[i]]][0] + len(son[fa[i]])\\rbrace + len(i) \\ \\ （第二种状态） $$\n那么最后的答案是什么呢？显然就是每个节点的 $j = 0$ 和 $j = 1$ 的两种状态的最大值，即对于 i 节点 max（dp[i][0], dp[i][1]）。不废话，上代码（其余细节看注释）！！！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int M = 1e4 + 10; int n; vector\u0026lt;int\u0026gt; son[M]; //子节点不止一个，不放入结构体是为了方便清空数组 long long dp[M][2]; struct cpNode { //电脑节点结构体 int fa; //它爹是谁 long long len; // 它到它爹的距离 cpNode(int f = 0, long long l = 0) : fa(f), len(l) {} } cp[M]; void dfs1(int r) { //状态一 for (auto s : son[r]) { dfs1(s); dp[r][0] = max(dp[r][0], dp[s][0] + cp[s].len); } } void dfs2(int r) { //状态二 dp[r][1] = dp[cp[r].fa][1] + cp[r].len; //先把第二种状态的第一种可能算了，还记得吗因为它只有一个爹 for (auto bro : son[cp[r].fa]) { //遍历他的兄弟 if (bro != r) // 如果是它兄弟，即不是它自己 dp[r][1] = max(dp[r][1], dp[bro][0] + cp[bro].len + cp[r].len); } for (auto s : son[r]) dfs2(s); //计算它子节点的状态二 } int main() { while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;n) != EOF) { //多组输入，这设定把我坑惨了 for (int i = 2; i \u0026lt;= n; i++) { int f, len; // f为第 i 号节点的父亲， len是到它父亲的距离 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;f, \u0026amp;len); son[f].push_back(i); cp[i] = {f, (long long)len}; } dfs1(1); //第一状态的转移计算 for (auto s : son[1]) dfs2(s); //把除 1 号节点的节点都进行计算第二状态，因为 1 号节点只有第一状态 for (int i = 1; i \u0026lt;= n; i++) printf(\u0026#34;%lld\\n\u0026#34;, max(dp[i][0], dp[i][1])); //输出每个节点的结果 //清空数组，可以不看 memset(dp, 0, sizeof dp); for (int i = 1; i \u0026lt;= n; i++) { for (auto it = son[i].begin(); it != son[i].end();) it = son[i].erase(it); } } return 0; } 平均时间复杂度应该也是O($n$) 空间复杂度O(n) ④ 状态压缩DP 状态压缩更像是一种思想，而不是一种方法。当有些问题很可能不存在有效的(多项式级的)算法时，利用状态压缩是可以使得题目简单些。一般情况下状态压缩是把状态压缩成二进制的形式来表示（也有三进制的）一个集合，通过压缩可以把不必要的信息给去掉，从而减少冗余。 常见的二进制使用 都是最基础的：与、或、非、异或 在c++中分别是 \u0026amp;（与）、|（或）、!（非）、^（异或） 左右移：\u0026laquo; （左移），例如 5（00000101）\u0026laquo; 1 = 10（00001010）； \u0026raquo;（右移）,例如 5 （00000101）\u0026raquo; 1 = 2 (00000010)。 取反：~（1 变 0，0 变 1），例如 ~ 00000101 = 11111010 查看是否有相邻的 1（状压用得多，多用来去掉不合法的状态）：x \u0026amp; (x \u0026raquo; 1) == 0或者x \u0026amp; (x \u0026laquo; 1) == 0：语句判断为真则没有相邻的1，否则有相邻的 1。例如 88（01011000）\u0026amp; 44 (00101100) = 8 (00001000) $\\ne$ 所以有相邻的 1。（不懂就自己多举几个例子） 检查 a 是否是 b 的子集（状压也用得多）：a \u0026amp; b == a：语句判断真为是其子集，否则不是。例如 88 是 16 的子集，因为88（01011000）\u0026amp; 16（00010000）= 16（00010000） 判断 a 和 b 是否有相同位的 1：a \u0026amp; b == 0：语句判断真为没有，否则有，很简单不解释 取末尾的 1：x \u0026amp; (-x)，例如 88（01011000）^ (-88)（10101000）= 8（00001000）——多用于树状数组 【例题 1】HDU 方格取数（1） 大致题意：给你一个方格，里面有数字，你可以在这些方格里面取数，但是不能取拥有公共边的方格，问你取出来的最大值为多少\n一道挺标准的状压dp板子题，一开始用普通dp没做出来，后来发现用状压真的简单一些\n简单的分析\n对于每个格子只有两种状态：选或者不选，我们定义选中了则在相应的二进制位数为 1，否则为 0。例如5 （000101）表示一行中第一个数和第三个数被选中 对于一行有 n 个格子的总共的选择方式个数为 $2^n$ 既然都说了状压，那直接开压：把列压缩（对于这题行和列相同，压列是个人喜欢，更多情况下是压缩数据范围小的那个，你当然希望$2^n$越小越好啦） 下一步在输入之前把不合法的状态预处理了，只留下合法的，就是本题所说的不能选取拥有公共边的格子，即对于每一行状态不能有相邻的 1 然后是转移方程（很简单，并且不难想） $$ dp[i][now] = max\\lbrace dp[i - 1][pre] + w[now]]\\rbrace $$\n解释：i 表示第 i 行，now 表示当前行的二进制状态，pre 表示上一行的所有不与 now 具有相同位 1 的状态，可以用相与（\u0026amp;）是否等于 0 来判断，若等于 0 则没有相同我位的 1，否则有；w[now]表示当前状态的选取方格的总值 那么最后的答案就是最后一行中的最大值 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int maxn = 25; unsigned int nums[maxn][maxn];//用无符型是因为HDU的尿性，不这样可能会超内存 vector\u0026lt;unsigned int\u0026gt; v;//用来存储合法的状态 int n; int val(int r, int v) {//求当前行状态的总价值 int res = 0, i = n; while (v != 0) { if (v \u0026amp; 1) { res += nums[r][i]; } v \u0026gt;\u0026gt;= 1; i--; } return res; } int main() { while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;n) != EOF) { v.clear(); //清空v数组 int choice = (1 \u0026lt;\u0026lt; n); //最大的状态数 for (int i = 0; i \u0026lt; choice; i++) { if ((i \u0026amp; (i \u0026lt;\u0026lt; 1)) == 0) v.push_back(i);//预处理，选取合法的状态 } int len = v.size(); vector\u0026lt;vector\u0026lt;unsigned int\u0026gt;\u0026gt; dp(n + 1, vector\u0026lt;unsigned int\u0026gt;(len));//动态开辟数组，防止超内存 for (int i = 1; i \u0026lt;= n; i++) {//输入 for (int j = 1; j \u0026lt;= n; j++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;nums[i][j]); } } unsigned int Max = 0; for (int i = 1; i \u0026lt;= n; i++) { for (int now = 0; now \u0026lt; len; now++) { int w = val(i, v[now]); for (int pre = 0; pre \u0026lt; len; pre++) {//枚举上一行的状态值 if ((v[now] \u0026amp; v[pre]) == 0) dp[i][now] = max(dp[i][now], dp[i - 1][pre] + w);//状态转移 } } } for (int i = 0; i \u0026lt; len; i++) {//最后的结果 Max = max(Max, dp[n][i]); } printf(\u0026#34;%d\\n\u0026#34;, Max); } return 0; } 表面上时间复杂度：O($n2^n2^n$),先别急，经过预处理，实际比这个小得多得多，每个$2^n$估计会被压到最大也就4000左右，据大佬测试 n 最大是17，不会有n = 20得样例；这下子复杂度就妥妥地能过了 空间复杂度：和时间复杂度同理，最大也就开个约为17 * 4000的数组 【例题2】洛谷 P1879 Corn Fields G 题目大意：给你一个M * N的方格土地，1 表示可以种玉米，0 表示不可以种玉米。拥有公共边的格子不能同时种上玉米，问你有多少种种的方式，什么都不种也算一种，答案对 1e8 取模\n一道状压dp计数题，也是一个很好的板子题\n简单的分析\nM 和 N 的数据范围都很小，所以我还是采用了压缩列来做 要做的准备有：预处理本不合法的状态、把方格土地的01状态转换成十进制的表示，用个数组cor[i]来储存，方便后面判断是否能种、先把第一行合法的状态算了，把能种的且合法的都初始化为 1； 先看状态转移方程 $$ dp[i][now] += dp[i - 1][pre] $$ 解释：i 表示第 i 行，now 和 pre 分别表示当前行的状态和上一行的状态，当然 now 的前提是可以在当前行上种下来，即 now 是 cor[i] 的子集，而 pre 和 now 必须没有同位的 1 例如第 n 行，什么都不种（now = 0）的方法数就是上一行合法状态的和（其实所有和都可算，因为不合法的一定是0），而第 n 行状态 q 的种法的方法数就是上一行与他没有同位 1 状态的和（这里可以多一个判断，判断pre是否能在上一行上种起来，这样可以循环，当然不判断也行，因为不合法的一定为0） 最后的答案就是最后一行的dp和(稍微换了一下码风，可能会舒服点，因为循环和判断有点多) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int M = 15, mod = 1e8; int m, n, nums[M], cor[M]; vector\u0026lt;int\u0026gt; v;//存储合法的状态 int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;m, \u0026amp;n); int choice = 1 \u0026lt;\u0026lt; n; for (int i = 0; i \u0026lt; choice; i++) { if ((i \u0026amp; (i \u0026lt;\u0026lt; 1)) == 0) v.push_back(i); } int len = v.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(m + 1, vector\u0026lt;int\u0026gt;(len, 0)); for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;nums[j]); if (!nums[j]) continue; cor[i] |= (1 \u0026lt;\u0026lt; (j - 1));//把每一行的方块状态转换成对应的十进制 } } int ans = 0; for (int i = 0; i \u0026lt; len; i++) { //先处理第一行，方便后面计算 if ((v[i] \u0026amp; cor[1]) != v[i]) continue; dp[1][i] = 1; } for (int i = 2; i \u0026lt;= m; i++) { for (int j = 0; j \u0026lt; len; j++) { if ((v[j] \u0026amp; cor[i]) != v[j]) continue; for (int k = 0; k \u0026lt; len; k++) { if ((v[j] \u0026amp; v[k]) != 0) continue; if ((v[k] \u0026amp; cor[i - 1]) != v[k]) continue; dp[i][j] = (dp[i][j] + dp[i - 1][k]) % mod; } } } for (int i = 0; i \u0026lt; len; i++) { ans = (ans + dp[m][i]) % mod; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } 时间和空间复杂度和上一题类似，压着就可以过的 ⑤ 数位DP 篇幅过长已搬出，见数位dp 5. 优化dp的手段 ① 矩阵优化 ② 数据结构优化 ③ 单调队列优化 ④ 决策单调性优化 ⑤ 二进制优化 ⑥ 斜率优化 ⑦ 四边形不等式优化 未完待续（以后有空补充）……\n","date":"2020-08-19T12:22:01+08:00","permalink":"https://example.com/2020/","title":""},{"content":"Bin Packing 题意：给你n个物品，每个物品的重量为$w_i$，你有容量为w的背包，每个背包最多只能装两件物品，问你最少要多少背包来装 贪心就好了，贪心策略：将物品按重量排序，如果最重和最轻的物品一起不超过w就放一起，然后就让次重和次轻的放一起；否则重的单独放在一个背包，然后让次重的背包和最轻的一起，以此循环 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int M = 1e5 + 5; int n, w, wi[M]; int main () { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;w); for (int i = 0; i \u0026lt; n; i++) scanf(\u0026#34;%d\u0026#34;, wi + i); sort(wi, wi + n); int l = 0, r = n - 1, ans = 0; while (l \u0026lt;= r) { if (wi[l] + wi[r] \u0026lt;= w) l++, r--; else r--; ans++; } if (t) printf(\u0026#34;%d\\n\\n\u0026#34;, ans); else printf(\u0026#34;%d\\n\u0026#34;, ans); } return 0; } ","date":"2020-08-18T15:50:53+08:00","permalink":"https://example.com/2020/uva1149/","title":"UVA1149"},{"content":"Unique Snowflakes 题意：给你一个长度为$n(n \\le 1000000)$的数组，问你最长有不重复数字的连续子序列有多长 用set和map的速度都差不多，set记录是否重复，map记录当前数字在此之前最近出现的位置，如果没有就是-1 如果嫌set和map慢的话直接用unordered_set或者unordered_map 这里用了上次偶遇了一种很牛逼很简洁的hash方式后就喜欢上这个hash，跑进了100ms 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int M = 1e6 + 10, H = 0xfffff; int n, arr[M], last[M]; struct Hash{ int real[H + 5], val[H + 5]; void clear() { memset(val, -1, sizeof val); }//初始化-1 int\u0026amp; operator[] (const int \u0026amp;k) { int i = k \u0026amp; H; while (real[i] != k \u0026amp;\u0026amp; ~val[i]) i = (i + 1) \u0026amp; H; real[i] = k; return val[i]; } }h; int main() { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); h.clear(); memset(last, -1, sizeof last); for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%d\u0026#34;, arr + i); last[i] = h[arr[i]]; h[arr[i]] = i; } int ans = 0, l = 0, r = 0; while (r \u0026lt; n) { while (r \u0026lt; n \u0026amp;\u0026amp; last[r] \u0026lt; l) r++; ans = max(ans, r - l); l = last[r] + 1; } printf(\u0026#34;%d\\n\u0026#34;, ans); } return 0; } ","date":"2020-08-18T11:57:07+08:00","permalink":"https://example.com/2020/uva11572/","title":"UVA11572"},{"content":"Wine trading in Gergovia 题意：有n个村庄，每个村庄都有对酒的需求，正数代表要送出多少酒，负数代表需要多少酒，把k单位的酒运到相邻的村庄要k单位的体力，让你计算最小需要的体力 对于第一个村庄，他的需求量x无论正负，都需要右边的村庄搬过来或者搬过去右边的村庄，然后把多余的需求继承到下一个村庄，和紫书上讲的思想差不多 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; using ll = long long; const int M = 1e5 + 10; int n; ll arr[M], ans; int main() { while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;n), n) { ans = 0; for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%lld\u0026#34;, arr + i); } for (int i = 0; i \u0026lt; n - 1; i++) { ans += abs(arr[i]), arr[i + 1] += arr[i]; } printf(\u0026#34;%lld\\n\u0026#34;, ans); memset(arr, 0, sizeof arr); } return 0; } ","date":"2020-08-18T10:55:44+08:00","permalink":"https://example.com/2020/uva11054/","title":"UVA11054"},{"content":"4 Values whose Sum is 0 题意：给你4个长度为$n(n \\le 4000)$的集合，让你在4个集合里分别取a、b、c、d，使得$a + b + c + d = 0$，问你有多少种取法 按紫书说的“中途相遇法”，从象个不同的方向来解决问题，最终“汇集”在一起 用哈希记录$a + b$，然后再计算$-c - d$的哈希个数就好了，用slt提供的unordered_map足够过这题了，跑了6000ms多，a掉了 后来看了一位大佬自己写的hash，跑了一下，平均650ms，一个很快的哈希表 原理大概和线性探查法差不多，不过这里用的不是取余（取余很慢），这里用的位运算里的与运算，保证了数值在给定的哈希范围内 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int M = 4e3 + 10, H = 0x7fffff; int n, arr[5][M]; struct Hash{ int real[H + 5], val[H + 5] void clear() { memset(val, 0, sizeof val); } int\u0026amp; operator[] (const int\u0026amp; num) { int i = num \u0026amp; H; while (val[i] \u0026amp;\u0026amp; real[i] != num) i = (i + 1) \u0026amp; H; real[i] = num; return val[i]; } }h; void solve() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); h.clear(); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; 4; j++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;arr[j][i]); } } for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { h[arr[0][i] + arr[1][j]]++; } } int ans = 0; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { ans += h[- arr[2][i] - arr[3][j]]; } } printf(\u0026#34;%d\\n\u0026#34;, ans); } int main() { int T, f = 1; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { if (f) f = !f; else puts(\u0026#34;\u0026#34;); solve(); } return 0; } ","date":"2020-08-17T19:54:27+08:00","permalink":"https://example.com/2020/uva1152/","title":"UVA1152"},{"content":"Building for UN 题意：有一栋楼，有$n(n \\le 50)$个国家要开会，每个国家至少分配一个位置，让你输出一种方案，H层，每层W行L列，使得任意两个国家要能相邻，层数也算相邻 按紫书说的构造一种解出来，只需要两层就好了，每层$n \\times n$的格子，第一层第i行是第i个国家,第二层第j列是第j个国家， 这个模型有点像放筷子，有n双筷子，分别都有左和右，要想让每个左筷子都能接触到其他右筷子的方案就是在第一层筷子横着放，第二层竖着放就行了 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int n; char str[55]; void solve() { printf(\u0026#34;%d %d %d\\n\u0026#34;, 2, n, n); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) printf(\u0026#34;%c\u0026#34;, str[i]); puts(\u0026#34;\u0026#34;); } puts(\u0026#34;\u0026#34;); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) printf(\u0026#34;%c\u0026#34;, str[j]); puts(\u0026#34;\u0026#34;); } } int main() { for (int i = 0; i \u0026lt; 26; i++) str[i] = \u0026#39;a\u0026#39; + i; for (int i = 0; i \u0026lt; 26; i++) str[26 + i] = \u0026#39;A\u0026#39; + i; while (~scanf(\u0026#34;%d\u0026#34;, \u0026amp;n)) solve(); return 0; } ","date":"2020-08-17T11:43:31+08:00","permalink":"https://example.com/2020/uva1605/","title":"UVA1605"},{"content":"Stacks of Flapjacks 题意：给你一个序列，每次选一个数k，从序列的后往前数第k个数然后把它及它之前时数都翻转一下，问你一种选法使得序列从小到大排好序 有点像选择排序，不过为了不影响后面的，应该先把排好最大的数，如果已经就位就排第二大的数，具体策略是先把它调到最前面再调到相应的正确位置，一直排到有序为止 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int cnt, arr[50], tmp[50]; char line[150]; void solve() { memcpy(tmp, arr, sizeof(int) * cnt); sort(tmp, tmp + cnt); int indx = cnt - 1; for (int i = cnt - 1; i \u0026gt;= 0; i--) { if (tmp[indx] == arr[i]) { indx--; } else { int nums = i, k = cnt - i; while (arr[nums] != tmp[indx]) { nums--, k++; } if(nums != 0) { reverse(arr, arr + nums + 1); printf(\u0026#34;%d \u0026#34;, k); } reverse(arr, arr + i + 1); printf(\u0026#34;%d \u0026#34;, cnt - i); indx--; } } puts(\u0026#34;0\u0026#34;); } bool read() { if (fgets(line, sizeof line, stdin) == nullptr) return false; printf(\u0026#34;%s\u0026#34;, line); char *tmp = line; cnt = 0; while (1) { sscanf(tmp, \u0026#34;%d\u0026#34;, \u0026amp;arr[cnt++]); tmp = strchr(tmp, \u0026#39; \u0026#39;); if (tmp == nullptr) break; tmp++; } return true; } int main() { while (read()) solve(); return 0; } ","date":"2020-08-17T11:16:52+08:00","permalink":"https://example.com/2020/uva120/","title":"UVA120"},{"content":"Egyptian Fractions (HARD version) 题意：埃及分数问题困难版，问你一个真分数$a/b$，在表达成$a/b = 1/c + 1/d ……$，选的分数尽量少，相同情况下自小的分数尽量大，限制有$k(k \\le 5)$个数不能用来做分母，让你求解 思路，IDA*的经典题，和普通埃及分数差不多的写法，就是要加一个限制，即有些数不能用 一开始写了一个分数的结构体，后来发现没必要，直接IDA*就好了 注意几个剪枝的地方， 到达目标层时 判断分子是否为1 判断最后一个分母是否重复 判断最后一个分母是否可用 判断是否是更优解 未达到目标层时 预测选用当前的抉择是否会超出目标层（IDA*的关键剪枝） 判断当前抉择的分母是否可用 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; using ll = long long; ll kase = 0, can[1005], k, ans[10000], tmp[10000], a, b, x; ll gcd(ll a, ll b) { ll m = 1; while(m) m = a % b, a = b, b = m; return a; } bool dfs(ll now, const ll \u0026amp;h, ll first, ll a, ll b) { if (now == h) { if (a != 1) return false; if (b \u0026lt; 1001 \u0026amp;\u0026amp; can[b]) return false; if (b == tmp[h - 2]) return false; tmp[h - 1] = b; if (ans[h - 1] == 0) memcpy(ans, tmp, sizeof(ll) * h); for (int i = h - 1; i \u0026gt;= 0; i--) { if (ans[i] == tmp[i]) continue; else if (ans[i] \u0026gt; tmp[i]) memcpy(ans, tmp, sizeof(ll) * h); break; } return true; } bool ok = false; for (ll i = max(first, b / a) + 1; ; i++) { if (a * i \u0026gt;= (h - now + 1) * b) break; if (i \u0026lt; 1001 \u0026amp;\u0026amp; can[i]) continue; tmp[now - 1] = i; ll g = gcd(b * i, a * i - b); if (dfs(now + 1, h, i, (a * i - b) / g, b * i / g)) ok = true; } return ok; } void solve() { scanf(\u0026#34;%lld%lld%lld\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;k); printf(\u0026#34;Case %lld: %lld/%lld=\u0026#34;, ++kase, a, b); while (k--) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;x); can[x] = true; } for (ll i = 1; ; i++) { if (dfs(1, i, 0, a, b)) { for (ll j = 0; j \u0026lt; i - 1; j++) printf(\u0026#34;1/%lld+\u0026#34;, ans[j]); printf(\u0026#34;1/%lld\\n\u0026#34;, ans[i - 1]); break; } } memset(tmp, 0, sizeof tmp); memset(can, 0, sizeof can); memset(ans, 0, sizeof ans); } int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) solve(); return 0; } ","date":"2020-08-16T21:28:14+08:00","permalink":"https://example.com/2020/uva12558/","title":"UVA12558"},{"content":"Overlapping Squares 题意：给你个$4 \\times 4$的网格图，问你有没有可能用不超过6张$2 \\times 2$的纸叠成给的样子 一开始想破脑袋都想不出来应该怎么验证是否相同，没办法还是问了下度娘，知道思路后自己写了代码ac了 想不出的是如何验证正确性，一开始想着是否要把被遮住的部分补全然后验证，但这样又怎么验证？看了看别人的思路发现自己是真的蠢，直接模拟用$2 \\times 2$的纸一张一张地放上去不就好了吗 dfs最多也就6层，纸放下去只有9种可能，能想到这里就可以直接dfs模拟了 ac代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; char g[10][20], p[10][20]; bool vis[10]; bool init() { for (int i = 0; i \u0026lt; 5; i++) { fgets(g[i], 15, stdin); if (g[i][0] == \u0026#39;0\u0026#39;) return false; } memset(p, \u0026#39; \u0026#39;, sizeof p); memset(vis, 0, sizeof vis); return true; } bool check() { for (int i = 0; i \u0026lt; 5; i++) { for (int j = 0; j \u0026lt; 9; j++) if (p[i][j] != g[i][j]) return false; } return true; } bool dfs(int num) { if (check()) return true; if (num == 6) return false; char tmp[10][20]; memcpy(tmp, p, sizeof p); for (int i = 0; i \u0026lt; 9; i++) { if (vis[i]) continue; vis[i] = true; int r = i / 3, c = (i % 3) * 2; p[r + 1][c] = p[r + 2][c] = p[r + 1][c + 4] = p[r + 2][c + 4] = \u0026#39;|\u0026#39;; p[r][c + 1] = p[r + 2][c + 1] = p[r][c + 3] = p[r + 2][c + 3] = \u0026#39;_\u0026#39;; for (int j = 1; j \u0026lt; 4; j++) p[r + 1][c + j] = \u0026#39; \u0026#39;; p[r + 2][c + 2] = \u0026#39; \u0026#39;; if (dfs(num + 1)) return true; vis[i] = false; memcpy(p, tmp, sizeof p);//回溯 } return false; } int main () { int kase = 0; while(init()) { printf(\u0026#34;Case %d: \u0026#34;, ++kase); if (dfs(0)) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } return 0; } ","date":"2020-08-15T17:16:11+08:00","permalink":"https://example.com/2020/uva12113/","title":"UVA12113"},{"content":"Pipeline Scheduling 历经千辛万苦终于a了这题 题意：一台电脑有5个工作单元(unit0 ~ unit4)，有10(0 ~ 9)个程序需要完成，每个程序都要在n$(n \u0026lt; 20\u0026gt;)$的时间片完成，在同一时间里，一个单元只能执行一个程序，开始执行后就要严格按顺序执行完，问你最小的完成10个程序的时间是多少 从读题到思考到ac用了近两天，下面我将会从运行时间慢到运行时间快，tle到ac开始阐释解决这题时的坎坷 首先是这题怎么dfs 一开始想的时候想到了一个最笨的方法：根据时间一步一步地dfs下去，但这样的话绝对不行，因为如果n = 19,最多会递归190层，就算考虑剪枝，如果答案就是上百的，那也受不了 想了很久终于想到一个办法就是根据程序来递归，即递归（0 ~ 9）这样的话最多也就9层 用一个二维的bool数组run[i][j]来储存状态，代表第i个工作单元在j时间时的运行情况，false代表是空闲的，true代表是正在工作 对于一开始第一个程序即程序0肯定就是从0时刻时开始运行是最优的，所以dfs从程序1开始 对于第$k$个程序来说，如果开始的时间是$s$，则它结束的时间一定是$s + n$，则第$k + 1$个程序可以在$s + 1$到$s + n + 1$之间（包括端点）的时间里开始运行 到这里dfs的运行方式就很明朗了，只需要暴力枚举每个$s + 1$到$s + n + 1$的位置开始运行下一个程序就行了 那么剪枝呢？这个dfs的方法直接对比先前算好最小完成时间的和当前程序的结束时间做对比来剪 上述的方法是会tle的，先别急，一步一步走到ac这个开头不能少 上述dfs方法的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int n, Min; char unit[6][25]; bool run[5][500]; bool check(int s) { for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; 5; j++) if (unit[j][i] == \u0026#39;X\u0026#39; \u0026amp;\u0026amp; run[j][i + s]) return false; return true; } void dfs(int num, int s) { if (s + n \u0026gt;= Min) return; if (num == 10) { Min = s + n; return; } for (int i = s + 1; i \u0026lt;= s + n; i++) { if (!check(i)) continue; for (int j = 0; j \u0026lt; 5; j++) for (int k = 0; k \u0026lt; n; k++) if (unit[j][k] == \u0026#39;X\u0026#39;) run[j][i + k] = true; dfs(num + 1, i); for (int j = 0; j \u0026lt; 5; j++) for (int k = 0; k \u0026lt; n; k++) if (unit[j][k] == \u0026#39;X\u0026#39;) run[j][i + k] = false; } } inline void init(){ memset(run, 0, sizeof run); Min = 0xffff; } int main () { while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;n), n) { for (int i = 0; i \u0026lt; 5; i++) { scanf(\u0026#34;%s\u0026#34;, unit[i]); } init(); for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; 5; j++) if (unit[j][i] == \u0026#39;X\u0026#39;) run[j][i] = true; //程序0开始运行 dfs(1, 0); printf(\u0026#34;%d\\n\u0026#34;, Min); } return 0; } 上面的代码运行n = 19的时候，要在内心默念三四秒才会出答案，显然是超级慢了 下面阐述我是如何一步一步优化到ac甚至更快的结果的 对于上述的代码，我自己在运行的时候是很绝望的，自己跑都能感觉到很慢。后来就度娘了一下，学到了一种比较聪明的方法 考虑第一个程序运行时哪些工作单元是在工作中的，上面说过对于下一个单元它只能在$s + 1$到$s + n + 1$内开始，但是并不是所有时间都可以开始的，它下一个能开始运行的时间是具有跳跃性的，就比如说题中的样例，他就只能当前程序运行的第2、3、6、7的时间开始，别的时间开始都会有冲突，对于后面的所有程序都是只能在上一个程序的第2、3、6、7的时间开始 把跳跃的时间用数组jump[cnt]记录下来，这样的好处就是可以少枚举一些不必要的程序开始时间，$cnt$是可跳跃的个数 还有一个好处就是可以大大地剪枝，具体的剪枝操作是：假如当前递归到了第$num$个数字，上一个程序的开始时间是$s$,则最少还要$s + jump[0] \\times (10 - num) + n$的时间完成10个程序运行的时间，这样就可以和先前算好的$Min$进行对比剪枝了 优化好的代码如下，在电脑上运行20个$n = 19$的不同数据都能很快地出答案，但很可惜，交上去还是tle了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int n, jump[25], Min, cnt = 0; char unit[6][25]; bool run[5][500]; bool check(int s) { for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; 5; j++) if (unit[j][i] == \u0026#39;X\u0026#39; \u0026amp;\u0026amp; run[j][i + s]) return false; return true; } void dfs(int num, int s) { if (s + n \u0026gt;= Min) return; if (s + jump[0] * (10 - num) + n \u0026gt;= Min) return; if (num == 10) { Min = s + n; return; } for (int i = 0; i \u0026lt; cnt; i++) { if (!check(s + jump[i])) continue; for (int j = 0; j \u0026lt; 5; j++) for (int k = 0; k \u0026lt; n; k++) if (unit[j][k] == \u0026#39;X\u0026#39;) run[j][s + jump[i] + k] = true; dfs(num + 1, s + jump[i]); for (int j = 0; j \u0026lt; 5; j++) for (int k = 0; k \u0026lt; n; k++) if (unit[j][k] == \u0026#39;X\u0026#39;) run[j][s + jump[i] + k] = false; } } inline void init(){ memset(run, 0, sizeof run); cnt = 0; Min = 0xffff; } int main () { while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;n), n) { for (int i = 0; i \u0026lt; 5; i++) { scanf(\u0026#34;%s\u0026#34;, unit[i]); } init(); for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; 5; j++) if (unit[j][i] == \u0026#39;X\u0026#39;) run[j][i] = true; for (int i = 1; i \u0026lt;= n; i++) if(check(i)) jump[cnt++] = i; dfs(1, 0); printf(\u0026#34;%d\\n\u0026#34;, Min); } return 0; } 这个代码还有优化的空间的，就是二进制状态压缩，对于之前设定的run[5][500]的数组可以进行压缩成一维的run[500]，用二进制代表时间i时5个工作单元的状态，0代表空闲，1代表工作中 别忘了，要把输入的最初结果也要二进制压缩 这样进行压缩速度快了不少，少了一重长度为5的循环，可能递归常数大的原因，亦或是上面那个代码就tle了一点点的原因，所以二进制优化后直接ac了 ac代码如下，跑了440ms 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int n, Min, unit[25], run[500], jump[25], cnt = 0; bool check(int s) { for (int i = 0; i \u0026lt; n; i++) if (unit[i] \u0026amp; run[i + s]) return false; return true; } void dfs(int num, int s) { if (s + n \u0026gt;= Min) return; if (s + (10 - num) * jump[0] + n \u0026gt;= Min) return; if (num == 10) { Min = s + n; return; } for (int i = 0; i \u0026lt; cnt; i++) { if (!check(jump[i] + s)) continue; for (int j = 0; j \u0026lt; n; j++) run[s + jump[i] + j] |= unit[j]; dfs(num + 1, jump[i] + s); for (int j = 0; j \u0026lt; n; j++) run[s + jump[i] + j] ^= unit[j];//回溯 } } inline void init(){ memset(run, 0, sizeof run); memset(unit, 0, sizeof unit); cnt = 0; Min = 0xffff; } int main () { while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;n), n) { init(); for (int i = 0; i \u0026lt; 5; i++) { getchar(); for (int j = 0; j \u0026lt; n; j++) { char c = getchar(); if (c == \u0026#39;X\u0026#39;) unit[j] |= (1 \u0026lt;\u0026lt; i);//压缩 } } for (int i = 0; i \u0026lt; n; i++) run[i] = unit[i]; for (int i = 1; i \u0026lt;= n; i++) if (check(i)) jump[cnt++] = i; dfs(1, 0); printf(\u0026#34;%d\\n\u0026#34;, Min); } return 0; } 那么还有优化的空间吗？当然还有，注意到n的范围是不超过20的，当我们在考虑下一个程序运行时是只看上一个程序的运行开始时间和结束时间的，所以我们可以反过来压缩，上一份代码是对每个时间里的所有工作单元进行压缩，这次是把每个工作单元的一次工作时间进行压缩 换句话说就是上一份代码是对行进行了压缩，这次是对列进行压缩，即每次压缩都是一个n位的二进制数 对于下一个程序，由于只看上一个程序，所以只需要存位数为n的二进制状态就行了，同样记得回溯，这次的回溯要用个tmp数组存起之前的二进制状态 这次的压缩直接把之前n的循环改成了5的循环，更大限度地优化了时间 ac代码如下，跑了190ms 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int n, Min, unit[10], run[10], cnt = 0, jump[25]; bool check(int s) { for (int i = 0; i \u0026lt; 5; i++) if (unit[i] \u0026amp; (run[i] \u0026gt;\u0026gt; s)) return false; return true; } void dfs(int num, int s) { if (s + n \u0026gt;= Min) return; if (s + (10 - num) * jump[0] + n\u0026gt;= Min) return; if (num == 10) { Min = s + n; return; } for (int i = 0; i \u0026lt; cnt; i++) { if (!check(jump[i])) continue; int tmp[5]; for (int j = 0; j \u0026lt; 5; j++) { tmp[j] = run[j]; run[j] = (run[j] \u0026gt;\u0026gt; jump[i]) | unit[j]; } dfs(num + 1, s + jump[i]); for (int j = 0; j \u0026lt; 5; j++) run[j] = tmp[j]; } } inline void init(){ memset(run, 0, sizeof run); memset(unit, 0, sizeof unit); Min = 0xffff; cnt = 0; } int main () { while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;n), n) { init(); for (int i = 0; i \u0026lt; 5; i++) { getchar(); for (int j = 0; j \u0026lt; n; j++) { char c = getchar(); if (c == \u0026#39;X\u0026#39;) unit[i] |= (1 \u0026lt;\u0026lt; j); } } for (int i = 0; i \u0026lt; 5; i++) run[i] = unit[i]; for (int i = 1; i \u0026lt;= n; i++) if(check(i)) jump[cnt++] = i; dfs(1, 0); printf(\u0026#34;%d\\n\u0026#34;, Min); } return 0; } 这是我优化的最快的了，再快的优化方式，我一个小小蒟蒻想不到了 ","date":"2020-08-14T12:22:46+08:00","permalink":"https://example.com/2020/uva690/","title":"UVA690"},{"content":"The Domino Effect 题意：一个多米诺骨牌有两个面，一共有28个不同的多米诺骨牌，放在那，可能横着，可能竖着，这样就形成了一个$7 \\times 8$的一个数字图，问你所有可能的摆放方式 dfs就好了，一开始没想到怎么dfs，绞尽脑汁，一开始一格一格来，失败，后来采用每一行都用一个二进制状态来描述是横还是竖，还是失败了，最后看了下题解，豁然开朗 也是dfs，但是不能再单纯地一格一格得dfs，要一行一行来，不然可能会像我一开始那样，会遗漏很多格子没递归到，所以要一行一行来，方式就是每行一格一格地递归，递归到最后一列的才换行（代码24行处），最终将28个牌都遍历一遍才能输出 至于骨牌号码的储存方式，考虑到数据小，所以用了压缩来储存起骨牌的号码 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int domi[10][10], id[400], ans[10][10], nums = 0, kase = 0; bool vis[30]; const int dr[] = {1, 0}, dc[] = {0, 1}; inline int ID(int a, int b) { return (min(a, b) \u0026lt;\u0026lt; 6) | max(a, b); } inline bool check(int r, int c) { return r \u0026lt; 7 \u0026amp;\u0026amp; c \u0026lt; 8; } void init(){ memset(ans, 0, sizeof ans); memset(vis, 0, sizeof vis); nums = 0; } void dfs(int r, int c, int num) { if (num == 28) { nums++; for (int i = 0; i \u0026lt; 7; i++) { for (int j = 0; j \u0026lt; 8; j++) { printf(\u0026#34;%4d\u0026#34;, ans[i][j]); } puts(\u0026#34;\u0026#34;); } puts(\u0026#34;\\n\u0026#34;); return; } if (c == 8) r++, c = 0; if (ans[r][c]) { dfs(r, c + 1, num); return; } for (int i = 0; i \u0026lt; 2; i++) { int newr = r + dr[i], newc = c + dc[i]; int x = ID(domi[r][c], domi[newr][newc]), res = id[x]; if (!check(newr, newc) || vis[res] || ans[newr][newc]) continue; ans[r][c] = ans[newr][newc] = res, vis[res] = true; dfs(r, c + 1, num + 1); ans[r][c] = ans[newr][newc] = 0, vis[res] = false; } } int main () { int cnt = 0; bool ok = true, f = true; for (int i = 0; i \u0026lt;= 6; i++) { for (int j = i; j \u0026lt;= 6; j++) { id[ID(i, j)] = ++cnt; } } while (1) { for (int i = 0; i \u0026lt; 7 \u0026amp;\u0026amp; ok; i++) { for (int j = 0; j \u0026lt; 8; j++) { if (!~scanf(\u0026#34;%d\u0026#34;, \u0026amp;domi[i][j])) { ok = false; break; } } } if (!ok) break; if (f) f = !f; else puts(\u0026#34;\\n\\n\\n\\n\u0026#34;); printf(\u0026#34;Layout #%d:\\n\\n\u0026#34;, ++kase); for (int i = 0; i \u0026lt; 7; i++) { puts(\u0026#34;\u0026#34;); for (int j = 0; j \u0026lt; 8; j++) printf(\u0026#34;%4d\u0026#34;, domi[i][j]); } printf(\u0026#34;\\n\\nMaps resulting from layout #%d are:\\n\\n\\n\u0026#34;, kase); init(); dfs(0, 0, 0); printf(\u0026#34;There are %d solution(s) for layout #%d.\\n\u0026#34;, nums, kase); } return 0; } ","date":"2020-08-13T14:46:51+08:00","permalink":"https://example.com/2020/uva211/","title":"UVA211"},{"content":"Golygons 题意：一个网格图，现在给你图中$k(k \\le 50)$个障碍的坐标（坐标可能为负），不能继续上次的方向继续走也不能后退，这就意味着只能左右走，第$i$次走$i$个单位，从(0, 0)点出发，走了$n(n \\le 20)$次恰好回到(0, 0)点，让你输出所有可能的路线，按字典序输出 因为深度已知，所以我才用了DFS的方法，考虑到坐标可能有负数，所以我把坐标原点移动了一下，将(1000, 1000)记为原点，其余点也一样有同样变化，因为 $n \\le 20$， 所以1000够用 将答案用vector\u0026lt;char\u0026gt;的一维数组存起来，因为vector里面自带字典序的排序，所以最后可以直接sort(ans, ans + num)排序（详细看代码），当然用vector\u0026lt;string\u0026gt;来存，这样就不用再而外加多一维数组了，string也有push_back()（用append()也可以）和pop_back()函数，这样最后的排序就必须是sort(ans.begin(), ans.end()); 一个方案中一个坐标不能被访问两次，用个vis的布尔数组来记录是否被访问过 dfs两次，因为最开始是4个方向都可以走的 最后记得回溯 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int M = 1e3; int t, k, bn, num; bool isb[M + M][M + M], vis[M + M][M + M]; const char dir[] = \u0026#34;ewns\u0026#34;; const int dx[] = {1, -1, 0, 0}; const int dy[] = {0, 0, 1, -1}; vector\u0026lt;char\u0026gt; ans[1000], tmp; void init() { num = 0; memset(isb, 0, sizeof isb); memset(vis, 0, sizeof vis); for (auto \u0026amp;i : ans) i.clear(); } void dfs(int a, int b, int n, int d) { if (n == k) { if (a != M || b != M) return; ans[num++] = tmp; return; } for (int i = d; i \u0026lt; 4 - 2 + d; i++) { int newx = a, newy = b; bool flag = true; for (int j = 0; j \u0026lt;= n; j++) {//走n+1步 newx += dx[i], newy += dy[i]; if (isb[newx][newy]) { flag = false; break; }//遇到障碍就不行 } if (!flag || vis[newx][newy]) continue; vis[newx][newy] = true; tmp.push_back(dir[i]); dfs(newx, newy, n + 1, 2 - d); tmp.pop_back(); vis[newx][newy] = false; } } int main () { scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { init(); scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;k, \u0026amp;bn); while (bn--) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); isb[x + M][y + M] = true;//障碍 } dfs(M, M, 0, 0); dfs(M, M, 0, 2); sort(ans, ans + num);//排序 for (int i = 0; i \u0026lt; num; i++) { for (auto x : ans[i]) printf(\u0026#34;%c\u0026#34;, x); puts(\u0026#34;\u0026#34;); } printf(\u0026#34;Found %d golygon(s).\\n\\n\u0026#34;, num); } return 0; } ","date":"2020-08-12T15:54:08+08:00","permalink":"https://example.com/2020/uva225/","title":"UVA225"},{"content":"Firetruck 题意：给你一个无向图，让你求出从1号节点到n号节点的所有路径，按顺序输出，具体看样例 DFS和BFS都可以，这里我用了DFS，利用了一个ans的vector数组来储存答案，根据题目要求，优先递归节点权值小的 注意：要先判断1号节点能否到达n号节点，不然会tle，这里我用了一个类似于并查集的思想来判断是否能到达n号节点 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; using vi = vector\u0026lt;int\u0026gt;; int t, cnt, Kase = 0, nums, fa[25]; bool vis[25], f, num[25], v[25]; vi nodes[25], ans; void init() { cnt = 0, nums = 0; for (auto \u0026amp;i : nodes) i.clear(); ans.clear(); ans.push_back(1); memset(num, 0, sizeof num); memset(vis, 0, sizeof vis); memset(v, 0, sizeof v); vis[1] = true; for (int i = 1; i \u0026lt; 25; i++) fa[i] = i; } void DFS(int n) { if (n == t) { cnt++, f = true; for (auto i : ans) { if (f) f = !f; else printf(\u0026#34; \u0026#34;); printf(\u0026#34;%d\u0026#34;, i); } puts(\u0026#34;\u0026#34;); return; } for (auto x : nodes[n]) { if (vis[x]) continue; vis[x] = true; ans.push_back(x); DFS(x); vis[x] = false; ans.pop_back(); } } bool check(int n = 1) { for (auto i : nodes[n]) { if(!v[i]) { fa[i] = 1, v[i] = true; check(i); } } return fa[t] == 1; } int main () { while (~scanf(\u0026#34;%d\u0026#34;, \u0026amp;t)) { printf(\u0026#34;CASE %d:\\n\u0026#34;, ++Kase); int u, v; init(); while (scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v), u + v) { nodes[u].push_back(v); nodes[v].push_back(u); } for (auto \u0026amp;i : nodes) sort(i.begin(), i.end()); if(check()) DFS(1); printf(\u0026#34;There are %d routes from the firestation to streetcorner %d.\\n\u0026#34;, cnt, t); } return 0; } ","date":"2020-08-12T10:24:20+08:00","permalink":"https://example.com/2020/uva208/","title":"UVA208"},{"content":"Editing a Book 题意：给你一个排列，你一次能够剪切一段字串，然后在别的地方插入粘贴，让你求最少的剪切粘贴次数使得排列是1~n按顺序的 IDA*的题，每次规定递归的层数，长度为n的排列最多是剪切粘贴n - 1次 剪枝精髓：移动一次最多改变 3 个数字的后继数字，例如从{a，b，c，d}到{a, c, b, d},只有a, c, b（字母均代表区间）三个区间最后一个数的后继改变了 假设当前递归到d层，还有h个数字的后继不正确（最后一个数字的评判依据是是否是最后一个数，即$n - 1$），的最少还要遍历 $d + h / 3$ 层，当前设置了最大层数为Max, 则当 $d + h / 3 \u0026gt; Max$ 即 $3 \\times d + h \u0026gt; 3 \\times Max$ 就剪枝 代码如下，跑了300ms 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int n, arr[15], tmp[15], kase = 0; bool check() { for (int i = 0; i \u0026lt; n; i++) { if (arr[i] != i + 1) return false; } return true; } int h() { int cnt = 0; for (int i = 0; i \u0026lt; n - 1; i++) { if (arr[i] + 1 != arr[i + 1]) cnt++; } if (arr[n - 1] != n) cnt++; return cnt; } bool DFS(int d, int Max) { if (check()) return true; //完成走人 if (d * 3 + h() \u0026gt; 3 * Max) return false;//剪枝 int old[15], cut[10]; memcpy(old, arr, sizeof arr); for (int i = 0; i \u0026lt; n; i++) { if (i == 0 || old[i] != old[i - 1] + 1) { //剪枝，只选取错误的剪切 for (int j = i; j \u0026lt; n; j++) { int cnt = 0, len = j - i + 1; for (int k = 0; k \u0026lt; n; k++) { if (k \u0026lt; i || k \u0026gt; j) cut[cnt++] = arr[k]; } for (int k = 0; k \u0026lt;= cnt; k++) { memcpy(tmp, cut, sizeof(int) * k); memcpy(\u0026amp;tmp[k], \u0026amp;arr[i], sizeof(int) * (len)); memcpy(\u0026amp;tmp[k + len], \u0026amp;cut[k], sizeof(int) * (cnt - k)); memcpy(arr, tmp, sizeof(int) * n); if (memcmp(arr, old, sizeof(int) * n) == 0) continue;//和之前的一样，剪枝 if (DFS(d + 1, Max)) return true; memcpy(arr, old, sizeof arr); } } } } return false; } int main () { while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;n), n) { for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%d\u0026#34;, arr + i); } if (check()) { printf(\u0026#34;Case %d: 0\\n\u0026#34;, ++kase); continue; } for (int i = 1; i \u0026lt; n; i++) { if (DFS(0, i)) { printf(\u0026#34;Case %d: %d\\n\u0026#34;, ++kase, i); break; } } } return 0; } ","date":"2020-08-11T10:02:22+08:00","permalink":"https://example.com/2020/uva11212/","title":"UVA11212"},{"content":"The Morning after Halloween 题意：给你一个图，\u0026quot;#\u0026ldquo;为障碍物，\u0026rdquo; \u0026ldquo;为通路，图里面最多有3个小写字母（a, b, c）和于其对应的大写字母（A, B, C），每次移动每个小写字母都有4个方向和不动5种方案，一次移动可以有多个小写字母一起移动，不能一个空格点不能同时有多个小写字母，问你最少要移动多少次才能让这些小写字母移动到对应的大写字母上 受紫书的启发，了解到了一个规矩图或者迷宫亦或是题目给的不是图（例如上次的倒水题），也能够利用“状态”来简化成一个平时我们更多看到的点对点的图，看来是几个能够相互连接产生关系的状态，就能考虑利用状态图来解 这题的“状态”是对每个坐标的压缩，压缩成一个一维的标志，看起来就好像是给每家每户上一个门牌号一样，因为坐标最大是（16, 16），也就是说最多有256个“门牌号”，这对于一个图来说还是有点多，幸运的是题中说每 $2 \\times 2$ 的格子至少有一个可走的点，这样我们只要考虑可以走的点就行了 按出现顺序给可走的点编上“门牌号”，并记录上字母的门牌号 还要记录每个点能到哪些点，这样就能当成一个有向图来看了 如果题目给的鬼的数量不到3个，那可以假装他给了，为没给的字母强行加个门牌号，并且他们已经到了自己的目的地，即相应的大小写字母在同一个位置 以下代码是单向的BFS, vj上测得是930ms 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cctype\u0026gt; using namespace std; const int M = 210, f = 0xff; char g[M][M]; int w, n, h, s[3], t[3], id[20][20], dir[M][M][M]; const int dx[] = {-1, 0, 1, 0, 0}; const int dy[] = {0, -1, 0, 1, 0}; inline bool check(int x, int y) { return x \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt;= w \u0026amp;\u0026amp; y \u0026lt;= h; } inline int ID(int a, int b, int c) { return (a \u0026lt;\u0026lt; 16) | (b \u0026lt;\u0026lt; 8) | c; }//状态压缩 inline bool move(int a, int b, int ago, int bgo) {//检车移动是否合法，即不能一步交换位置，不能到同一个位置 return (a == bgo \u0026amp;\u0026amp; b == ago) || ago == bgo; } struct pos{ int x, y, n, go[5]; } p[200]; void BFS() { memset(dir, -1, sizeof dir); queue\u0026lt;int\u0026gt; q; q.push(ID(s[0], s[1], s[2])); dir[s[0]][s[1]][s[2]] = 0; while (q.size()) { int u = q.front(); q.pop(); int a = u \u0026gt;\u0026gt; 16, b = (u \u0026gt;\u0026gt; 8) \u0026amp; f, c = u \u0026amp; f; if (a == t[0] \u0026amp;\u0026amp; b == t[1] \u0026amp;\u0026amp; c == t[2]) return; // printf(\u0026#34;()\u0026#34;); for (int i = 0; i \u0026lt; p[a].n; i++) { int ago = p[a].go[i]; for (int j = 0; j \u0026lt; p[b].n; j++) { int bgo = p[b].go[j]; if (move(a, b, ago, bgo)) continue; for (int k = 0; k \u0026lt; p[c].n; k++) { int cgo = p[c].go[k]; if (move(a, c, ago ,cgo))continue; if (move(b, c, bgo, cgo))continue; if (dir[ago][bgo][cgo] \u0026gt;= 0) continue; dir[ago][bgo][cgo] = dir[a][b][c] + 1; q.push(ID(ago, bgo, cgo)); } } } } } int main() { while (scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;w, \u0026amp;h, \u0026amp;n), w + h + n) { int cnt = 0; for (int i = 0; i \u0026lt; h; i++) { getchar(); for (int j = 0; j \u0026lt; w; j++) { char c = g[i][j] = getchar(); if (c == \u0026#39;#\u0026#39;) continue; p[cnt].x = j, p[cnt].y = i, id[i][j] = cnt; if (islower(c)) s[c - \u0026#39;a\u0026#39;] = cnt; if (isupper(c)) t[c - \u0026#39;A\u0026#39;] = cnt; cnt++; } } for (int i = 0; i \u0026lt; cnt; i++) { p[i].n = 0; for (int j = 0; j \u0026lt; 5; j++) { int nowx = p[i].x + dx[j], nowy = p[i].y + dy[j]; if (g[nowy][nowx] == \u0026#39;#\u0026#39; || !check(nowx, nowy)) continue; p[i].go[p[i].n++] = id[nowy][nowx]; } } if (n \u0026lt;= 2) p[cnt].n = 1, p[cnt].go[0] = cnt, s[2] = t[2] = cnt++;//假装给满了3个鬼 if (n \u0026lt;= 1) p[cnt].n = 1, p[cnt].go[0] = cnt, s[1] = t[1] = cnt++; BFS(); printf(\u0026#34;%d\\n\u0026#34;, dir[t[0]][t[1]][t[2]]); memset(p, 0, sizeof p); } return 0; } 以下代码是双向的bfs，测得是590ms 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cctype\u0026gt; using namespace std; const int M = 210, f = 0xff; char g[M][M]; int w, n, h, s[3], t[3], id[20][20], dir[M][M][M][2], ans; const int dx[] = {-1, 0, 1, 0, 0}; const int dy[] = {0, -1, 0, 1, 0}; inline bool check(int x, int y) { return x \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt;= w \u0026amp;\u0026amp; y \u0026lt;= h; } inline int ID(int a, int b, int c) { return (a \u0026lt;\u0026lt; 16) | (b \u0026lt;\u0026lt; 8) | c; } inline bool move(int a, int b, int ago, int bgo) { return (a == bgo \u0026amp;\u0026amp; b == ago) || ago == bgo; } struct pos{ int x, y, n, go[5]; } p[200]; int BFS(queue\u0026lt;int\u0026gt; \u0026amp;q, int st) { int u = q.front(); q.pop(); int a = u \u0026gt;\u0026gt; 16, b = (u \u0026gt;\u0026gt; 8) \u0026amp; f, c = u \u0026amp; f; if (dir[a][b][c][1 - st] != -1 \u0026amp;\u0026amp; dir[a][b][c][st] != -1) {//如果碰头了就是答案了 return dir[a][b][c][1 - st] + dir[a][b][c][st]; } for (int i = 0; i \u0026lt; p[a].n; i++) { int ago = p[a].go[i]; for (int j = 0; j \u0026lt; p[b].n; j++) { int bgo = p[b].go[j]; if (move(a, b, ago, bgo)) continue; for (int k = 0; k \u0026lt; p[c].n; k++) { int cgo = p[c].go[k]; if (move(a, c, ago ,cgo))continue; if (move(b, c, bgo, cgo))continue; if (dir[ago][bgo][cgo][st] \u0026gt;= 0) continue; dir[ago][bgo][cgo][st] = dir[a][b][c][st] + 1; q.push(ID(ago, bgo, cgo)); } } } return -1; } void double_bfs() { queue\u0026lt;int\u0026gt; q[2]; memset(dir, -1, sizeof dir); q[0].push(ID(s[0], s[1], s[2])); q[1].push(ID(t[0], t[1], t[2])); dir[s[0]][s[1]][s[2]][0] = 0; dir[t[0]][t[1]][t[2]][1] = 0; while (1) {//起点和终点各跑一次 ans = BFS(q[0], 0); if (ans != -1) return; ans = BFS(q[1], 1); if (ans != -1) return; } } int main() { #ifndef ONLINE_JUDGE freopen(\u0026#34;D:/MYCODE/vsCode-c/test.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;D:/MYCODE/vsCode-c/test.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif while (scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;w, \u0026amp;h, \u0026amp;n), w + h + n) { int cnt = 0; for (int i = 0; i \u0026lt; h; i++) { getchar(); for (int j = 0; j \u0026lt; w; j++) { char c = g[i][j] = getchar(); if (c == \u0026#39;#\u0026#39;) continue; p[cnt].x = j, p[cnt].y = i, id[i][j] = cnt; if (islower(c)) s[c - \u0026#39;a\u0026#39;] = cnt; if (isupper(c)) t[c - \u0026#39;A\u0026#39;] = cnt; cnt++; } } for (int i = 0; i \u0026lt; cnt; i++) { p[i].n = 0; for (int j = 0; j \u0026lt; 5; j++) { int nowx = p[i].x + dx[j], nowy = p[i].y + dy[j]; if (g[nowy][nowx] == \u0026#39;#\u0026#39; || !check(nowx, nowy)) continue; p[i].go[p[i].n++] = id[nowy][nowx]; } } if (n \u0026lt;= 2) p[cnt].n = 1, p[cnt].go[0] = cnt, s[2] = t[2] = cnt++; if (n \u0026lt;= 1) p[cnt].n = 1, p[cnt].go[0] = cnt, s[1] = t[1] = cnt++; double_bfs(); printf(\u0026#34;%d\\n\u0026#34;, ans); memset(p, 0, sizeof p); } return 0; } ","date":"2020-08-10T17:00:48+08:00","permalink":"https://example.com/2020/uva1601/","title":"UVA1601"},{"content":"Fill 题意：给你3个没有刻度的杯子，每个杯子的都有自己的容量，现利用这三个杯子量出体积为d的水，现在问最少的倒水量，如果量不到d，就量和d想接近的d' 按照书中的说法这是一个隐式图，求最短路，最短路的评判标志是倒水量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int M = 210; int cap[3], d, ans[M]; bool vis[M][M]; struct nodes{ int v[3], d; nodes(){} nodes(int v0, int v1, int v2, int d) :d(d) { v[0] = v0, v[1] = v1, v[2] = v2; } bool operator \u0026lt; (const nodes\u0026amp; tmp) const { return d \u0026gt; tmp.d; } }; void init() { memset(ans, -1, sizeof ans); memset(vis, 0, sizeof vis); } void update(nodes \u0026amp;u) { for (int i = 0; i \u0026lt; 3; i++) { if (ans[u.v[i]] \u0026lt; 0 || ans[u.v[i]] \u0026gt; u.d) ans[u.v[i]] = u.d; } } void BFS() { init(); scanf(\u0026#34;%d%d%d%d\u0026#34;, cap, cap + 1, cap + 2, \u0026amp;d); priority_queue\u0026lt;nodes\u0026gt; q; nodes s(0, 0, cap[2], 0); q.push(s); vis[0][0] = true; while (q.size()) { nodes u = q.top(); q.pop(); update(u); if (ans[d] \u0026gt; 0) break; for (int i = 0; i \u0026lt; 3; i++) { for (int j = 0; j \u0026lt; 3; j++) { if (j == i) continue; if (!u.v[i] || u.v[j] == cap[j]) continue; int pour = min(cap[j], u.v[i] + u.v[j]) - u.v[j]; nodes v = u; v.v[i] -= pour, v.v[j] += pour, v.d += pour; if (vis[v.v[0]][v.v[1]])continue; vis[v.v[0]][v.v[1]] = true; q.push(v); } } } while (ans[d] \u0026lt; 0 \u0026amp;\u0026amp; d \u0026gt; 0) { d--; } printf(\u0026#34;%d %d\\n\u0026#34;, ans[d], d); } int main () { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) BFS(); return 0; } ","date":"2020-08-09T20:37:14+08:00","permalink":"https://example.com/2020/uva10603/","title":"UVA10603"},{"content":"Mobile Computing 题意：有一个房间，有长为1的木棍，用天平的方式放一些物品，让你求出不超过房间的宽度的最长宽度的，如果误解输出-1 做了两天，习得了两种dfs非枚举子集的办法（到时再回头研究刘神方法），只选择了一种学习，当然另一种也看了 自底向上枚举二叉树，思想有点像哈夫曼建树，选择两个节点来合并，然后就是递归回溯的事 dfs(n) ：代表还剩下 n 个节点可以拼接 w[i] ：代表第 i 个节点的重量，w[i] = 0 则表示该节点已经被用了 l[i]、r[i] ：代表第 i 节点的左右宽度的最大值 值得注意的是在求 l[i] 和 r[i] 时同时要考虑当前另一个节点，例如在计算 l[i] 时，不仅要考虑 左子树的左最大宽度 + 当前节点的左宽度，还要考虑 右子树的左最大宽度 - 当前节点的右宽度，前者很好理解，关键是后者：因为有可能右子树的左最大宽度会超过左子树 具体看图，右子树同理 UVA1354\r显然橙色节点的距离超过了黄色节点 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; using vi = vector\u0026lt;int\u0026gt;; double d, Max, l[10], r[10]; int n, cnt, k = 0; vi w; void dfs(int num) { if (num == 1) { for (int i = 0; i \u0026lt; n; i++) { if (!w[i]) continue; if (l[i] + r[i] \u0026gt; d) continue; Max = max(Max, l[i] + r[i]); } return; } for (int i = 0; i \u0026lt; n; i++) { if (!w[i]) continue; for (int j = 0; j \u0026lt; n; j++) { if (!w[j] || i == j) continue; int neww = w[i] + w[j], tmp1 = w[i], tmp2 = w[j]; double newl = (w[j] * 1.0) / (w[i] + w[j]), newr = 1 - newl; w[i] = neww, w[j] = 0; double tmpl = l[i], tmpr = r[i]; l[i] = max(newl + l[i], l[j] - newr); r[i] = max(newr + r[j], r[i] - newl); cnt--; dfs(num - 1); //回溯 cnt++; w[i] = tmp1, w[j] = tmp2; l[i] = tmpl, r[i] = tmpr; } } } void solve() { memset(l, 0, sizeof l); memset(r, 0, sizeof r); scanf(\u0026#34;%lf%d\u0026#34;, \u0026amp;d, \u0026amp;n); Max = -1, cnt = n; w = vi(n); for (auto \u0026amp;i : w) scanf(\u0026#34;%d\u0026#34;, \u0026amp;i); if (n == 1) { puts(\u0026#34;0\u0026#34;); return; } dfs(n); printf(\u0026#34;%0.10f\\n\u0026#34;, Max); } int main () { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while(T--) solve(); return 0; } ","date":"2020-08-09T15:45:24+08:00","permalink":"https://example.com/2020/uva1354/","title":"UVA1354"},{"content":"Bandwidth 题意：给你一个无向图，让你输出一种序列使得每个节点到该节点在图中相连的节点的最远距离的最小值，直接看题目比较好懂 dfs遍历所有可能的序列，然后求出一个最小值，我的代码用了邻接表 剪枝的话一种是利用计算好最小带宽的一种来剪枝，第二种就是计算未确定位置的节点的最小带宽来剪 按照紫书的指导，剪了两种枝，但是感觉剪一种的速度差不多，两者交上去都是$0ms$，毕竟节点不多，剪一种枝就行了 以下代码是剪了两种枝的，如果只剪一种，只要把28，60，62注释就行了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; char str[200]; bool ext[26], ok[26][26]; int head[26], n, indx[26], vis[26], mind, con[26]; struct es{ int to, next; es(int to = 0, int next = -1) : to (to), next(next) {} }; vector\u0026lt;es\u0026gt; e; vector\u0026lt;char\u0026gt; node, res, ans; void add_edge(int u, int v) { e.push_back(es(v, head[u])); head[u] = e.size() - 1, con[u]++; if (!ext[u]) node.push_back(u + \u0026#39;A\u0026#39;); ext[u] = true; } bool check(int cur, int u) { if (!cur) return false; if (con[u] \u0026gt; mind) return true; for (int i = head[u]; ~i; i = e[i].next) { int v = e[i].to; if (!vis[v]) continue; if (cur - indx[v] \u0026gt;= mind) return true; } return false; } void left(int u, int x = -1) { for (int i = head[u]; ~i; i = e[i].next) { con[e[i].to] += x; } } void dfs(size_t cur) { if (cur == node.size()) { int m = 0; for (int i = cur - 1; i \u0026gt;= 0; i--) { int u = res[i] - \u0026#39;A\u0026#39;; for (int j = head[u]; ~j; j = e[j].next) { int v = e[j].to; m = max(m, abs(i - indx[v])); } } if (m \u0026lt; mind) { mind = m; ans = res; } return; } for (size_t i = 0; i \u0026lt; node.size(); i++) { int u = node[i] - \u0026#39;A\u0026#39;; if (vis[u]) continue; if (check(cur, u)) continue; res[cur] = node[i], indx[u] = cur, vis[u] = true; left(u); dfs(cur + 1); left(u, 1); vis[u] = false; } } void init() { memset(head, -1, sizeof head); e.clear(), ans.clear(), res.clear(), node.clear(); memset(vis, 0, sizeof vis); memset(con, 0, sizeof con); memset(ext, 0, sizeof ext); memset(ok, 0, sizeof ok); mind = 100; } int main () { while (scanf(\u0026#34;%s\u0026#34;, str), str[0] != \u0026#39;#\u0026#39;) { init(); char *tmp = str; for (;;) { int u = tmp[0] - \u0026#39;A\u0026#39;; int len = strlen(tmp); for (int i = 2; tmp[i] != \u0026#39;;\u0026#39; \u0026amp;\u0026amp; i \u0026lt; len; i++) { int v = tmp[i] - \u0026#39;A\u0026#39;; if (ok[u][v]) continue; add_edge(u, v); add_edge(v, u); ok[u][v] = ok[v][u] = true; } if (strchr(tmp, \u0026#39;;\u0026#39;) == nullptr ) break; tmp = strchr(tmp, \u0026#39;;\u0026#39;) + 1; } sort(node.begin(), node.end()); res = vector\u0026lt;char\u0026gt;(node.size()); dfs(0); for (auto i : ans) printf(\u0026#34;%c \u0026#34;, i); printf(\u0026#34;-\u0026gt; %d\\n\u0026#34;, mind); } return 0; } ","date":"2020-08-07T19:53:14+08:00","permalink":"https://example.com/2020/uva140/","title":"UVA140"},{"content":"Krypton Factor 定义一个串是容易串：有相邻的相同的字串；反之就是困难串 让你求只利用前k个大写字母的第n个困难串 dfs模拟一下，值得注意的是剪枝时只看当前串的后缀即可，例如遍历到ABCDEFGH时，就只判断H和G、GH和EF、FGH和CDE、EFGH和ABCD就行了 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int n, L, num = 0; bool ok = true; char ans[100], a[50], b[50]; bool check(int len) { if (!len) return false; for (int i = 1; i + i \u0026lt;= len + 1; i++) { memcpy(a, \u0026amp;ans[len - i + 1], sizeof(char) * i); memcpy(b, \u0026amp;ans[len - i - i + 1], sizeof(char) * i); a[i] = \u0026#39;\\0\u0026#39;, b[i] = \u0026#39;\\0\u0026#39;; if (strcmp(a, b) == 0) return true; } return false; } void dfs(int cur) { if (num \u0026gt; n) return; if (num == n) { size_t len = strlen(ans), s = 0, l = 0; for (size_t i = 0; i \u0026lt; len; i++) { if (s++ == 4) { if (l != 15) printf(\u0026#34; \u0026#34;); s = 1, l++; } if (l == 16) { puts(\u0026#34;\u0026#34;); l = 1; } printf(\u0026#34;%c\u0026#34;, ans[i]); } printf(\u0026#34;\\n%zu\\n\u0026#34;, len); return; } for (int i = 0; i \u0026lt; L; i++) { ans[cur] = i + \u0026#39;A\u0026#39;, ans[cur + 1] = \u0026#39;\\0\u0026#39;; if (check(cur)) continue; num++; dfs(cur + 1); } } int main() { while (scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;L), n + L) { num = 0; dfs(0); memset(ans, 0, sizeof ans); } return 0; } ","date":"2020-08-07T11:57:39+08:00","permalink":"https://example.com/2020/uva129/","title":"UVA129"},{"content":"Prime Ring Problem 题意：给你一个数n，让你求出所有素数环，素数环：利用 1 ~ n来排列组合成的一个环，相邻的两个数的和必须都是素数 直接dfs遍历所有排列，途中要剪枝，如果当前放的数和前面的数的和不是素数就直接剪了 画出解答树更好懂 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int kase = 0, n, arr[30]; bool isp[] = {0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0}; bool vis[30]; void dfs(int cur, int *A) { if (cur == n - 1) { if (!isp[1 + A[n - 1]]) return; bool f = true; for (int i = 0; i \u0026lt; n; i++) { if (f) f = !f; else printf(\u0026#34; \u0026#34;); printf(\u0026#34;%d\u0026#34;, A[i]); } puts(\u0026#34;\u0026#34;); return; } for (int i = 2; i \u0026lt;= n; i++) { if (vis[i]) continue; if (isp[A[cur] + i]) { A[cur + 1] = i; vis[i] = true; dfs(cur + 1, A); vis[i] = false; } } } int main() { arr[0] = 1; bool f = true; while (~scanf(\u0026#34;%d\u0026#34;, \u0026amp;n)) { if (f) f = !f; else puts(\u0026#34;\u0026#34;); printf(\u0026#34;Case %d:\\n\u0026#34;, ++kase); dfs(0, arr); memset(vis, 0, sizeof vis); } return 0; } ","date":"2020-08-06T20:32:38+08:00","permalink":"https://example.com/2020/uva524/","title":"UVA524"},{"content":"Fractions Again?! 给你一个k,让你求所有 $1 / k = 1 / x + 1/ y$ 的答案 $x \\ge y$ 计算可以发现 y 最大不会超过2k,最小是k + 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; using ll = long long; ll n; int main() { while (~scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n)) { vector\u0026lt;ll\u0026gt; a, b; for (ll i = n + 1; i \u0026lt;= n + n; i++) { if (n * i % (i - n) == 0) { a.push_back(n * i / (i - n)); b.push_back(i); } } printf(\u0026#34;%zu\\n\u0026#34;, a.size()); for (size_t i = 0; i \u0026lt; a.size(); i++) { printf(\u0026#34;1/%lld = 1/%lld + 1/%lld\\n\u0026#34;, n, a[i], b[i]); } } return 0; } ","date":"2020-08-06T18:27:25+08:00","permalink":"https://example.com/2020/uva10976/","title":"UVA10976"},{"content":"Maximum Product 给你一个数组，让你求子字串的最大乘积，如果没有就输出0 暴力解就好了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; using ll = long long; int n, kase = 0; int main () { while(~scanf(\u0026#34;%d\u0026#34;, \u0026amp;n)) { ll Max = 0; vector\u0026lt;ll\u0026gt; arr(n); for (auto \u0026amp;x : arr) scanf(\u0026#34;%lld\u0026#34;, \u0026amp;x); for (int i = 0; i \u0026lt; n; i++) { ll tmp = arr[i]; Max = max(Max, tmp); for (int j = i + 1; j \u0026lt; n; j++) { tmp *= arr[j]; Max = max(Max, tmp); } } printf(\u0026#34;Case #%d: The maximum product is %lld.\\n\\n\u0026#34;, ++kase, Max); } return 0; } ","date":"2020-08-06T17:34:18+08:00","permalink":"https://example.com/2020/uva11059/","title":"UVA11059"},{"content":"Division 题意：给你一个数n，让你求出 $abcde / fghij = n$ 的所有结果，a ~ j 的恰好是 0 ~ 9 的数 暴力遍历分子就好了，然后检查分母是否合法就行了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int M = 1e5; int n; bool check(int a, int b) { bool num[10] = {0}; if (b \u0026lt; 10000) num[0] = true; while (a || b) { num[a % 10] = true; num[b % 10] = true; a /= 10, b /= 10; } int x = 0; for (auto i : num) if (i) x++; return x == 10; } bool check(int a) { bool num[10] = {0}; if (a \u0026lt; 10000) num[0] = true; while (a) { num[a % 10] = true; a /= 10; } int x = 0; for (auto i : num) if (i) x++; return x == 5; } int main () { bool f = true; while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;n), n) { if (f) f = false; else puts(\u0026#34;\u0026#34;); bool ok = true; for (int i = 11111; i \u0026lt; M; i++) { if (i % n == 0 \u0026amp;\u0026amp; check(i) \u0026amp;\u0026amp; check(i / n) \u0026amp;\u0026amp; check(i, i / n)) { ok = false; printf(\u0026#34;%05d / %05d = %d\\n\u0026#34;, i, i / n, n); } } if (ok) printf(\u0026#34;There are no solutions for %d.\\n\u0026#34;, n); } return 0; } ","date":"2020-08-06T16:25:28+08:00","permalink":"https://example.com/2020/uva725/","title":"UVA725"},{"content":"Tree Reconstruction 题意：给你一个DFS和一个BFS遍历的树（具体遍历方式都是小的权值优先），让你求出每个节点的子节点 直接说思路：栈的运用，题目说输出任意可能的答案，所以把树当成一个二叉树来做，bfs本质就是树的一层一层的遍历，当一个节点在bfs序中下标为 $x$，则 $x + 1$可以认为是他的兄弟节点，其后面的都是下层的节点；而dfs的本质是一个链式的深度搜索，也就是说dfs中连续的很可能就是树的一条链式。根据以上性质，用栈来模拟dfs的建造过程，再更具上诉bfs的性质来判断某节点是否是栈顶的一个子节点 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, x; int main() { for (; ~scanf(\u0026#34;%d\u0026#34;, \u0026amp;n);) { vector\u0026lt;int\u0026gt; node[1010], dfs(n), bfs(n + 1); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); bfs[x] = i; } for (auto \u0026amp;i : dfs) scanf(\u0026#34;%d\u0026#34;, \u0026amp;i); stack\u0026lt;int\u0026gt; st; int root = dfs[0]; st.push(root); for (int i = 1; i \u0026lt; n; i++) { for (;;) { int fa = st.top(); if (bfs[fa] + 1 \u0026lt; bfs[dfs[i]] || fa == root) { node[fa].push_back(dfs[i]); st.push(dfs[i]); break; } else { st.pop(); } } } for (int i = 1; i \u0026lt;= n; i++) { printf(\u0026#34;%d:\u0026#34;, i); for (auto it : node[i]) { printf(\u0026#34; %d\u0026#34;, it); } puts(\u0026#34;\u0026#34;); } } return 0; } ","date":"2020-08-05T10:12:16+08:00","permalink":"https://example.com/2020/uva10410/","title":"UVA10410"},{"content":"Spatial Structures 类似于计算像素的，读懂题意直接模拟就好了 毒瘤题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; int n, kase = 0; char g[70][70], m[70][70]; vector\u0026lt;ll\u0026gt; ans; void dfs(int r1, int c1, int r2, int c2, ll all, int d, int pos) { if (r1 == r2) { if (m[r1][c1] == \u0026#39;1\u0026#39;) ans.push_back(all + pos * pow(5, d - 1)); return; } int sum1 = 0, sum2 = 0, sum3 = 0, sum4 = 0; for (int i = r1; i \u0026lt;= (r2 + r1) / 2; i++) { for (int j = c1; j \u0026lt;= (c2 + c1) / 2; j++) { sum1 += m[i][j] - \u0026#39;0\u0026#39;; } } for (int i = r1; i \u0026lt;= (r2 + r1) / 2; i++) { for (int j = (c1 + c2) / 2 + 1; j \u0026lt;= c2; j++) { sum2 += m[i][j] - \u0026#39;0\u0026#39;; } } for (int i = (r1 + r2) / 2 + 1; i \u0026lt;= r2; i++) { for (int j = c1; j \u0026lt;= (c1 + c2) / 2; j++) { sum3 += m[i][j] - \u0026#39;0\u0026#39;; } } for (int i = (r1 + r2) / 2 + 1; i \u0026lt;= r2; i++) { for (int j = (c1 + c2) / 2 + 1; j \u0026lt;= c2; j++) { sum4 += m[i][j] - \u0026#39;0\u0026#39;; } } int sum = sum1 + sum2 + sum3 + sum4; ll x = 0; if (d) x = all + pos*pow(5, d - 1); if (sum == (r2 - r1 + 1) * (c2 - c1 + 1)) { if (x) ans.push_back(x); if (d == 0) ans.push_back(0); return; } if (sum1 != 0) dfs(r1, c1, (r2 + r1) / 2, (c2 + c1) / 2, x, d + 1, 1); if (sum2 != 0) dfs(r1, (c1 + c2) / 2 + 1, (r2 + r1) / 2, c2, x, d + 1, 2); if (sum3 != 0) dfs((r1 + r2) / 2 + 1, c1, r2, (c1 + c2) / 2, x, d + 1, 3); if (sum4 != 0) dfs((r1 + r2) / 2 + 1, (c1 + c2) / 2 + 1, r2, c2, x, d + 1, 4); } int main() { bool flag = true; for (; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n), n;) { if (flag) flag = !flag; else puts(\u0026#34;\u0026#34;); if (n \u0026lt; 0) { int x; for (int i = 1; i \u0026lt;= -n; i++) for (int j = 1; j \u0026lt;= -n; j++) g[i][j] = \u0026#39;.\u0026#39;; for (; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x), ~x;) { int tmp[100] = {0}, len; int r1 = 1, c1 = 1 , r2 = -n, c2 = -n; for (len = 0; x; len++) { tmp[len] = x % 5; x /= 5; } for (int i = 0; i \u0026lt; len; i++) { int tp = tmp[i]; if (tp == 1) r2 = (r2 + r1) / 2, c2 = (c2 + c1) / 2; if (tp == 2) c1 = (c1 + c2) / 2 + 1, r2 = (r1 + r2) / 2; if (tp == 3) r1 = (r1 + r2) / 2 + 1, c2 = (c1 + c2) / 2; if (tp == 4) r1 = (r1 + r2) / 2 + 1, c1 = (c1 + c2) / 2 + 1; } for (int i = r1; i \u0026lt;= r2; i++) for (int j = c1; j \u0026lt;= c2; j++) g[i][j] = \u0026#39;*\u0026#39;; } printf(\u0026#34;Image %d\\n\u0026#34;, ++kase); for (int i = 1; i \u0026lt;= -n; i++) { for (int j = 1; j \u0026lt;= -n; j++){ printf(\u0026#34;%c\u0026#34;, g[i][j]); } puts(\u0026#34;\u0026#34;); } }else { for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%s\u0026#34;, \u0026amp;m[i][1]); dfs(1, 1, n, n, 0, 0, 0); int len = ans.size(); sort(ans.begin(), ans.end()); printf(\u0026#34;Image %d\\n\u0026#34;, ++kase); int h = 0, f = 1; for (int i = 0; i \u0026lt; len; i++) { if (f) f = 0; else printf(\u0026#34; \u0026#34;); printf(\u0026#34;%lld\u0026#34;, ans[i]); if (++h == 12 \u0026amp;\u0026amp; i != len - 1) { h = 0; f = 1; puts(\u0026#34;\u0026#34;); } } if (len != 0) puts(\u0026#34;\u0026#34;); printf(\u0026#34;Total number of black nodes = %d\\n\u0026#34;, len); ans.clear(); } } return 0; } ","date":"2020-08-04T18:02:01+08:00","permalink":"https://example.com/2020/uva806/","title":"UVA806"},{"content":"Petri Net Simulation 每个T变迁都有限制，必须是指定的P库有足够的token才行（注意，T指定的P库不一定只有一个），直接模拟就好了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int p[110], np, nt, kase = 0; struct T { int in[110], out[110]; T() { memset(in, 0, sizeof in); memset(out, 0, sizeof out); } }; int main() { for (; scanf(\u0026#34;%d\u0026#34;, \u0026amp;np), np;) { for (int i = 1; i \u0026lt;= np; i++) { scanf(\u0026#34;%d\u0026#34;, p + i); } scanf(\u0026#34;%d\u0026#34;, \u0026amp;nt); int x; T ts[110]; for (int i = 1; i \u0026lt;= nt; i++) { for (; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x), x;) { if (x \u0026lt; 0) ts[i].in[-x]++; else ts[i].out[x]++; } } int nf, n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;nf); bool ok = true; for (n = 0; n \u0026lt; nf \u0026amp;\u0026amp; ok;) { for (int i = 1; i \u0026lt;= nt; i++) { ok = true; for (int j = 1; j \u0026lt;= np; j++) { if (p[j] \u0026lt; ts[i].in[j]) { ok = false; break; } } if (ok) { for (int j = 1; j \u0026lt;= np; j++) { p[j] -= ts[i].in[j]; p[j] += ts[i].out[j]; } n++; break; } } } vector\u0026lt;int\u0026gt; ans; for (int i = 1; i \u0026lt;= np; i++) { if (p[i] != 0) { ans.push_back(i); } } if (n \u0026lt; nf) printf(\u0026#34;Case %d: dead after %d transitions\\n\u0026#34;, ++kase, n); else printf(\u0026#34;Case %d: still live after %d transitions\\n\u0026#34;, ++kase, nf); printf(\u0026#34;Places with tokens:\u0026#34;); for (auto i : ans) { printf(\u0026#34; %d (%d)\u0026#34;, i, p[i]); } puts(\u0026#34;\\n\u0026#34;); memset(p, 0, sizeof p); } return 0; } ","date":"2020-08-04T14:26:40+08:00","permalink":"https://example.com/2020/uva804/","title":"UVA804"},{"content":"Equilibrium Mobile 题意：给你一个天平，修改某些节点可以使得天平平衡，让你求出最小的修改数量 竟然是一道思维题，不行，这题要写写题解 思路： 假设这个数是一个满二叉树的，并且每个叶子节点每个叶子节点的重量（权值）都不一样，则最少的修改次数就是：叶子节点数 - 1，具体策略就是找一个叶子节点为基准点，设其重量为$x$，然后把其余的叶子节点的重量都修改成$x$，设数的深度为$h$，则此时整棵树的的重量为 $x \\times 2 ^ {h - 1}$ 对于其他情况，我们可以根据上述的特殊情况来推导，假设以某个叶子节点为基准点，然后计算修改后整棵树的重量（根据公式 $x \\times 2 ^ {h - 1}$） 所以策略就是，计算每个叶子节点以其为基准点修改后的整棵树的重量，这样计算下去，可能会出现计算结果相同的情况，就意味着以该叶子节点为基准点修改时，有不需要修改的叶子节点 那么我们就可以统计以每个叶子节点为基准点修改后的整棵树的重量的值，出现最多次数的就说明以该叶子节点为基准点修改，有最多的叶子节点不需要修改，固需要修改的叶子节点个数最少 剩下的就是代码实现了，由于重量可能很大，固用哈希来存放该重量的数量 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll = long long; int t, num; char str[1000005]; unordered_map\u0026lt;ll, int\u0026gt; myhash; void dfs(int l, int r, ll d) { if (str[l] == \u0026#39;[\u0026#39;) { int l_indx = l + 1, p = 0; while (l_indx \u0026lt; r) { if (str[l_indx] == \u0026#39;[\u0026#39;) p++; if (str[l_indx] == \u0026#39;]\u0026#39;) p--; if (p == 0) break; l_indx++; } int r_indx = strchr(\u0026amp;str[l_indx], \u0026#39;,\u0026#39;) - \u0026amp;str[l_indx] + l_indx; dfs(l + 1, l_indx, d + 1); dfs(r_indx + 1, r - 1, d + 1); return; } ll w = 0; sscanf(\u0026amp;str[l], \u0026#34;%lld\u0026#34;, \u0026amp;w); myhash[w * (1 \u0026lt;\u0026lt; d)]++; num++; } int main () { scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { myhash.clear(); num = 0; scanf(\u0026#34;%s\u0026#34;, str); int len = strlen(str), ans = -1; dfs(0, len - 1, 0); for (auto i : myhash) ans = max(ans, i.second); printf(\u0026#34;%d\\n\u0026#34;, num - ans); } return 0; } ","date":"2020-08-03T20:27:46+08:00","permalink":"https://example.com/2020/uva12166/","title":"UVA12166"},{"content":"Patrol Robot BFS进阶题 题意：有个移动的机器人，从（1， 1）点出发，目标是（m， n）点，0为可以通过的点，1为障碍点，机器人一次最多只能穿越k障碍，问你最少要走多少步到达终点 BFS走，要注意个是要记录到达障碍点的最短穿越障碍个数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, m, g[25][25], t, k; const int dx[] = {-1, 0, 1, 0}; const int dy[] = {0, -1, 0, 1}; inline bool check(int x, int y) { return x \u0026gt;= 1 \u0026amp;\u0026amp; y \u0026gt;= 1 \u0026amp;\u0026amp; x \u0026lt;= n \u0026amp;\u0026amp; y \u0026lt;= m; } struct coo{ int x, y, d, k; coo(){} coo(int x, int y, int d, int k) : x(x), y(y), d(d), k(k){} }; void bfs() { queue\u0026lt;coo\u0026gt; q; bool vis[25][25][25] = {0}; vis[1][1][0] = g[1][1] == 1; q.push(coo(1, 1, 0, g[1][1] == 1)); while (q.size()) { coo u = q.front(); q.pop(); if (vis[u.y][u.x][u.k]) continue; vis[u.y][u.x][u.k] = true; if (u.x == n \u0026amp;\u0026amp; u.y == m) { printf(\u0026#34;%d\\n\u0026#34;, u.d); return; } for (int i = 0; i \u0026lt; 4; i++) { int x = u.x + dx[i], y = u.y + dy[i]; if (!check(x, y)) continue; if (g[y][x]) { if (u.k + 1 \u0026gt; k) continue;//如果穿越障碍个数比之前算的还大就不计入 q.push(coo(x, y, u.d + 1, u.k + 1)); } else { q.push(coo(x, y, u.d + 1, 0)); } } } puts(\u0026#34;-1\u0026#34;); } int main () { scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;m, \u0026amp;n, \u0026amp;k); for (int i = 1; i \u0026lt;= m; i++) for (int j = 1; j \u0026lt;= n; j++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;g[i][j]); bfs(); memset(g, 0, sizeof g); } return 0; } ","date":"2020-08-03T16:26:13+08:00","permalink":"https://example.com/2020/uva1600/","title":"UVA1600"},{"content":"Knight Moves 题意：在象棋里，给马的起点和终点，计算最小移动步数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;bits/stdc++.h\u0026gt; #define mk(a, b) make_pair(a, b) using namespace std; using pii = pair\u0026lt;int, int\u0026gt;; using pdi = pair\u0026lt;pii, int\u0026gt;; int sx, sy, ex, ey; bool vis[10][10]; char a[5], b[5]; const int dx[] = {-2, -1, 1, 2, 2, 1, -1, -2}; const int dy[] = {-1, -2, -2, -1, 1, 2, 2, 1}; inline bool cherk(int x, int y) { return x \u0026gt; 0 \u0026amp;\u0026amp; y \u0026gt; 0 \u0026amp;\u0026amp; x \u0026lt; 9 \u0026amp;\u0026amp; y \u0026lt; 9; } void print(int num) { printf(\u0026#34;To get from %s to %s takes %d knight moves.\\n\u0026#34;, a, b, num); } void bfs() { queue\u0026lt;pdi\u0026gt; q; q.push(mk(mk(sx, sy), 0)); vis[sx][sy] = true; while (q.size()) { int x = q.front().first.first, y = q.front().first.second; int num = q.front().second; q.pop(); if (x == ex \u0026amp;\u0026amp; y == ey) { print(num); return;} for (int i = 0; i \u0026lt; 8; i++) { int l = x + dx[i], r = y + dy[i]; if (cherk(l, r) \u0026amp;\u0026amp; !vis[l][r]) { q.push(mk(mk(l, r), num + 1)); vis[x][y] = true; } } } } int main () { #ifndef ONLINE_JUDGE freopen(\u0026#34;test.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;test.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif while (~scanf(\u0026#34;%s %s\u0026#34;, a, b)) { sx = a[0] - \u0026#39;a\u0026#39; + 1, sy = a[1] - \u0026#39;0\u0026#39;; ex = b[0] - \u0026#39;a\u0026#39; + 1, ey = b[1] - \u0026#39;0\u0026#39;; bfs(); memset(vis, 0, sizeof vis); } return 0; } ","date":"2020-08-02T16:15:00+08:00","permalink":"https://example.com/2020/uva439/","title":"UVA439"},{"content":"Tree Recovery 给你一个二叉树的先序和中序遍历，输出对应的后序遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; char pre[30], in[30]; void dfs(int a, int b, int c, int d) { if (c \u0026gt; d) return; char tmp = pre[a]; int indx = c; while (in[indx] != tmp) indx++; dfs(a + 1, a + indx - c, c, indx - 1); dfs(a + indx - c + 1, b, indx + 1, d); printf(\u0026#34;%c\u0026#34;, tmp); } int main () { while (~scanf(\u0026#34;%s%s\u0026#34;, pre, in)) { int len = strlen(pre); dfs(0, len - 1, 0, len - 1); puts(\u0026#34;\u0026#34;); } return 0; } ","date":"2020-08-02T15:35:18+08:00","permalink":"https://example.com/2020/uva536/","title":"UVA536"},{"content":"S-Trees 题意：一棵二叉树，每个层节点都有有个逻辑布尔变量，0往左走，1往右走，给你最后一层的结果值，再给你每个变量的取值，问你最后走到的最后一层叶子节点的值 这题有点迷，一开始忘记记录变量的顺序尽然也过了，后来记录了也能过 不考虑变量的顺序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, k, kase = 0;; char res[600], in[10]; void dfs(int indx, int x) { if (indx == n) { printf(\u0026#34;%c\u0026#34;, res[x - (1 \u0026lt;\u0026lt; n)]); return; } if (in[indx] == \u0026#39;0\u0026#39;) dfs(indx + 1, x \u0026lt;\u0026lt; 1); else dfs(indx + 1, x \u0026lt;\u0026lt; 1 | 1); } int main () { while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;n), n) { char tmp[10]; for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%s\u0026#34;, tmp); } scanf(\u0026#34;%s\u0026#34;, res); printf(\u0026#34;S-Tree #%d:\\n\u0026#34;, ++kase); scanf(\u0026#34;%d\u0026#34;, \u0026amp;k); while (k--) { scanf(\u0026#34;%s\u0026#34;, in); dfs(0, 1); } puts(\u0026#34;\\n\u0026#34;); } return 0; } 考虑变量的顺序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, k, num[10], kase = 0;; char res[600], in[10]; void dfs(int indx, int x) { if (indx == n) { printf(\u0026#34;%c\u0026#34;, res[x - (1 \u0026lt;\u0026lt; n)]); return; } if (in[num[indx]] == \u0026#39;0\u0026#39;) dfs(indx + 1, x \u0026lt;\u0026lt; 1); else dfs(indx + 1, x \u0026lt;\u0026lt; 1 | 1); } int main () { #ifndef ONLINE_JUDGE freopen(\u0026#34;test.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;test.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;n), n) { char tmp[10]; for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%s\u0026#34;, tmp); num[i] = tmp[1] - \u0026#39;0\u0026#39; - 1; } scanf(\u0026#34;%s\u0026#34;, res); printf(\u0026#34;S-Tree #%d:\\n\u0026#34;, ++kase); scanf(\u0026#34;%d\u0026#34;, \u0026amp;k); while (k--) { scanf(\u0026#34;%s\u0026#34;, in); dfs(0, 1); } puts(\u0026#34;\\n\u0026#34;); } return 0; } ","date":"2020-08-02T14:41:02+08:00","permalink":"https://example.com/2020/uva712/","title":"UVA712"},{"content":"Parentheses Balance 让你判断括号是否合法，栈的经典例题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int t; int main () { scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); getchar(); while (t--) { char str[150]; fgets(str, sizeof str, stdin); stack\u0026lt;char\u0026gt; st; for (int i = 0; str[i] != \u0026#39;\\n\u0026#39;; i++) { if (str[i] == \u0026#39;)\u0026#39; \u0026amp;\u0026amp; st.size() \u0026amp;\u0026amp; st.top() == \u0026#39;(\u0026#39;) st.pop(); else if (str[i] == \u0026#39;]\u0026#39; \u0026amp;\u0026amp; st.size() \u0026amp;\u0026amp; st.top() == \u0026#39;[\u0026#39;) st.pop(); else st.push(str[i]); } if (st.empty()) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } return 0; } ","date":"2020-08-02T09:51:25+08:00","permalink":"https://example.com/2020/uva672/","title":"UVA672"},{"content":"Abbott\u0026rsquo;s Revenge 题意：给你起点和终点，每个点面向不同的方向有不用的指定方向，问你从起点到终点最短路 BFS就好，但是要注意的是每个点都有不用的方向，所以要多加一维来保存这些方向，即每个点相当于是4个点 一道值得学习深究的一题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const char dis[] = \u0026#34;NESW\u0026#34;, go[] = \u0026#34;RLF\u0026#34;; const int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, 1, 0, -1 }; int sx, sy, rx, ry, ex, ey, rd, d[15][15][4]; bool ok[15][15][4][3]; inline int get_dis(char c) { return strchr(dis, c) - dis; } inline int get_go(char c) { return strchr(go, c) - go; } inline bool cherk(int x, int y) { return x \u0026gt; 0 \u0026amp;\u0026amp; x \u0026lt;= 9 \u0026amp;\u0026amp; y \u0026gt; 0 \u0026amp;\u0026amp; y \u0026lt;= 9; } struct nodes{ int x, y, d; nodes(int x = 0, int y = 0, int d = 0) : x(x), y(y), d(d) {} }pre[15][15][4]; nodes work(nodes \u0026amp;node, int i) { int dr = node.d; if (i == 0) dr = (dr + 1) % 4; if (i == 1) dr = (dr + 3) % 4; return nodes(node.x + dx[dr], node.y + dy[dr], dr); } void print(nodes last) { vector\u0026lt;nodes\u0026gt; ans; while (1){ ans.push_back(last); if (d[last.x][last.y][last.d] == 1) break; last = pre[last.x][last.y][last.d]; } ans.push_back(nodes(sx, sy, 0)); reverse(ans.begin(), ans.end()); int k = 0; printf(\u0026#34; \u0026#34;); for (auto i : ans) { if (k++ \u0026amp;\u0026amp; k % 10 == 1) printf(\u0026#34;\\n \u0026#34;); printf(\u0026#34; (%d,%d)\u0026#34;, i.x, i.y); } puts(\u0026#34;\u0026#34;); } void bfs() { queue\u0026lt;nodes\u0026gt; q; q.push(nodes(rx, ry, rd)); d[rx][ry][rd] = 1; while (q.size()) { nodes node = q.front(); q.pop(); int x = node.x, y = node.y, dir = node.d; if (x == ex \u0026amp;\u0026amp; y == ey) { print(node); return; } for (int i = 0; i \u0026lt; 3; i++) { if (!ok[x][y][dir][i]) continue; nodes nxt = work(node, i); if (!cherk(nxt.x, nxt.y) || d[nxt.x][nxt.y][nxt.d] != 0) continue; d[nxt.x][nxt.y][nxt.d] = d[x][y][dir] + 1; pre[nxt.x][nxt.y][nxt.d] = node; q.push(nxt); } } puts(\u0026#34; No Solution Possible\u0026#34;); } void init() { memset(ok, 0, sizeof ok); memset(d, 0, sizeof d); } int main() { char str[100], w, ch[100]; int x, y; while (1) { scanf(\u0026#34;%s\u0026#34;, str); if (strcmp(str, \u0026#34;END\u0026#34;) == 0) break; puts(str); scanf(\u0026#34;%d%d %c%d%d\u0026#34;, \u0026amp;sx, \u0026amp;sy, \u0026amp;w, \u0026amp;ex, \u0026amp;ey); rd = get_dis(w); rx = sx + dx[rd], ry = sy + dy[rd]; while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;x), x) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;y); while (scanf(\u0026#34;%s\u0026#34;, ch), ch[0] != \u0026#39;*\u0026#39;) { int len = strlen(ch); for (int i = 1; i \u0026lt; len; i++) { ok[x][y][get_dis(ch[0])][get_go(ch[i])] = true; } } } bfs(); init(); } return 0; } ","date":"2020-08-01T15:56:21+08:00","permalink":"https://example.com/2020/uva816/","title":"UVA816"},{"content":"Ordering Tasks 题意：给你一堆未知数的大小关系，让你输出可能的总体大小关系 简化了拓扑排序，只因根据题中的意思了解到一定是DAG 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int M = 110; int m, n, vis[M]; bool g[M][M]; vector\u0026lt;int\u0026gt; ans; void dfs(int u) { vis[u] = true; for (int i = 1; i \u0026lt;= m; i++) { if (!vis[i] \u0026amp;\u0026amp; g[u][i]) { dfs(i); } } ans.push_back(u); } int main() { while (scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;m, \u0026amp;n), m + n) { int x, y; for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); g[x][y] = true; } for (int i = 1; i \u0026lt;= m; i++) { if (vis[i]) continue; dfs(i); } reverse(ans.begin(), ans.end()); for (auto i : ans) printf(\u0026#34;%d \u0026#34;, i); puts(\u0026#34;\u0026#34;); ans.clear(); memset(g, 0, sizeof g); memset(vis, 0, sizeof vis); } return 0; } ","date":"2020-08-01T09:47:35+08:00","permalink":"https://example.com/2020/uva10305/","title":"UVA10305"},{"content":"Oil Deposits 给你一个矩形图，让你求连通的“@”块，一个连通的定义是该点的八个方向都是连通的，dfs就行了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int m, n, cont[110][110]; char g[110][110]; void dfs(int x, int y, int num) { if (x \u0026lt; 0 || y \u0026lt; 0 || x \u0026gt;= m || y \u0026gt;= n || cont[x][y] || g[x][y] != \u0026#39;@\u0026#39;) return; cont[x][y] = num; for (int i = -1; i \u0026lt;= 1; i++) { for (int j = -1; j \u0026lt;= 1; j++) { if (i != 0 || j != 0) dfs(x + i, y + j, num); } } } int main() { while (scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;m, \u0026amp;n), m \u0026amp;\u0026amp; n) { for (int i = 0; i \u0026lt; m; i++) { scanf(\u0026#34;%s\u0026#34;, g[i]); } int num = 0; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (!cont[i][j] \u0026amp;\u0026amp; g[i][j] == \u0026#39;@\u0026#39;) { dfs(i, j, ++num); } } } printf(\u0026#34;%d\\n\u0026#34;, num); memset(cont, 0, sizeof cont); } return 0; } ","date":"2020-07-31T20:13:07+08:00","permalink":"https://example.com/2020/uva572/","title":"UVA572"},{"content":"The Falling Leaves 二叉树的计算，直接递归读入遍历即可 所有数据要以空行相隔，UVA特色 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int M = 5e5 + 5; int node[M], t = 0; void build(int mid) { int v; scanf(\u0026#34;%d\u0026#34;, \u0026amp;v); if (v == -1) return; node[mid] += v; build(mid - 1); build(mid + 1); } bool read() { int v, mid = M \u0026gt;\u0026gt; 1; scanf(\u0026#34;%d\u0026#34;, \u0026amp;v); if (v == -1) return false; memset(node, 0, sizeof node); node[mid] = v; build(mid - 1); build(mid + 1); return true; } int main() { while (read()) { int indx = 0, f = 1; while (!node[indx]) indx++; printf(\u0026#34;Case %d:\\n\u0026#34;, ++t); for (; node[indx] != 0; indx++) { if (f) f = 0; else printf(\u0026#34; \u0026#34;); printf(\u0026#34;%d\u0026#34;, node[indx]); } puts(\u0026#34;\\n\u0026#34;); } return 0; } ","date":"2020-07-31T19:38:47+08:00","permalink":"https://example.com/2020/uva699/","title":"UVA699"},{"content":"Not so Mobile 题意：天平平衡，题意很好懂，就是让你判断给的天平平不平衡，直接递归读入就好了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int t, w; bool ok; void read(int \u0026amp;w) { int wl, dl, wr, dr; scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;wl, \u0026amp;dl, \u0026amp;wr, \u0026amp;dr); if (wl == 0) read(wl); if (wr == 0) read(wr); w = wl + wr; if (wl * dl != wr * dr) ok = false; } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { ok = true; read(w); if (ok) puts(\u0026#34;YES\u0026#34;); else puts(\u0026#34;NO\u0026#34;); if (t) puts(\u0026#34;\u0026#34;); } return 0; } 总结：这题是一个很特殊的树，在输入时就开始递归，值得学习 ","date":"2020-07-31T17:53:32+08:00","permalink":"https://example.com/2020/uva839/","title":"UVA839"},{"content":"Dropping Balls 题意：小球在一个二叉树上下落，每个节点都有一个开关，起初全是关的，如果节点是开小球往右走，反之往左走，让你求最后一个球落到了哪个节点 如果直接单纯的模拟是会超时的，观察可以发现一个节点的第奇数个球都会落到左子树，第偶数个球都落到了右边，自己草稿模拟一下就好了 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int d, n, t; int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;d, \u0026amp;n); int ans = 1; for (int i = 1; i \u0026lt; d; i++) { if (n \u0026amp; 1) { ans \u0026lt;\u0026lt;= 1; n = (n + 1) \u0026gt;\u0026gt; 1; } else { ans = ans \u0026lt;\u0026lt; 1 | 1; n \u0026gt;\u0026gt;= 1; } } printf(\u0026#34;%d\\n\u0026#34;, ans); } return 0; } ","date":"2020-07-31T11:53:31+08:00","permalink":"https://example.com/2020/uva679/","title":"UVA679"},{"content":"Tree 给你二叉树的中序和先序遍历，让你求从根节点到叶节点的的距离权值和最小，如果有多解，叶节点的权值要小，输出叶节点的权值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int M = 1e4 + 10; string str; int ino[M], posto[M], ans, Max, lson[M], rson[M], len = 0; void dfs(int u, int sum) { if (!lson[u] \u0026amp;\u0026amp; !rson[u]) { if (sum \u0026lt; Max || (sum == Max \u0026amp;\u0026amp; ans \u0026gt; u)) { ans = u, Max = sum; } } if (lson[u] != 0) dfs(lson[u], sum + lson[u]); if (rson[u] != 0) dfs(rson[u], sum + rson[u]); } int build(int a, int b, int c, int d) { if (c \u0026gt; d) return 0; int v = posto[b], indx = c; while (ino[indx] != v \u0026amp;\u0026amp; indx \u0026lt;= d) indx++; int l = indx - c; lson[v] = build(a, a + l - 1, c, indx - 1); rson[v] = build(a + l, b - 1, indx + 1, d); return v; } void init(int *A) { char *s = \u0026amp;str[0]; len = 0; while (1) { sscanf(s, \u0026#34;%d\u0026#34;, A + len++); if (strchr(s, \u0026#39; \u0026#39;) == nullptr) return; s = strchr(s, \u0026#39; \u0026#39;) + 1; } } int main() { while (getline(cin, str)) { init(ino); getline(cin, str); init(posto); build(0, len - 1, 0, len - 1); ans = Max = 1e5; dfs(posto[len - 1], posto[len - 1]); printf(\u0026#34;%d\\n\u0026#34;, ans); memset(lson, 0, sizeof lson); memset(rson, 0, sizeof rson); } return 0; } ","date":"2020-07-31T11:50:26+08:00","permalink":"https://example.com/2020/uva548/","title":"UVA548"},{"content":"Rails 让你判断列车出站是否正确，栈的运用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;stack\u0026gt; using namespace std; const int M = 1e3 + 10; int n, arr[M]; int main() { while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;n), n) { while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;arr[1]), arr[1]) { for (int i = 2; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, arr + i); } stack\u0026lt;int\u0026gt; st; int in = 1, out = 1; bool ok = true; while (out \u0026lt;= n) { if (in == arr[out]) { in++, out++; } else if (st.size() \u0026amp;\u0026amp; st.top() == arr[out]) { st.pop(); out++; } else if (in \u0026lt;= n) { st.push(in++); } else { puts(\u0026#34;No\u0026#34;); ok = false; break; } } if (ok) puts(\u0026#34;Yes\u0026#34;); memset(arr, 0, sizeof arr); } puts(\u0026#34;\u0026#34;); } return 0; } ","date":"2020-07-31T11:48:14+08:00","permalink":"https://example.com/2020/uva514/","title":"UVA514"},{"content":"Matrix Chain Multiplication 矩阵链乘，栈的运用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using pii = pair\u0026lt;int, int\u0026gt;; int n; pii m[30]; char str[100000]; int main() { #ifndef ONLINE_JUDGE freopen(\u0026#34;test.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;test.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 0; i \u0026lt; n; i++) { char a; int x, y; scanf(\u0026#34;\\n%c%d%d\u0026#34;, \u0026amp;a, \u0026amp;x, \u0026amp;y); m[a - \u0026#39;A\u0026#39;] = make_pair(x, y); } getchar(); while (fgets(str, sizeof str, stdin)) { stack\u0026lt;pii\u0026gt; st; int len = strlen(str), ans = 0; if (str[len - 1] == \u0026#39;\\n\u0026#39;) str[len-- - 1] = \u0026#39;\\0\u0026#39;; bool ok = true; for (int i = 0; i \u0026lt; len; i++) { if (isalpha(str[i])) { st.push(m[str[i] - \u0026#39;A\u0026#39;]); } else if (str[i] == \u0026#39;)\u0026#39;) { pii a = st.top(); st.pop(); pii b = st.top(); st.pop(); if (a.first != b.second) { puts(\u0026#34;error\u0026#34;); ok = false; break; } ans += a.first * a.second * b.first;//b * a st.push(make_pair(b.first, a.second)); } } if (ok) printf(\u0026#34;%d\\n\u0026#34;, ans); } return 0; } ","date":"2020-07-31T11:44:20+08:00","permalink":"https://example.com/2020/uva442/","title":"UVA442"},{"content":"Trees on the level 二叉树的建立 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int M = 1e5 + 10; int lson[M], rson[M], cnt, node[M]; bool ok, in[M] = {false};//in记录节点是否存在 vector\u0026lt;int\u0026gt; ans; int newnode() {//申请新的地址 int u = ++cnt; lson[u] = rson[u] = 0; return u; } void newtree() {//建新树 lson[1] = rson[1] = 0; in[1] = false; cnt = 1; } void build(int v, char *s) { int indx = 0, u = 1; while (s[indx] != \u0026#39;)\u0026#39;) { if (s[indx] == \u0026#39;L\u0026#39;) { if (!lson[u]) lson[u] = newnode(); u = lson[u]; } else { if (!rson[u]) rson[u] = newnode(); u = rson[u]; } indx++; } if (in[u]) ok = true; node[u] = v; in[u] = true; } void init() { memset(lson, 0, sizeof lson); memset(rson, 0, sizeof rson); memset(in, 0, sizeof in); memset(node, 0, sizeof node); } bool read() { char str[100]; init(); newtree(); while (scanf(\u0026#34;%s\u0026#34;, str) != EOF) { if (strcmp(\u0026#34;()\u0026#34;, str) == 0) return true; int node; sscanf(\u0026amp;str[1], \u0026#34;%d\u0026#34;, \u0026amp;node); build(node, strchr(str, \u0026#39;,\u0026#39;) + 1); } return false; } void dfs() { queue\u0026lt;int\u0026gt; q; q.push(1); while (q.size()) { int u = q.front(); q.pop(); if (!in[u]) { ok = true; return; } ans.push_back(node[u]); if (lson[u] != 0) q.push(lson[u]); if (rson[u] != 0) q.push(rson[u]); } } int main() { #ifndef ONLINE_JUDGE freopen(\u0026#34;test.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;test.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif while (read()) { dfs(); if (ok) puts(\u0026#34;not complete\u0026#34;); else { bool f = true; for (auto i : ans) { if (f) f = false; else printf(\u0026#34; \u0026#34;); printf(\u0026#34;%d\u0026#34;, i); } puts(\u0026#34;\u0026#34;); } ans.clear(); ok = false; } return 0; } 总结（收获）：在一般情况下利用指针建树和新建节点的原理就是申请新的地址内存（指针），但是如果这样的话在释放内存的时候会很不方便。所以这里我利用了变量模拟地址，即代码中的cnt，cnt = x代表申请了一个地址是x的内存（模拟的），这样的好处就是方便建树和建立新的节点，也没有因为难以释放指针内存的后顾之忧了。 ","date":"2020-07-31T11:19:07+08:00","permalink":"https://example.com/2020/uva122/","title":"UVA122"},{"content":"传送门 题意：给你两个同长数组代表n个人两场比赛的成绩，再给你一个x，某两个数组的和$a_i + b_j \\ge x$，问你两数组组合成满足式子的排名最高和最低是多少。具体看样例就懂了。 思路：此题对于最高排名一定是1，即第一名，而最低排名的话，一开始知道是一个双指针的贪心，但是就是不知道怎么贪，后来看到大佬的想法豁然开朗：只要找到组合后大于等于x的个数有多少就好了。 具体找法：一个数组a大到小排序，一个数组b小到大排序，然后只要从a从头开始一个一个遍历，从b数组中从头找能与a数组的数加起来大于等于x的数就好了，然后记录个数，就是答案 心得：贪心题目是难想，想到之后就很简单，代码量也不大，还有一个比较考验的就是模拟的功力了（从人的思维去想想如果这不是一道编程题，而是一个生活的益智题，你会怎么做？然后再用代码实现,说的简单，感觉还是要多刷题） 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; const int M = 1e5 + 5; int n, x, a[M], b[M]; int main() { #ifndef ONLINE_JUDGE freopen(\u0026#34;test.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;test.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;x); for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%d\u0026#34;, a + i); } for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%d\u0026#34;, b + i); } printf(\u0026#34;1 \u0026#34;); sort(a, a + n); sort(b, b + n); reverse(a, a + n); //a从大到小排序 int j = 0, ans = 0; for (int i = 0; i \u0026lt; n; i++) { while (j \u0026lt; n \u0026amp;\u0026amp; b[j] + a[i] \u0026lt; x) { j++; } if (j \u0026gt;= n) break; ans++; j++; } printf(\u0026#34;%d\u0026#34;, ans); return 0; } ","date":"2020-07-24T19:25:00+08:00","permalink":"https://example.com/2020/olympiad/","title":"Olympiad"},{"content":"传送门 题意：给你一个矩阵，每次进行与行之间的交换，或者是列与列之间的交换，或者查询(x, y)点的值 思路：一开始想着是不是直接就纯模拟算了，后来想想，直接用数组把行和列也记录下来不就好了吗 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;cstdio\u0026gt; using namespace std; const int M = 1e3 + 10; int r[M], c[M], g[M][M], n, m, k; int main() { #ifndef ONLINE_JUDGE freopen(\u0026#34;test.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;test.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;k); for (int i = 1; i \u0026lt;= n; i++) r[i] = i; for (int i = 1; i \u0026lt;= m; i++) c[i] = i; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;g[i][j]); } } while (k--) { char a; int x, y; scanf(\u0026#34;\\n%c %d %d\u0026#34;, \u0026amp;a, \u0026amp;x, \u0026amp;y); if (a == \u0026#39;r\u0026#39;) {//交换操作 r[x] ^= r[y], r[y] ^= r[x], r[x] ^= r[y]; } else if (a == \u0026#39;c\u0026#39;) { c[x] ^= c[y], c[y] ^= c[x], c[x] ^= c[y]; } else { printf(\u0026#34;%d\\n\u0026#34;, g[r[x]][c[y]]); } } return 0; } ","date":"2020-07-24T16:26:14+08:00","permalink":"https://example.com/2020/cosmic_tables/","title":"Cosmic_Tables"},{"content":"传送门 什么鬼，div2也出水题？还是我变强了？😂 题意：给你一个长为n的序列，再给你一个k，你每次都必须要这样做：选择第k个数，把他复制到序列的最后，再把序列的第一个数给删了，问你要操作多少次可以使得序列数组的数全部相同，如果根本不可能通过上述操作使得序列数组的数全部相同，则输出-1 思路：不难发现，如果一开始第k个数及后面的数有出现不同的数的话，是不可能通过上述操作使得整个数组完全相同，如果可能的话，就往k前找，即往左找，找到第一个与第k个数不同的数，输出他的下标就好了（因为要一直删到那个不同的数），模拟一下就好了。 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;cstdio\u0026gt; using namespace std; const int M = 1e5 + 10; int n, k, arr[M]; int main() { #ifndef ONLINE_JUDGE freopen(\u0026#34;test.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;test.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%d\u0026#34;, arr + i); } int tmp = arr[k - 1]; for (int i = k; i \u0026lt; n; i++) { if (arr[i] != tmp) { printf(\u0026#34;-1\u0026#34;); return 0; } } for (int i = k - 2; i \u0026gt;= 0; i--) { if (arr[i] != tmp) { printf(\u0026#34;%d\u0026#34;, i + 1); return 0; } } printf(\u0026#34;0\u0026#34;); return 0; } ","date":"2020-07-24T15:15:22+08:00","permalink":"https://example.com/2020/shooshuns_and_sequence/","title":"Shooshuns_and_Sequence"},{"content":"传送门 题意：旅行者每天都会记录自己的海拔高度，他每天规定走海拔相差不超过1的路线，有一天他的记录丢失了，只剩下几天的，问你他之前有可能到达的最高海拔是多少，如果数据出现矛盾，输出\u0026quot;IMPOSSIBLE\u0026quot; 思路：用两个数组记录天数和当天的海拔高度，如果相隔的海拔差比相隔的天数差还大的话就是矛盾，否则就这样计算相隔天数中可能的最大海拔高度：$MaxHight = ( day[i] + hight[i] - (day[i - 1] - hight[i - 1]) ) / 2$，最后取众多MaxHight的最大值 注意：第一天和最后一天的数据可能没给，所以我们要自己造一个可能的最大高度，例如只给你第3天的海拔高度为5，总共旅行的天数为4，那么我们就自己造一个第一天的高度为7$(5 + 3 - 1)$，第4天的高度为6$(5 + (4 - 3))$，就是一开始没想到这个，wa了2发/(ㄒoㄒ)/~~ 代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int M = 1e5 + 10; int n, m, d[M], h[M]; bool ok = true; int main() { #ifndef ONLINE_JUDGE freopen(\u0026#34;test.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;test.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= m; i++) { scanf(\u0026#34;%d%d\u0026#34;, d + i, h + i); if (i != 1 \u0026amp;\u0026amp; d[i] - d[i - 1] \u0026lt; abs(h[i] - h[i - 1])) { ok = false; } } if (ok) { h[0] = h[1] + d[1] - 1, h[m + 1] = h[m] + (n - d[m]); d[0] = 1, d[m + 1] = n; int Max = h[0]; for (int i = 1; i \u0026lt;= m + 1; i++) { int tmp = (d[i] + h[i] - (d[i - 1] - h[i - 1])) \u0026gt;\u0026gt; 1; Max = max(Max, tmp); } printf(\u0026#34;%d\\n\u0026#34;, Max); } else { printf(\u0026#34;IMPOSSIBLE\\n\u0026#34;); } return 0; } ","date":"2020-07-24T09:56:16+08:00","permalink":"https://example.com/2020/tourists_notes/","title":"Tourist's_Notes"},{"content":"传送门 题意：一个只由1和0组成的十进制数叫做Quasi Binary，例如11（十一）就是，现在给你一个n，让你求出他可能有哪些Quasi Binary的和组成，输出最少的Quasi Binary个数并将他们输出 思路：模拟，用个二维数组记录所有的结果位数结果，然后相加输出。例如32就是记录10、10、10、1、1，然后分别将不同位数的相加得到11（10 + 1），11（10 + 1），10（10 + 0） 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int main() { #ifndef ONLINE_JUDGE freopen(\u0026#34;test.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;test.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int t = n, sum = 0; while (t) { sum = max(t % 10, sum); t /= 10; } printf(\u0026#34;%d\\n\u0026#34;, sum); int tmp, x = 0, y = 0, numset[7][10] = {0}, w = 1; while (n) { tmp = n % 10, y = 0; while (tmp) { numset[x][y++] = w; tmp--; } n /= 10, x++, w *= 10; } for (int i = 0; i \u0026lt; sum; i++) { int res = 0; for (int j = 0; j \u0026lt; 7; j++) { res += numset[j][i]; } printf(\u0026#34;%d \u0026#34;, res); } return 0; } ","date":"2020-07-23T21:08:02+08:00","permalink":"https://example.com/2020/quasi_binary/","title":"Quasi_Binary"},{"content":"传送门 题意：给你个字符串，减去一段子串，是否能将剩下的不改变顺序拼成\u0026quot;CODEFORCES\u0026quot;，能则输出\u0026quot;YES\u0026quot;，否则输出\u0026quot;NO\u0026quot; 思路：直接枚举减去的长度，然后暴力 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; char aim[] = \u0026#34;CODEFORCES\u0026#34;, str[200], tmp[200]; int main() { #ifndef ONLINE_JUDGE freopen(\u0026#34;test.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;test.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif scanf(\u0026#34;%s\u0026#34;, str); if (strcmp(str, aim) == 0) { puts(\u0026#34;YES\u0026#34;); return 0; } int len = strlen(str); for (int i = 1; i \u0026lt;= len; i++) { for (int j = 0; j + i - 1 \u0026lt; len; j++) { int ind = 0; for (int k = 0; k \u0026lt; len; k++) { if (k \u0026lt; j || k \u0026gt; j + i - 1) { tmp[ind++] = str[k]; } } tmp[ind] = \u0026#39;\\0\u0026#39;; if (strcmp(tmp, aim) == 0) { puts(\u0026#34;YES\u0026#34;); return 0; } } } puts(\u0026#34;NO\u0026#34;); return 0; } ","date":"2020-07-23T20:08:59+08:00","permalink":"https://example.com/2020/cutting_banner/","title":"Cutting_Banner"},{"content":"前言 起因是一次力扣周赛时被一道最短论的题给整蒙了，决定这几天恶补图论，正好POJ的刷题题单刷到了图 打算学习图论从零开始，目前刷的题不多 总结 关于存图 不同的存图方式可以使得不同的算法更加方便，例如：邻接表可以使Dijkstra算法在堆优化中方便不少，而邻接矩阵可以使Floyd算法更加方便 关于建图 有一些题目在描述的时候给的数据不好建图，这需要经验的积累 而有一些题目并没有直接说明是图，换句话说能否看出是使用图论的知识来解题也需要经验的累积 关于计算 题目中的要求并不是一成不变的，有时候最短路径并不是仅仅指的是值最短，有时候也有可能题目让你求最大值，但最短路依然可以解 最短路 先从最短路开始刷，刷到后面发现有些题三个算法（Dijkstra、Bellman-Ford、Floyd）都是可以解的 Dijkstra [例题]\n洛谷P4779 【模板】单源最短路径（标准版）\n题意：最短路板子题，不解释 思路：直接用Dijkstra的堆优化做，因为没有负环 直接上代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;locale\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int M = 2e5 + 10; const ll INF = 0x3f3f3f3f; int n, m, s, cnt = 0; struct edges { int w, to, next; edges(int a = 0, int b = 0, int c = -1) : w(b), to(a), next(c) {} }; vector\u0026lt;int\u0026gt; head, dis; vector\u0026lt;edges\u0026gt; edge; inline void add(int u, int v, int w) { edge[++cnt] = edges(v, w, head[u]); head[u] = cnt; } void dij() { vector\u0026lt;bool\u0026gt; vis(n + 1, false); dis = vector\u0026lt;int\u0026gt;(n + 1, INF); priority_queue\u0026lt;pii, vector\u0026lt;pii\u0026gt;, greater\u0026lt;pii\u0026gt; \u0026gt; heap; dis[s] = 0; heap.push(make_pair(0, s)); while (heap.size()) { int u = heap.top().second; heap.pop(); if (vis[u]) continue; vis[u] = true; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to, w = edge[i].w; if (dis[v] \u0026gt; dis[u] + w) { dis[v] = dis[u] + w; heap.push(make_pair(dis[v], v)); } } } } int main() { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;s); head = vector\u0026lt;int\u0026gt;(n + 1, -1); edge = vector\u0026lt;edges\u0026gt;(m + 1); for (int i = 0; i \u0026lt; m; i++) { int u, v, w; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;w); add(u, v, w); } dij(); for (int i = 1; i \u0026lt;= n; i++) { printf(\u0026#34;%d \u0026#34;, dis[i]); } puts(\u0026#34;\u0026#34;); return 0; } 洛谷P1629 邮递员送信\n题意：一个邮递员从一号顶点出发送东西，一次只能送一个，送完就要回到1号节点，求送完后的最短路(注意：有向图的往返) 思路：两次Dijkstra就可以了 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;utility\u0026gt; #define mk(a, b) make_pair(a, b) using namespace std; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; int n, m, cnt = 0; vector\u0026lt;int\u0026gt; dis, ddis, head, head2; struct edges { int to, w, next; edges(int a = 0, int b = 0, int c = -1) : to(a), w(b), next(c) {} }; vector\u0026lt;edges\u0026gt; edge, bk; void init() { head = vector\u0026lt;int\u0026gt;(n + 1, -1); head2 = vector\u0026lt;int\u0026gt;(n + 1, -1); dis = vector\u0026lt;int\u0026gt;(n + 1, INF); ddis = vector\u0026lt;int\u0026gt;(n + 1, INF); edge = vector\u0026lt;edges\u0026gt;(m + 1); bk = vector\u0026lt;edges\u0026gt;(m + 1); } void add(int u, int v, int w) { edge[++cnt] = edges(v, w, head[u]); bk[cnt] = edges(u, w, head2[v]); head[u] = cnt; head2[v] = cnt; } void dij() { priority_queue\u0026lt;pii\u0026gt; heap; vector\u0026lt;bool\u0026gt; vis(n + 1, false); heap.push(mk(0, 1)); while (heap.size()) { int u = heap.top().second; heap.pop(); if (vis[u]) continue; vis[u] = true; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].to, w = edge[i].w; if (dis[v] \u0026gt; dis[u] + w) { dis[v] = dis[u] + w; heap.push(mk(-dis[v], v)); } } } } void dij2() { priority_queue\u0026lt;pii\u0026gt; heap; vector\u0026lt;bool\u0026gt; vis(n + 1, false); heap.push(mk(0, 1)); while (heap.size()) { int u = heap.top().second; heap.pop(); if (vis[u]) continue; vis[u] = true; for (int i = head2[u]; ~i; i = bk[i].next) { int v = bk[i].to, w = bk[i].w; if (ddis[v] \u0026gt; ddis[u] + w) { ddis[v] = ddis[u] + w; heap.push(mk(-ddis[v], v)); } } } } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); init(); for (int i = 0; i \u0026lt; m; i++) { int u, v, w; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;w); add(u, v, w); } dis[1] = ddis[1] = 0; dij(); dij2(); int ans = 0; for (int i = 1; i \u0026lt;= n; i++) { ans += dis[i] + ddis[i]; } printf(\u0026#34;%d\u0026#34;, ans); return 0; } 洛谷P1144 最短路计数\n题意：无向图，每条边的权值都为 1， 求从一号顶点出发到其他顶点的最短路的个数 思路：用个$ans$数组储存最短路的个数，Dijkstra内加个计数条件，如果有松弛操作则$ans$继承上一个节点最短路的个数，如果没用松弛操作，就直接让$ans$加上一节点的$ans$（注：ans[1]初始化为1， 其余都初始化为0） 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; pii; const int M = 1e6 + 5; int n, m, dis[M], head[M], ans[M], cnt = 0; struct es { int to, next; es(int a = 0, int b = -1) : to(a), next(b) {} } e[M \u0026lt;\u0026lt; 2]; void add(int a, int b) { e[++cnt] = es(b, head[a]); head[a] = cnt; } void dij() { for (int i = 2; i \u0026lt;= n; i++) { dis[i] = 0x3f3f3f3f; } ans[1] = 1; vector\u0026lt;bool\u0026gt; vis(n + 1, false); priority_queue\u0026lt;pii\u0026gt; heap; heap.push(make_pair(0, 1)); while (heap.size()) { int u = heap.top().second; heap.pop(); if (vis[u]) continue; vis[u] = true; for (int i = head[u]; ~i; i = e[i].next) { int v = e[i].to; if (dis[v] \u0026gt; dis[u] + 1) {//松弛操作 dis[v] = dis[u] + 1; ans[v] = ans[u]; heap.push(make_pair(-dis[v], v)); } else if (dis[u] + 1 == dis[v]) { ans[v] += ans[u]; ans[v] %= 100003; } } } } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); memset(head, -1, sizeof head); for (int i = 0; i \u0026lt; m; i++) { int u, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); add(u, v); add(v, u); } dij(); for (int i = 1; i \u0026lt;= n; i++) { if (ans[i] \u0026gt;= 100003) ans[i] = 0; printf(\u0026#34;%d\\n\u0026#34;, ans[i]); } return 0; } Bellman-Ford 这个算法更多的不是用来计算最短路，而是用来计算是否有负环或者正环（负环dis初始化为INF，正环dis初始化为0）\n【例题】\nEOlymp - 1453 Ford-Bellman\n题意：给你一个有向图，有负权边，保证没有负环，求1号顶点到各个点的最短距离，如果无法到达顶点，距离输出30000 思路：就是一个很纯正的Bellman - Ford的板子题 直接上代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int INF = 0x3f3f3f3f; int n, m; vector\u0026lt;int\u0026gt; dis; struct edges { int u, v, w; edges(int u = 0, int v = 0, int w = 0) : u(u), v(v), w(w) {} }; vector\u0026lt;edges\u0026gt; e; int add(int a, int b) { //无穷大加任何数还是无穷大 if (a == INF || b == INF) return a; return a + b; } void bf() { bool flag; while (true) { flag = true; for (int j = 0; j \u0026lt; m; j++) { if (dis[e[j].v] \u0026gt; add(dis[e[j].u], e[j].w)) { dis[e[j].v] = dis[e[j].u] + e[j].w; flag = false; } } if (flag) return; } } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); dis = vector\u0026lt;int\u0026gt;(n + 1, INF); for (int i = 0; i \u0026lt; m; i++) { int u, v, w; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;w); e.push_back(edges(u, v, w)); } dis[1] = 0; bf(); for (int i = 1; i \u0026lt;= n; i++) { if (dis[i] == INF) dis[i] = 30000; printf(\u0026#34;%d \u0026#34;, dis[i]); } puts(\u0026#34;\u0026#34;); return 0; } POJ 2240 Arbitrage\n题意：给你一个有向图，判断是否有正环 思路：把字符串的顶点用hash来代替，然后就是标准的Bellman - Ford模板题了,正环判断dis初始化为0 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int n, m, test = 0; double dis[100]; string str; struct es { int u, v; double w; es(int a = 0, int b = 0, double c = 0) : u(a), v(b), w(c) {} }; vector\u0026lt;es\u0026gt; e; bool bf() { for (int i = 1; i \u0026lt;= n - 1; i++) { for (int j = 0; j \u0026lt; m; j++) { if (dis[e[j].v] \u0026lt; dis[e[j].u] * e[j].w) { dis[e[j].v] = dis[e[j].u] * e[j].w; } } } for (int i = 0; i \u0026lt; m; i++) { if (dis[e[i].v] \u0026lt; dis[e[i].u] * e[i].w) { return true; } } return false; } int main() { map\u0026lt;string, int\u0026gt; hsh; while (cin \u0026gt;\u0026gt; n, n) { for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; str; hsh[str] = i; } cin \u0026gt;\u0026gt; m; e = vector\u0026lt;es\u0026gt;(m); for (int i = 0; i \u0026lt; m; i++) { string a, b; double w; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; w \u0026gt;\u0026gt; b; e[i] = es(hsh[a], hsh[b], w); } memset(dis, 0, sizeof dis); dis[1] = 1; if (bf()) { cout \u0026lt;\u0026lt; \u0026#34;Case \u0026#34; \u0026lt;\u0026lt; ++test \u0026lt;\u0026lt; \u0026#34;: Yes\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;Case \u0026#34; \u0026lt;\u0026lt; ++test \u0026lt;\u0026lt; \u0026#34;: No\u0026#34; \u0026lt;\u0026lt; endl; } } return 0; } POJ 3259 Wormholes\n题意：有两种边，一种是双向边，一种是单线负权边，问你是否有负环 思路：双向边和负权边都用邻接表存起来，然后就是普通的Bellman - Ford了 代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int M = 3e3; int n, m, ww, f, dis[510]; struct es { int u, v, w; es(int a = 0, int b = 0, int c = 0) : u(a), v(b), w(c) {} }; vector\u0026lt;es\u0026gt; e; bool bf() { for (int i = 1; i \u0026lt;= n; i++) { bool flag = true; for (int j = 0; j \u0026lt; m + m + ww; j++) { if (dis[e[j].v] \u0026gt; dis[e[j].u] + e[j].w) { dis[e[j].v] = dis[e[j].u] + e[j].w; flag = false; } } if (flag) break; if (i == n) return true;//有负环，因为松弛了 n 次 } return false; } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;f); while (f--) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;ww); int u, v, w; for (int i = 0; i \u0026lt; m; i++) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;w); e.push_back(es(u, v, w)); e.push_back(es(v, u, w)); } for (int i = 0; i \u0026lt; ww; i++) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;w); e.push_back(es(u, v, -w)); } memset(dis, 0x3f, sizeof dis); dis[1] = 0; if (bf()) puts(\u0026#34;YES\u0026#34;); else puts(\u0026#34;NO\u0026#34;); e.clear(); } return 0; } POJ 1860 Currency Exchange\n题意：给你一个有向图，你手中有v元的a货币，每个顶点都是一个货币兑换点，每个兑换点都有自己的兑换费用和兑换比例，并且兑换是双向的，例如 a → b, b → a，但兑换比率和兑换费用不一定一样，由测试样例给，问你从某点出发，回到该点时，即兑换会原本的货币种类，他手中的钱能否变多 思路：判断正环，唯一要注意的就是初始化 $ dis[s] = V $，其余初始化为0 代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int M = 300; int n, m, s; double vv, dis[M] = {0}; //vv是一开始手中的钱的数量 struct es { int u, v; double r, c; es(int a = 0, int b = 0, double c = 0, double d = 0) : u(a), v(b), r(c), c(d) {} } e[M]; bool bf() { for (int i = 1; i \u0026lt;= n - 1; i++) { for (int j = 0; j \u0026lt; m + m; j++) { if (dis[e[j].v] \u0026lt; (dis[e[j].u] - e[j].c) * e[j].r) { dis[e[j].v] = (dis[e[j].u] - e[j].c) * e[j].r; } } } for (int j = 0; j \u0026lt; m + m; j++) { if (dis[e[j].v] \u0026lt; (dis[e[j].u] - e[j].c) * e[j].r) { return true; //手中的钱变多了 } } return false;//手中的钱没变或者少了 } int main() { scanf(\u0026#34;%d%d%d%lf\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;s, \u0026amp;vv); for (int i = 0; i \u0026lt; m; i++) { int u, v; double a, b, c, d; scanf(\u0026#34;%d%d%lf%lf%lf%lf\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;a, \u0026amp;b, \u0026amp;c, \u0026amp;d); e[i \u0026lt;\u0026lt; 1] = es(u, v, a, b); //一个兑换点有从 a -\u0026gt; b, e[i \u0026lt;\u0026lt; 1 | 1] = es(v, u, c, d); //也有从 b -\u0026gt; a } dis[s] = vv; if (bf()) puts(\u0026#34;YES\u0026#34;); else puts(\u0026#34;NO\u0026#34;); return 0; } Floyd POJ 2253 Frogger\n题意：一直青蛙想通过石头跳到另一只青蛙那里，但是他的跳跃能力是有封顶的，即他的能力是有限的，最多能跳1米的话，绝对跳不到1.1米远的石头上，给你石头的坐标，和两只青蛙的坐标，问你青蛙的最远能跳的封顶距离的最小值是多少 思路：一个最短路的变形题，用Floyd比较好想（其他方法也可），转换成人话就是让你求从 a 点到 b 点的路径中，最小边权的最大值是多少，有点绕，自己草稿纸画个图就明白了 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int M = 2e2 + 10; int n, x[M], y[M], test = 0; double dis[M][M]; void Floyd() { for (int k = 1; k \u0026lt;= n; k++) { for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (dis[i][j] \u0026gt; max(dis[i][k], dis[k][j])) { dis[i][j] = max(dis[i][k], dis[k][j]); } // dis[i][j] = min(dis[i][j], max(dis[i][k], dis[k][j]));//更清晰的代码 } } } } int main() { while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;n), n) { scanf(\u0026#34;%d%d%d%d\u0026#34;, \u0026amp;x[1], \u0026amp;y[1], \u0026amp;x[2], \u0026amp;y[2]); double a = x[2] - x[1], b = y[2] - y[1]; dis[1][2] = sqrt(a * a + b * b); for (int i = 3; i \u0026lt;= n; i++) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x[i], \u0026amp;y[i]); for (int j = 1; j \u0026lt; i; j++) { a = x[i] - x[j], b = y[i] - y[j]; dis[i][j] = sqrt(a * a + b * b); dis[j][i] = dis[i][j]; } } Floyd(); printf(\u0026#34;Scenario #%d\\nFrog Distance = %.3f\\n\\n\u0026#34;, ++test, dis[1][2]); memset(dis, 0, sizeof dis); } return 0; } POJ 1125 Stockbroker Grapevine\n题意：给你一个有向图，问你是否能从一点出发到达所有其他顶点，如果有输出该点编号并输出到达这些顶点的最短路中的最大值，否则输出\u0026quot;disjoint\u0026quot; 思路：显然Floyd算法，在Floyd完了之后遍历每个最短路，看看取最短路的最大值和其起点，如果这个最大值是无穷大则说明没有一个顶点可以到达其他顶点 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int M = 110; int n, tm[M][M], dis[M][M]; void floyd() { for (int k = 1; k \u0026lt;= n; k++) { for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); } } } } int main() { #ifndef ONLINE_JUDGE freopen(\u0026#34;test.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;test.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;n), n) { memset(dis, 0x3f, sizeof dis); memset(tm, 0x3f, sizeof tm); for (int i = 1; i \u0026lt;= n; i++) { int m; scanf(\u0026#34;%d\u0026#34;, \u0026amp;m); for (int j = 0; j \u0026lt; m; j++) { int x, y; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); dis[i][x] = y; } } floyd(); int ans = -1, Min = 0x3f3f3f3f; for (int i = 1; i \u0026lt;= n; i++) { int Max = 0; for (int j = 1; j \u0026lt;= n; j++) { if (i != j \u0026amp;\u0026amp; dis[i][j] \u0026gt; Max) { Max = dis[i][j]; } } if (Max \u0026lt; Min) { ans = i; Min = Max; } } if (Min == 0x3f3f3f3f) { puts(\u0026#34;disjoint\u0026#34;); continue; } printf(\u0026#34;%d %d\\n\u0026#34;, ans, Min); } return 0; } Spfa 一种速度极快的最短路算法，但是听说被一位大佬卡死了，但是在一些题目上还是能用的，下面利用这个算法来解决上面的一些题\n存图的方式最好是邻接表法，这样比较方便松弛\n其实道理都差不多，题目的不同，主要修改的就是松弛操作部分的代码\n【例题】\nPOJ 3259 Wormholes\n上面的Bellman - Ford算法的例题，除了存图的方式不同，松弛的操作还是不变 直接上代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int M = 2e4; int n, m, ww, f, dis[510], head[510], cnt = 0; struct es { int to, w, next; es(int a = 0, int b = 0, int c = -1) : to(a), w(b), next(c) {} }; vector\u0026lt;es\u0026gt; e; void add(int u, int v, int w) { e[++cnt] = es(v, w, head[u]); head[u] = cnt; } bool spfa() { queue\u0026lt;int\u0026gt; q; vector\u0026lt;bool\u0026gt; inq(n + 1); vector\u0026lt;int\u0026gt; nums(n + 1, 0); q.push(1); inq[1] = true; nums[1]++; while (q.size()) { int u = q.front(); q.pop(); inq[u] = false; for (int i = head[u]; ~i; i = e[i].next) { int v = e[i].to, w = e[i].w; if (dis[v] \u0026gt; dis[u] + w) { dis[v] = dis[u] + w; if (!inq[v]) { q.push(v); inq[v] = true; nums[v]++; if (nums[v] \u0026gt;= n) return true; } } } } return false; } int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;f); while (f--) { cnt = 0; memset(head, -1, sizeof head); scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;ww); e = vector\u0026lt;es\u0026gt;(m + m + ww + 1); int u, v, w; for (int i = 0; i \u0026lt; m; i++) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;w); add(u, v, w); add(v, u, w); } for (int i = 0; i \u0026lt; ww; i++) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;w); add(u, v, -w); } memset(dis, 0x3f, sizeof dis); dis[1] = 0; if (spfa()) puts(\u0026#34;YES\u0026#34;); else puts(\u0026#34;NO\u0026#34;); e.clear(); } return 0; } 未完待续 ","date":"2020-07-21T22:22:01+08:00","permalink":"https://example.com/2020/%E5%9B%BE%E8%AE%BA%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/","title":"图论刷题总结"},{"content":"传送门\n题意 有 a 个 饼干，和 b 个巧克力 有 n 个 第一类人，有 m 个第二类人 对于第一类人， if (a \u0026gt; b)吃一个饼干，else 吃一个巧克力 对于第二类人， if (a \u0026gt; b)吃一个巧克力，else 吃一个饼干 问你是否有一种方法能让第一类和第二类人都有东西吃，有输出Yes，否则输出No 思考 很显然第一类人优先吃多的（一样多就吃巧克力），第二类人优先吃少的（一样多就吃饼干） 有两种思路，一个是我自己比赛时想到的，一个是x大佬讲的 方法一 一来就判断饼干和巧克力的总数够不够第一类和第二类人吃，如果不够，直接No，如果够如下 先让第二类人吃，方便我们思考，因为东西只会被越吃越少嘛，不可能越吃越多，所以他自始至终都会不会换别的吃 然后就是判断最少的是否够第二类人吃。先讨论最简单的——够，显然如果够的话则第一类人一定够吃，为什么，因为第一类人是优先吃最多的，而我们先判断的是总数都够吃，所以无论怎么吃，不管最多的东西怎么变化，都是够吃的,所以是Yes； 但是如果不够吃呢，直接就是No，为什么，解释起来有点麻烦（比赛时候我就是这里没有想好，一直往别的地方想，自己扰乱了自己的思维）。先这样想，如果不够吃，那么最小的永远都是那一个（饼干或者巧克力一开始最少的）：因为不够吃，所以那一个就会被吃完（即等于0），但是呢第二类人还有没吃到的，他们只会吃最少的那一个，而最少的那一个个数是0了，所以无论如何都吃不了了。 比赛的时候我往别的地方想了（相信不止我会这样想歪，现在想通了，解释一下，可能会有点啰嗦）：就是如果最少的不够第二类人吃的话那就一开始先让第一类人吃，或者中途到了某个关系后交替来吃。但是这样只会让自己陷入窘境，其实这种情况下，无论是让第一类人先吃，还是交替吃，都不会改变第二类人没得吃的结果。因为第一类人的插入只会让最多数量的那个东西变少，一直吃到饼干和巧克力个数一样时，最少的个数依然是最少，即便最少的种类可能会变，但是第二类人能吃的个数不会变。换句话说就是，即便它最少或最多的种类转移了，第二类依然会吃最少的，他不可能可以多吃一个多的那一个（即便饼干和巧克力相等） 详细见代码solve()函数 方法二 第一步和方法一相同，总数不够就No，否则如下 利用一个小规律：先让第二类人吃一次，再让第一类人吃一次，这样的话无论两者大小，饼干数和巧克力数都会各自减一。利用这个特点把人和东西给简化。 第一种可能，东西（饼干或者巧克力）优先有一方优先减到0，而两类人都还有，那么一定是No，因为第二类人只吃最少的，而最少的为0了 第二种可能就是，人优先有一方减到了0，这时候如果是第二类人减到了0，显然就是Yes（道理和方法一中最少数量的东西够第一类人吃是一样的）。如果是第一类人减到了0，那么也就是说只剩下第二类人，因为第二类人只吃最少的，所以只要判断最少的那个东西够不够第二类人吃就行了，够就Yes，不够就No 详细见代码solve2()函数 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef vector\u0026lt;int\u0026gt; vi; typedef vector\u0026lt;long long\u0026gt; vll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;long long, long long\u0026gt; pll; #define debug printf(\u0026#34;(hao)\u0026#34;) #define all(x) x.begin(), x.end() #define rep(i, a, b) for (int i = (a); i \u0026lt; (b); i++) #define clr(a, v) memset(a, v, sizeof(a)) void solve() {//方法一 // int n; ll a, b, n, m; scanf(\u0026#34;%lld%lld%lld%lld\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;n, \u0026amp;m); if (a + b \u0026lt; n + m) printf(\u0026#34;No\\n\u0026#34;); //判断总数够不够吃，不够吃就No else { ll Min = min(a, b); //寻找最小的一堆食物 if (Min \u0026gt;= m) printf(\u0026#34;Yes\\n\u0026#34;); // 最少的够第二类人吃 else printf(\u0026#34;No\\n\u0026#34;); //最少的不够第二类人吃 } } void solve2() {//方法二 // int n; ll a, b, n, m; scanf(\u0026#34;%lld%lld%lld%lld\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;n, \u0026amp;m); if (a + b \u0026lt; n + m) printf(\u0026#34;No\\n\u0026#34;); else { ll temp = min(n, m), tmin = min(a, b); if (tmin \u0026gt;= temp) { //如果人先出现0，即第二种可能 a -= temp, b -= temp, n -= temp, m -= temp;//全部均掉简化 if (m == 0) printf(\u0026#34;Yes\\n\u0026#34;);//第二类人为0 else { //还有第二类人剩下 if (min(a, b) \u0026gt;= m) printf(\u0026#34;Yes\\n\u0026#34;); else printf(\u0026#34;No\\n\u0026#34;); } } else printf(\u0026#34;No\\n\u0026#34;); //食物先出现0，即上述第一种可能 } } // #define LOCAL int main() { std::ios::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(\u0026#34;test.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;test.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { solve(); // solve2(); } return 0; } 反思 在比赛的时候想到了方法一，但是没有认真用代码实现，并且在往深处思考的时候反而被别个可能性干扰了，也没能及时想出方法反驳自己，而是冒出让第一类人先吃的想法解决自己的矛盾，并没有想到就算第一类人吃了耶挽回不了第二类人的命运（没得吃） 感觉自己当时思维会混乱极有可能就是比赛的状态，打得少，做得少 想到方法就往一处想，尽量不要再想别的，或者想到别的发现想不下去就回到之前的状态重新换方向想 总结 模拟就是要看题量如何 思维的严谨和正确性都是题量堆积出来的，经验的多少决定（十分影响）了思维的快慢和正误 所以做刷题，多打比赛，多总结 ","date":"2020-07-06T20:28:19+08:00","permalink":"https://example.com/2020/c.-a-cookie-for-you%E9%A2%98%E8%A7%A3/","title":"C. A Cookie for You题解"},{"content":"传送门\n题意 小A和小B要读书，现在共又 n 本书，对于每本书都有三个参数，$t_i$：阅读的时间、$a_i$：小A喜欢读的书、$b_i$：小B喜欢读的书 现在小A和小B都要读 k 本书，但是他俩只读自己喜欢的书 问你小A和小B最少要读多久可以读到 k 本书，（对于都喜欢的书，时间是可以只算一次的） 如果他俩有一个没读到 k 本书就输出 -1 思路 一道思维贪心题cf好狠呀，网上有很多的解法，大多数都是模拟+贪心，但是我看到了一位大佬的贪心思路，醍醐灌顶，下面就用它的思路了 对于每个书本可以分为以下四类 小A和小B都喜欢的书 只有小A喜欢的书 只有小B喜欢的书 他俩都不喜欢的书 显然最后一类可以不管不要呀，看书长知识，目前只考虑第二三类的书，可以分别用数组$a_n$和$b_n$记录这些书的阅读时间，然后从小到大排序，精彩的来了，把$a_i 和 b_i$合成一本书当作是第一类的书（妙呀,我怎么没想到，太笨了，太菜了，刷题少），然后放入第一类，再来对第一类的书的阅读时间排序，选前 k 个书，记录阅读时间就是最终答案 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef vector\u0026lt;int\u0026gt; vi; typedef vector\u0026lt;long long\u0026gt; vll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;long long, long long\u0026gt; pll; #define debug printf(\u0026#34;(hao)\u0026#34;) #define all(x) x.begin(), x.end() #define rep(i, a, b) for (int i = (a); i \u0026lt; (b); i++) #define clr(a, v) memset(a, v, sizeof(a)) const int M = 2e5 + 10; vi a, b, t; void solve() { int n, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); rep(i, 0, n) { int _t, _a, _b; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;_t, \u0026amp;_a, \u0026amp;_b); if (_a \u0026amp;\u0026amp; _b) t.push_back(_t); // 第一类 else if (_a) a.push_back(_t); // 第二类 else if (_b) b.push_back(_t); //第三类 } sort(all(a)); sort(all(b)); rep(i, 0, (int)min(a.size(), b.size())) t.push_back(a[i] + b[i]);//精辟之处 if ((int)t.size() \u0026lt; k) {//如果不够 k 本，就输出 -1 printf(\u0026#34;-1\\n\u0026#34;); return; } sort(all(t)); int res = 0; rep(i, 0, k) res += t[i]; printf(\u0026#34;%d\\n\u0026#34;, res); } // #define LOCAL int main() { std::ios::sync_with_stdio(false); #ifdef LOCAL freopen(\u0026#34;test.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;test.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif // int T; // scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); // while (T--) solve(); return 0; } 反思 比赛的时候没做到这题，一个字：菜 一开始用结构体来分析每一本书，后来才学到了把书本分类，然后贪心 贪心渐渐地不会了 以后cf前几题看看和贪心有没有关系 总结 这个结构题的题很巧妙地把他拆开，从而没有用到结构题，好处就是排序压力小 这场比赛很喜欢思维题和贪心 当有两个（或多个）共同影响时，要考虑把他们拆开来计算 …… ","date":"2020-07-06T18:00:01+08:00","permalink":"https://example.com/2020/e1.-reading-books-easy-version%E9%A2%98%E8%A7%A3/","title":"E1. Reading Books (easy version)题解"},{"content":"传送门\n题意 给你一个长度为 n 的数组$a_n$，和一个 k，你有一个 x（一开始为0），你有以下两种操作 给 x 加上 1，即$x = x + 1$ 选择一个任意一个$a_i$($0 \\le i \u0026lt; n$)加上 x，然后 x 加上 1 每个元素最多只能被执行一次上诉操作 问你执行上述操作，x 最小为多少可以使得数组所有元素都能整除 k 思路 记录数组的每一个数至少要加多少才可以被 k 整除 寻找上述数中的最大的众数，计算 x 加到多少才可以使得这些数都能被 k 整除。 例如 对于一个数组 {1，1，1，2，3}，k = 6 则其至少要加的数为 {5，5，5，4，3} 显然最大的众数是 5，其个数是 3，那么对于第一个 5 则需要把 x 加到 5 就行了，对于第二个 5 ，就需要再等到下一个能模 6 为 5 的数，显然就是11($5 + 6 = 11$), 而第三个 5 也是同理就是 17，但这个还不是最终答案，因为题目的第二个操作是先给数组加上 x，再让 $x + 1$,所以最终答案就是 18 为什么这样就是对的呢？很简单，如果想要执行题中把所有数都弄成可以整除 k 并且每个数只能执行一次，对于两个相同且不能被 k 整除的数 y，想要把这两个 y 都弄成能被 k 整除，第二个数 y 一定要等到下一次有一个数 x 加上这个 y 使得它能整除 k。 所以我们要求出每个数最少加多少才可以被 k 整除，然后求一个最大的众数，计算最后一个众数需要的最小x（因为最后的 x 一定是停在了能使这些最大众数的最后一个数被 k 整除的结果），记得最后的答案要再加一才是最终答案。 那么其余的非最大众数呢？别担心，这些数在为最大众数服务的时候就能有一个 x 使得他们的一些能被 k 整除。例如上面的例子，我们在把 x 走到 5 的之前就有个4，可以使得数组中的 2 加上这个 4 能被 6 整除 还想不明白就想想模数具有周期性，例如将0 ~ n中的数都摸上 3 ，就会有这么一个规律 ：0 1 2 0 1 2 0 1 2 0 1 2····· 代码如下（求众数有点滑稽，因为我不会利用简单代码的求众数的方法） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef vector\u0026lt;int\u0026gt; vi; typedef vector\u0026lt;long long\u0026gt; vll; typedef pair\u0026lt;int, int\u0026gt; pii; typedef pair\u0026lt;long long, long long\u0026gt; pll; #define debug printf(\u0026#34;(hao)\u0026#34;) #define all(x) x.begin(), x.end() #define rep(i, a, b) for (int i = (a); i \u0026lt; (b); i++) #define clr(a, v) memset(a, v, sizeof(a)) void solve() { long long n, k; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;k); vll arr; rep(i, 0, n) { long long tmp; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;tmp); if (tmp % k != 0) //如果这个数不能被 k 整除 arr.push_back(k - tmp % k); //对于每个数把最少加多少能被 k 整除的数放到数组里 } if (arr.empty()) {//如果数组的数都能被 k 整除，操作次数就使 0 printf(\u0026#34;0\\n\u0026#34;); return; } sort(all(arr)); long long Max = 1, w = arr[0]; int len = arr.size(); for (int i = 1; i \u0026lt; len;) { //求最大众数，方法比较蠢 int sen = 1; //计算出现个数 if (arr[i] == arr[i - 1]) { while (arr[i] == arr[i - 1] \u0026amp;\u0026amp; i \u0026lt; len) { sen++; i++; } } else { i++; } if (Max \u0026lt;= sen) Max = sen, w = arr[i - 1];//如果出现次数比之前算的要多 } printf(\u0026#34;%lld\\n\u0026#34;, w + k * (Max - 1) + 1); } // #define LOCAL int main() { std::ios::sync_with_stdio(false); #ifdef LOCAL freopen(\u0026#34;test.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;test.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) solve(); return 0; } 反思 找规律的能力不强 面对模没有想到他的一个周期性 总结 对连续的数模具有一定周期性 众数的求法不熟练 这题在真正计算的时候用的不是原数组 ","date":"2020-07-06T16:58:31+08:00","permalink":"https://example.com/2020/d.-zero-remainder-array%E9%A2%98%E8%A7%A3/","title":"D. Zero Remainder Array题解"},{"content":"传送门\n题意 给你一串字符串，只有\u0026quot;(\u0026quot; h和\u0026quot;)\u0026ldquo;组成，你每次都能选择一个字符把它移到最左边或者最右边，问你最少移动几次可以使得字符串的括号合法 思路 一道贪心题（比赛的时候没看出来，太菜了😭） 只要计算出合法的括号对，然后用总长度减去合法的括号对的个数，即剩余的不合法长度除以 2 就是最少的步数 例如 ： \u0026ldquo;()))))((((()\u0026rdquo;, 去掉合法的后就是\u0026rdquo;))))((((\u0026quot;, 那么移动的长度就是$8 \\div 2 = 4$就是答案 这题我一开始想复杂了，对于上一个样例，我以为必须要把下标为2 ~ 5（从0开始）的先一道最左边，再把（原本的）6 ~ 9移到最左边，变成这样：\u0026quot;(((())))()()\u0026quot;,总次数是8，所以就很搞了，然而正确答案是把6 ~ 9 移到最左边就合法了，就是这样：\u0026quot;((((()))))()\u0026quot;,总次数就是 4 所以最终的思路就是判断合法的有多少对：在博客中遇到了两种方法，一种是用栈，一种是不用栈（根据括号合法的特性一定要左括号先出现， 即从头到尾遍历，用一个变量来储存左括号出现次数，一旦遇到右括号变量值就自减） 代码如下（用栈）： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef vector\u0026lt;int\u0026gt; vi; #define debug printf(\u0026#34;(hao)\u0026#34;) #define all(x) x.begin(), x.end() #define rep(i, a, b) for (int i = (a); i \u0026lt; (b); i++) #define clr(a, v) memset(a, v, sizeof(a)) void solve() { int n; char bra[55]; stack\u0026lt;char\u0026gt; res; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); scanf(\u0026#34;%s\u0026#34;, bra); for (int i = 0; i \u0026lt; n; i++) { if (res.empty()) res.push(bra[i]); //栈为空，就无论什么括号都放进去 else if (bra[i] == \u0026#39;)\u0026#39;) //如果是右括号 if (res.top() == \u0026#39;(\u0026#39;) res.pop();//栈顶是左括号，就弹出 else res.push(bra[i]); //否则把右括号入栈 else res.push(bra[i]); //如果是左括号，就直接入栈 } printf(\u0026#34;%d\\n\u0026#34;, (int)res.size() \u0026gt;\u0026gt; 1); } // #define LOCAL int main() { std::ios::sync_with_stdio(false); #ifdef LOCAL freopen(\u0026#34;test.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;test.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) solve(); return 0; } 反思 这题我最开始是误会了求最小移动步数，后来发现是操作次数，还是没看出要贪心 遇到括号就直接想想括号的一些小性质（例如：合法的括号长度一定是偶数、括号的合法一定是左括号在前等等） 有括号优先考虑是否要用到栈来辅助 总结 cf的前几题不是思维就是贪心，代码不难，但是找规律难 多刷这种题，我觉得这也是解决一些困难题目的基础 ","date":"2020-07-06T15:59:43+08:00","permalink":"https://example.com/2020/c.-move-brackets%E9%A2%98%E8%A7%A3/","title":"C. Move Brackets题解"},{"content":"传送门\n题意 给一个数 n,问你只进行以下两种操作，要操作最少多少次能够使得 n 为 1： 把 n 除以 6 （前提是可以整除） 把 n 乘 2 输出最少的操作次数，如果无论如何都没办法得到 1，则输出 -1 思路 首先要知道的是，如果对一个数同时进行两个操作就相当于对 n 除以 3 思考一个极端的例子就是：n 的质因子只有 3，那么它一定可以最终得到 1。为什么呢？因为我们可以让每个 3 都乘 2， 这样他就有了因子 6， 便可以做第一个操作了，并且最终得到 1 如果这个数既有 2 又有 3 怎么办？ 很简单，只需要把一对 2 和 3 看成 6，最终剩下的因子如果是 2（因为已经无望再去除以 6 了），则不可能得到 1，如果是 3， 则当成只有因子 3 的数看待（即上述的极端情况） 最后一种情况就是 n 的质因子除了 3 和 2 还有其他的质因子的话，一定最终无法得到 1 所以最终的想法就是：计算出质因子 2 的个数a，和计算出质因子 3 的个数 b, 如果 $a \u0026gt; b$ 则无法得到 1，否则要操作的次数最少为 $(b - a) \\times 2 + a$ 代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; typedef vector\u0026lt;int\u0026gt; vi; #define debug printf(\u0026#34;(hao)\u0026#34;) #define all(x) x.begin(), x.end() #define rep(i, a, b) for (int i = (a); i \u0026lt; (b); i++) #define clr(a, v) memset(a, v, sizeof(a)) //主代码函数 void solve() { int n, a = 0, b = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); while (n % 2 == 0) n /= 2, a++; //计算质因子 2 的个数 while (n % 3 == 0) n /= 3, b++; //计算质因子 3 的个数 if (n != 1) printf(\u0026#34;-1\\n\u0026#34;); //如果质因子有其他 else if (a \u0026gt; b) printf(\u0026#34;-1\\n\u0026#34;); //如果 2 个数比三多，则无法得到 1 else printf(\u0026#34;%d\\n\u0026#34;, (b - a) * 2 + a); } // #define LOCAL int main() { std::ios::sync_with_stdio(false); #ifdef LOCAL freopen(\u0026#34;test.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;test.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) solve(); return 0; } 反思 第一次没做出来是使用了模拟的暴力解法，理论上是过了，第一次提交过了，重判之后又错在了第11个test，后来看了才发现是爆int了一定是因为我第一次打cf比赛的原因 看到int范围就要优先考虑使用long long不然这题我也不会错 最知道思考的是本文的解法，思维题嘛，锻炼自己思维，毕竟不是每道思维题都可以直接模拟 总结 遇到这种题尝试思考因子的问题 在草稿纸上找找规律，毕竟cf就喜欢考这些思维题 ","date":"2020-07-06T15:01:02+08:00","permalink":"https://example.com/2020/b.-multiply-by-2-divide-by-6%E9%A2%98%E8%A7%A3/","title":"B. Multiply by 2, divide by 6题解"},{"content":"1、写在前面 这几天疯狂刷leetcode的dp题，刷到我都想吐了，看到一个题就先往dp想，感觉中毒不浅，话不多说，赶紧开始总结一下我的成长历程心得。\n2、我对dp的看法和理解 首先引入《算法笔记》里的一句话:\n动态规划是一种非常精妙的算法思想，他没有固定的写法、极其灵活，常常需要具体问题具体分析。\n没错正式这种具体问题具体分析的设定让我刷到吐了\n平时在思考动态规划的往往是利用一个小小的公式：递推 = 递归 + 记忆化（下面会赘述我是怎么利用这个公式思考的）\n虽然他是这么说，但是我还是觉得dp的是有套路可循的，例如给dp分类 （背包dp、树形dp、区间dp……），经典题的记忆 （爬楼梯、树塔问题、LIS……）\n一般来说，我思考dp都是从结果往前想的（即从末尾开始想）\ndp的基本使用条件： 1. 拥有重叠子问题、 2. 最优子结构、3.无后效性\ndp思考三步走： 1. 状态定义 → 2.列状态转移方程 → 3.验证方程\n我觉得的动规成长路线：小白 → 利用小公式辅助建立dp → 正常dp三步走思维思考 → 大佬 （我还没触及 将来一定达到( ఠൠఠ )ﾉ）\n3、典型例题 ①爬楼梯（leetcode #70） 题意 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。\n示例 1：\n输入： 2\n输出： 2\n解释： 有两种方法可以爬到楼顶。\n1、 1 阶 + 1 阶\n2、 2 阶\n示例 2：\n输入： 3\n输出： 3\n解释： 有三种方法可以爬到楼顶。\n1、 1 阶 + 1 阶 + 1 阶\n2、 1 阶 + 2 阶\n3、 2 阶 + 1 阶\n分析 （抛开动规，假设我们是小白）我的思考过程，利用上述提到的小小公式（递推 = 递归 + 记忆化\n首先：从末尾结果开始想，如果我们要走到最后一个台阶,那么我们就有两种走到这个台阶的方法：一是从这一个台阶的前一个台阶上来、二是从这个台阶的前第二个台阶上来。如图： 爬楼梯\r这样我们就很容易想到到达最后一个台阶的方法数为到前一个台阶的方法数加上到前第二个台阶的方法数，可能很拗口。看下面的公式就懂了。\n设 dp(n) 为到台阶n的总方法数，这样很容易就能写出这个方法数的公式为：\n$$ dp(n) = dp(n - 1) + dp(n - 2) $$\n不难写出递归代码 1 2 3 4 5 int dp(int n){ if(n == 1 || n == 0) return 1; return dp(n - 1) + dp(n - 2); } 仔细分析一下这个代码，时间复杂度不难发现式O(2^n)，例如假设我们求的是dp(5) 递归\r不难发现有很多重复计算(黄色部分)，这里采取了一个比较好的优化方法\u0026ndash;记忆化递归（是不是觉得很接近那个小公式了？别急看代码）\n1 2 3 4 5 6 7 8 9 const int Max = 50; int memor[Max] = {0}; int dp(int n) { if (n == 1 || n == 0) return 1; if (memor[n] != 0) return memor[n]; memor[n] = dp(n - 1) + dp(n - 2); return memor[n]; } 时间复杂度降到了O(n),就是变成这样 记忆化递归\r1 2 3 两者时间对比： 普通递归计算dp(45) : 3464 ms 记忆化递归计算dp(45) : 1 ms 天壤之别！！！\n回过头来看这题，这题是一个典型的动规问题，那么我是怎么利用那个小公式来思考这个题的状态方程的呢，很简单就是按照刚刚的思路走一遍。 不难发现我们按照那个思路走，其实已经写出了转移状态方程，就是下面这个，并且这个方程的含义就是我们递归时的含义，这就相当于一下完成了dp三步走的前两步。 $$ dp(n) = dp(n - 1) + dp(n - 2) $$\n接下来的一步就是检查（验证）方程，首先我们要思考这道题适不适合用动规的方法来写，这就需要我们验证这个题是否满足1.有重叠子问题，2.有最优子结构。重叠子问题的话，刚刚分析递归的时候已经发现了，并且优化后不会出现重复计算子问题；最优子结构就是分析没有个状态（即dp(n)）是否是最优的解，在一开始分析题目时不难发现每一个台阶的步数只取决于他前两个台阶的步数。 验证方程的最后一步，设定状态边界（我们总不可能让他一直计算下去吧），其实这道题的边界就是我们一开始的递归边界。 到了这里dp的代码就不难了,递归式自顶向下地计算，而我们动规就是自顶向下地思考，自底向上地计算，多说无益，上代码 1 2 3 4 5 6 7 8 9 10 11 12 const int Max = 50; int dp[Max], n; int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); dp[0] = 1, dp[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } printf(\u0026#34;%d\u0026#34;, dp[n]); return 0; } 时间复杂度同样是O(n),虽然还有更快O(logn)的方式解这题，但我们现在是小白呀，下次再聊。 小结 通过这道题我们从小白晋级到了会用小公式来思考dp。 1、首先从末尾结果开始思考 2、思考怎么递归 3、再来就是写出递归的的方程 4、分析递归，去除重叠问题 5、转换成dp思想，直接走dp三步走的第三步，检查是否状态方程，若不满足，回到1看看有没有另一种更好的办法（一般不会出现这种情况),当然还有另一种方法就是在原有的基础上再次优化（这些都是后话）；若满足直接dp走你。 写不动了未完待续……\n","date":"2020-06-27T00:00:00Z","permalink":"https://example.com/2020/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/","title":"动态规划刷题总结"}]